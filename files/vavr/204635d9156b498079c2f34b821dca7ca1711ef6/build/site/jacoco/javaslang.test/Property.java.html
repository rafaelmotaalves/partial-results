<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Property.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.test</a> &gt; <span class="el_source">Property.java</span></div><h1>Property.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.test;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

import java.util.Objects;
import java.util.Random;
import javaslang.*;
import javaslang.control.Option;
import javaslang.control.Try;
import javaslang.control.Try.NonFatalException;

/**
 * A property builder which provides a fluent API to build checkable properties.
 *
 * @author Daniel Dietrich
 * @since 1.2.0
 */
public class Property {

    private final String name;

<span class="fc" id="L29">    private Property(String name) {</span>
<span class="fc" id="L30">        this.name = name;</span>
<span class="fc" id="L31">    }</span>

    /**
     * Defines a new Property.
     *
     * @param name property name
     * @return a new {@code Property}
     * @throws NullPointerException if name is null.
     * @throws IllegalArgumentException if name is empty or consists of whitespace only
     */
    public static Property def(String name) {
<span class="fc" id="L42">        Objects.requireNonNull(name, &quot;name is null&quot;);</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">        if (name.trim().isEmpty()) {</span>
<span class="fc" id="L44">            throw new IllegalArgumentException(&quot;name is empty&quot;);</span>
        }
<span class="fc" id="L46">        return new Property(name);</span>
    }

    private static void logSatisfied(String name, int tries, long millis, boolean exhausted) {
<span class="fc bfc" id="L50" title="All 2 branches covered.">        if (exhausted) {</span>
<span class="fc" id="L51">            log(String.format(&quot;%s: Exhausted after %s tests in %s ms.&quot;, name, tries, millis));</span>
        } else {
<span class="fc" id="L53">            log(String.format(&quot;%s: OK, passed %s tests in %s ms.&quot;, name, tries, millis));</span>
        }
<span class="fc" id="L55">    }</span>

    private static void logFalsified(String name, int currentTry, long millis) {
<span class="fc" id="L58">        log(String.format(&quot;%s: Falsified after %s passed tests in %s ms.&quot;, name, currentTry - 1, millis));</span>
<span class="fc" id="L59">    }</span>

    private static void logErroneous(String name, int currentTry, long millis, String errorMessage) {
<span class="fc" id="L62">        log(String.format(&quot;%s: Errored after %s passed tests in %s ms with message: %s&quot;, name, Math.max(0, currentTry - 1), millis, errorMessage));</span>
<span class="fc" id="L63">    }</span>

    private static void log(String msg) {
<span class="fc" id="L66">        System.out.println(msg);</span>
<span class="fc" id="L67">    }</span>

    /**
     * Creates an Error caused by an exception when obtaining a generator.
     *
     * @param position The position of the argument within the argument list of the property, starting with 1.
     * @param size     The size hint passed to the {@linkplain Arbitrary} which caused the error.
     * @param cause    The error which occurred when the {@linkplain Arbitrary} tried to obtain the generator {@linkplain Gen}.
     * @return a new Error instance.
     */
    private static Error arbitraryError(int position, int size, Throwable cause) {
<span class="fc" id="L78">        return new Error(String.format(&quot;Arbitrary %s of size %s: %s&quot;, position, size, cause.getMessage()), cause);</span>
    }

    /**
     * Creates an Error caused by an exception when generating a value.
     *
     * @param position The position of the argument within the argument list of the property, starting with 1.
     * @param size     The size hint of the arbitrary which called the generator {@linkplain Gen} which caused the error.
     * @param cause    The error which occurred when the {@linkplain Gen} tried to generate a random value.
     * @return a new Error instance.
     */
    private static Error genError(int position, int size, Throwable cause) {
<span class="fc" id="L90">        return new Error(String.format(&quot;Gen %s of size %s: %s&quot;, position, size, cause.getMessage()), cause);</span>
    }

    /**
     * Creates an Error caused by an exception when testing a Predicate.
     *
     * @param cause The error which occurred when applying the {@linkplain java.util.function.Predicate}.
     * @return a new Error instance.
     */
    private static Error predicateError(Throwable cause) {
<span class="fc" id="L100">        return new Error(&quot;Applying predicate: &quot; + cause.getMessage(), cause);</span>
    }

    /**
     * Returns a logical for all quantor of 1 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @return a new {@code ForAll1} instance of 1 variables
     */
    public &lt;T1&gt; ForAll1&lt;T1&gt; forAll(Arbitrary&lt;T1&gt; a1) {
<span class="fc" id="L111">        return new ForAll1&lt;&gt;(name, a1);</span>
    }

    /**
     * Returns a logical for all quantor of 2 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @return a new {@code ForAll2} instance of 2 variables
     */
    public &lt;T1, T2&gt; ForAll2&lt;T1, T2&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2) {
<span class="fc" id="L124">        return new ForAll2&lt;&gt;(name, a1, a2);</span>
    }

    /**
     * Returns a logical for all quantor of 3 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @return a new {@code ForAll3} instance of 3 variables
     */
    public &lt;T1, T2, T3&gt; ForAll3&lt;T1, T2, T3&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3) {
<span class="fc" id="L139">        return new ForAll3&lt;&gt;(name, a1, a2, a3);</span>
    }

    /**
     * Returns a logical for all quantor of 4 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @param a4 4th variable of this for all quantor
     * @return a new {@code ForAll4} instance of 4 variables
     */
    public &lt;T1, T2, T3, T4&gt; ForAll4&lt;T1, T2, T3, T4&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4) {
<span class="fc" id="L156">        return new ForAll4&lt;&gt;(name, a1, a2, a3, a4);</span>
    }

    /**
     * Returns a logical for all quantor of 5 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @param a4 4th variable of this for all quantor
     * @param a5 5th variable of this for all quantor
     * @return a new {@code ForAll5} instance of 5 variables
     */
    public &lt;T1, T2, T3, T4, T5&gt; ForAll5&lt;T1, T2, T3, T4, T5&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5) {
<span class="fc" id="L175">        return new ForAll5&lt;&gt;(name, a1, a2, a3, a4, a5);</span>
    }

    /**
     * Returns a logical for all quantor of 6 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @param a4 4th variable of this for all quantor
     * @param a5 5th variable of this for all quantor
     * @param a6 6th variable of this for all quantor
     * @return a new {@code ForAll6} instance of 6 variables
     */
    public &lt;T1, T2, T3, T4, T5, T6&gt; ForAll6&lt;T1, T2, T3, T4, T5, T6&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6) {
<span class="fc" id="L196">        return new ForAll6&lt;&gt;(name, a1, a2, a3, a4, a5, a6);</span>
    }

    /**
     * Returns a logical for all quantor of 7 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @param &lt;T7&gt; 7th variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @param a4 4th variable of this for all quantor
     * @param a5 5th variable of this for all quantor
     * @param a6 6th variable of this for all quantor
     * @param a7 7th variable of this for all quantor
     * @return a new {@code ForAll7} instance of 7 variables
     */
    public &lt;T1, T2, T3, T4, T5, T6, T7&gt; ForAll7&lt;T1, T2, T3, T4, T5, T6, T7&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7) {
<span class="fc" id="L219">        return new ForAll7&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7);</span>
    }

    /**
     * Returns a logical for all quantor of 8 given variables.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @param &lt;T7&gt; 7th variable type of this for all quantor
     * @param &lt;T8&gt; 8th variable type of this for all quantor
     * @param a1 1st variable of this for all quantor
     * @param a2 2nd variable of this for all quantor
     * @param a3 3rd variable of this for all quantor
     * @param a4 4th variable of this for all quantor
     * @param a5 5th variable of this for all quantor
     * @param a6 6th variable of this for all quantor
     * @param a7 7th variable of this for all quantor
     * @param a8 8th variable of this for all quantor
     * @return a new {@code ForAll8} instance of 8 variables
     */
    public &lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; ForAll8&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; forAll(Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7, Arbitrary&lt;T8&gt; a8) {
<span class="fc" id="L244">        return new ForAll8&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7, a8);</span>
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll1&lt;T1&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;

<span class="fc" id="L259">        ForAll1(String name, Arbitrary&lt;T1&gt; a1) {</span>
<span class="fc" id="L260">            this.name = name;</span>
<span class="fc" id="L261">            this.a1 = a1;</span>
<span class="fc" id="L262">        }</span>

        /**
         * Returns a checkable property that checks values of the 1 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 1-ary predicate
         * @return a new {@code Property1} of 1 variables.
         */
        public Property1&lt;T1&gt; suchThat(CheckedFunction1&lt;T1, Boolean&gt; predicate) {
<span class="fc" id="L271">            final CheckedFunction1&lt;T1, Condition&gt; proposition = (t1) -&gt; new Condition(true, predicate.apply(t1));</span>
<span class="fc" id="L272">            return new Property1&lt;&gt;(name, a1, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll2&lt;T1, T2&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;

<span class="fc" id="L290">        ForAll2(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2) {</span>
<span class="fc" id="L291">            this.name = name;</span>
<span class="fc" id="L292">            this.a1 = a1;</span>
<span class="fc" id="L293">            this.a2 = a2;</span>
<span class="fc" id="L294">        }</span>

        /**
         * Returns a checkable property that checks values of the 2 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 2-ary predicate
         * @return a new {@code Property2} of 2 variables.
         */
        public Property2&lt;T1, T2&gt; suchThat(CheckedFunction2&lt;T1, T2, Boolean&gt; predicate) {
<span class="fc" id="L303">            final CheckedFunction2&lt;T1, T2, Condition&gt; proposition = (t1, t2) -&gt; new Condition(true, predicate.apply(t1, t2));</span>
<span class="fc" id="L304">            return new Property2&lt;&gt;(name, a1, a2, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll3&lt;T1, T2, T3&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;

<span class="fc" id="L324">        ForAll3(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3) {</span>
<span class="fc" id="L325">            this.name = name;</span>
<span class="fc" id="L326">            this.a1 = a1;</span>
<span class="fc" id="L327">            this.a2 = a2;</span>
<span class="fc" id="L328">            this.a3 = a3;</span>
<span class="fc" id="L329">        }</span>

        /**
         * Returns a checkable property that checks values of the 3 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 3-ary predicate
         * @return a new {@code Property3} of 3 variables.
         */
        public Property3&lt;T1, T2, T3&gt; suchThat(CheckedFunction3&lt;T1, T2, T3, Boolean&gt; predicate) {
<span class="fc" id="L338">            final CheckedFunction3&lt;T1, T2, T3, Condition&gt; proposition = (t1, t2, t3) -&gt; new Condition(true, predicate.apply(t1, t2, t3));</span>
<span class="fc" id="L339">            return new Property3&lt;&gt;(name, a1, a2, a3, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll4&lt;T1, T2, T3, T4&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;

<span class="fc" id="L361">        ForAll4(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4) {</span>
<span class="fc" id="L362">            this.name = name;</span>
<span class="fc" id="L363">            this.a1 = a1;</span>
<span class="fc" id="L364">            this.a2 = a2;</span>
<span class="fc" id="L365">            this.a3 = a3;</span>
<span class="fc" id="L366">            this.a4 = a4;</span>
<span class="fc" id="L367">        }</span>

        /**
         * Returns a checkable property that checks values of the 4 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 4-ary predicate
         * @return a new {@code Property4} of 4 variables.
         */
        public Property4&lt;T1, T2, T3, T4&gt; suchThat(CheckedFunction4&lt;T1, T2, T3, T4, Boolean&gt; predicate) {
<span class="fc" id="L376">            final CheckedFunction4&lt;T1, T2, T3, T4, Condition&gt; proposition = (t1, t2, t3, t4) -&gt; new Condition(true, predicate.apply(t1, t2, t3, t4));</span>
<span class="fc" id="L377">            return new Property4&lt;&gt;(name, a1, a2, a3, a4, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll5&lt;T1, T2, T3, T4, T5&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;

<span class="fc" id="L401">        ForAll5(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5) {</span>
<span class="fc" id="L402">            this.name = name;</span>
<span class="fc" id="L403">            this.a1 = a1;</span>
<span class="fc" id="L404">            this.a2 = a2;</span>
<span class="fc" id="L405">            this.a3 = a3;</span>
<span class="fc" id="L406">            this.a4 = a4;</span>
<span class="fc" id="L407">            this.a5 = a5;</span>
<span class="fc" id="L408">        }</span>

        /**
         * Returns a checkable property that checks values of the 5 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 5-ary predicate
         * @return a new {@code Property5} of 5 variables.
         */
        public Property5&lt;T1, T2, T3, T4, T5&gt; suchThat(CheckedFunction5&lt;T1, T2, T3, T4, T5, Boolean&gt; predicate) {
<span class="fc" id="L417">            final CheckedFunction5&lt;T1, T2, T3, T4, T5, Condition&gt; proposition = (t1, t2, t3, t4, t5) -&gt; new Condition(true, predicate.apply(t1, t2, t3, t4, t5));</span>
<span class="fc" id="L418">            return new Property5&lt;&gt;(name, a1, a2, a3, a4, a5, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll6&lt;T1, T2, T3, T4, T5, T6&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;

<span class="fc" id="L444">        ForAll6(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6) {</span>
<span class="fc" id="L445">            this.name = name;</span>
<span class="fc" id="L446">            this.a1 = a1;</span>
<span class="fc" id="L447">            this.a2 = a2;</span>
<span class="fc" id="L448">            this.a3 = a3;</span>
<span class="fc" id="L449">            this.a4 = a4;</span>
<span class="fc" id="L450">            this.a5 = a5;</span>
<span class="fc" id="L451">            this.a6 = a6;</span>
<span class="fc" id="L452">        }</span>

        /**
         * Returns a checkable property that checks values of the 6 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 6-ary predicate
         * @return a new {@code Property6} of 6 variables.
         */
        public Property6&lt;T1, T2, T3, T4, T5, T6&gt; suchThat(CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Boolean&gt; predicate) {
<span class="fc" id="L461">            final CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Condition&gt; proposition = (t1, t2, t3, t4, t5, t6) -&gt; new Condition(true, predicate.apply(t1, t2, t3, t4, t5, t6));</span>
<span class="fc" id="L462">            return new Property6&lt;&gt;(name, a1, a2, a3, a4, a5, a6, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @param &lt;T7&gt; 7th variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll7&lt;T1, T2, T3, T4, T5, T6, T7&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;
        private final Arbitrary&lt;T7&gt; a7;

<span class="fc" id="L490">        ForAll7(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7) {</span>
<span class="fc" id="L491">            this.name = name;</span>
<span class="fc" id="L492">            this.a1 = a1;</span>
<span class="fc" id="L493">            this.a2 = a2;</span>
<span class="fc" id="L494">            this.a3 = a3;</span>
<span class="fc" id="L495">            this.a4 = a4;</span>
<span class="fc" id="L496">            this.a5 = a5;</span>
<span class="fc" id="L497">            this.a6 = a6;</span>
<span class="fc" id="L498">            this.a7 = a7;</span>
<span class="fc" id="L499">        }</span>

        /**
         * Returns a checkable property that checks values of the 7 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 7-ary predicate
         * @return a new {@code Property7} of 7 variables.
         */
        public Property7&lt;T1, T2, T3, T4, T5, T6, T7&gt; suchThat(CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Boolean&gt; predicate) {
<span class="fc" id="L508">            final CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Condition&gt; proposition = (t1, t2, t3, t4, t5, t6, t7) -&gt; new Condition(true, predicate.apply(t1, t2, t3, t4, t5, t6, t7));</span>
<span class="fc" id="L509">            return new Property7&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7, proposition);</span>
        }
    }

    /**
     * Represents a logical for all quantor.
     *
     * @param &lt;T1&gt; 1st variable type of this for all quantor
     * @param &lt;T2&gt; 2nd variable type of this for all quantor
     * @param &lt;T3&gt; 3rd variable type of this for all quantor
     * @param &lt;T4&gt; 4th variable type of this for all quantor
     * @param &lt;T5&gt; 5th variable type of this for all quantor
     * @param &lt;T6&gt; 6th variable type of this for all quantor
     * @param &lt;T7&gt; 7th variable type of this for all quantor
     * @param &lt;T8&gt; 8th variable type of this for all quantor
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class ForAll8&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;
        private final Arbitrary&lt;T7&gt; a7;
        private final Arbitrary&lt;T8&gt; a8;

<span class="fc" id="L539">        ForAll8(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7, Arbitrary&lt;T8&gt; a8) {</span>
<span class="fc" id="L540">            this.name = name;</span>
<span class="fc" id="L541">            this.a1 = a1;</span>
<span class="fc" id="L542">            this.a2 = a2;</span>
<span class="fc" id="L543">            this.a3 = a3;</span>
<span class="fc" id="L544">            this.a4 = a4;</span>
<span class="fc" id="L545">            this.a5 = a5;</span>
<span class="fc" id="L546">            this.a6 = a6;</span>
<span class="fc" id="L547">            this.a7 = a7;</span>
<span class="fc" id="L548">            this.a8 = a8;</span>
<span class="fc" id="L549">        }</span>

        /**
         * Returns a checkable property that checks values of the 8 variables of this {@code ForAll} quantor.
         *
         * @param predicate A 8-ary predicate
         * @return a new {@code Property8} of 8 variables.
         */
        public Property8&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; suchThat(CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Boolean&gt; predicate) {
<span class="fc" id="L558">            final CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Condition&gt; proposition = (t1, t2, t3, t4, t5, t6, t7, t8) -&gt; new Condition(true, predicate.apply(t1, t2, t3, t4, t5, t6, t7, t8));</span>
<span class="fc" id="L559">            return new Property8&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7, a8, proposition);</span>
        }
    }

    /**
     * Represents a 1-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property1&lt;T1&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final CheckedFunction1&lt;T1, Condition&gt; predicate;

<span class="fc" id="L575">        Property1(String name, Arbitrary&lt;T1&gt; a1, CheckedFunction1&lt;T1, Condition&gt; predicate) {</span>
<span class="fc" id="L576">            this.name = name;</span>
<span class="fc" id="L577">            this.a1 = a1;</span>
<span class="fc" id="L578">            this.predicate = predicate;</span>
<span class="fc" id="L579">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction1&lt;T1, Boolean&gt; postcondition) {
<span class="fc" id="L588">            final CheckedFunction1&lt;T1, Condition&gt; implication = (t1) -&gt; {</span>
<span class="fc" id="L589">                final Condition precondition = predicate.apply(t1);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L591">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L593">                    return new Condition(true, postcondition.apply(t1));</span>
                }
            };
<span class="fc" id="L596">            return new Property1&lt;&gt;(name, a1, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L601">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L603">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L605">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L607">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="fc" id="L608">                boolean exhausted = true;</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L611">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
                        try {
<span class="fc" id="L613">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L615">                                exhausted = false;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L617">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L618">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1));</span>
                                }
                            }
<span class="fc" id="L621">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L622">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L623">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1)));</span>
<span class="fc" id="L624">                        }</span>
<span class="fc" id="L625">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L626">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L627">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L628">                    }</span>
                }
<span class="fc" id="L630">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L631">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L632">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L633">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L634">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 2-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property2&lt;T1, T2&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final CheckedFunction2&lt;T1, T2, Condition&gt; predicate;

<span class="fc" id="L652">        Property2(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, CheckedFunction2&lt;T1, T2, Condition&gt; predicate) {</span>
<span class="fc" id="L653">            this.name = name;</span>
<span class="fc" id="L654">            this.a1 = a1;</span>
<span class="fc" id="L655">            this.a2 = a2;</span>
<span class="fc" id="L656">            this.predicate = predicate;</span>
<span class="fc" id="L657">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction2&lt;T1, T2, Boolean&gt; postcondition) {
<span class="fc" id="L666">            final CheckedFunction2&lt;T1, T2, Condition&gt; implication = (t1, t2) -&gt; {</span>
<span class="fc" id="L667">                final Condition precondition = predicate.apply(t1, t2);</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L669">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L671">                    return new Condition(true, postcondition.apply(t1, t2));</span>
                }
            };
<span class="fc" id="L674">            return new Property2&lt;&gt;(name, a1, a2, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L679">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L681">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L683">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L685">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L686">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="fc" id="L687">                boolean exhausted = true;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L690">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L691">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
                        try {
<span class="fc" id="L693">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L695">                                exhausted = false;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L697">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L698">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2));</span>
                                }
                            }
<span class="fc" id="L701">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L702">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L703">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2)));</span>
<span class="fc" id="L704">                        }</span>
<span class="fc" id="L705">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L706">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L707">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L708">                    }</span>
                }
<span class="fc" id="L710">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L711">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L712">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L713">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L714">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 3-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property3&lt;T1, T2, T3&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final CheckedFunction3&lt;T1, T2, T3, Condition&gt; predicate;

<span class="fc" id="L733">        Property3(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, CheckedFunction3&lt;T1, T2, T3, Condition&gt; predicate) {</span>
<span class="fc" id="L734">            this.name = name;</span>
<span class="fc" id="L735">            this.a1 = a1;</span>
<span class="fc" id="L736">            this.a2 = a2;</span>
<span class="fc" id="L737">            this.a3 = a3;</span>
<span class="fc" id="L738">            this.predicate = predicate;</span>
<span class="fc" id="L739">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction3&lt;T1, T2, T3, Boolean&gt; postcondition) {
<span class="fc" id="L748">            final CheckedFunction3&lt;T1, T2, T3, Condition&gt; implication = (t1, t2, t3) -&gt; {</span>
<span class="fc" id="L749">                final Condition precondition = predicate.apply(t1, t2, t3);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L751">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L753">                    return new Condition(true, postcondition.apply(t1, t2, t3));</span>
                }
            };
<span class="fc" id="L756">            return new Property3&lt;&gt;(name, a1, a2, a3, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L761">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L763">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L765">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L767">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L768">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L769">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="fc" id="L770">                boolean exhausted = true;</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L773">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L774">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L775">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
                        try {
<span class="fc" id="L777">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L779">                                exhausted = false;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L781">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L782">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3));</span>
                                }
                            }
<span class="fc" id="L785">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L786">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L787">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3)));</span>
<span class="fc" id="L788">                        }</span>
<span class="fc" id="L789">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L790">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L791">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L792">                    }</span>
                }
<span class="fc" id="L794">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L795">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L796">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L797">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L798">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 4-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property4&lt;T1, T2, T3, T4&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final CheckedFunction4&lt;T1, T2, T3, T4, Condition&gt; predicate;

<span class="fc" id="L818">        Property4(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, CheckedFunction4&lt;T1, T2, T3, T4, Condition&gt; predicate) {</span>
<span class="fc" id="L819">            this.name = name;</span>
<span class="fc" id="L820">            this.a1 = a1;</span>
<span class="fc" id="L821">            this.a2 = a2;</span>
<span class="fc" id="L822">            this.a3 = a3;</span>
<span class="fc" id="L823">            this.a4 = a4;</span>
<span class="fc" id="L824">            this.predicate = predicate;</span>
<span class="fc" id="L825">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction4&lt;T1, T2, T3, T4, Boolean&gt; postcondition) {
<span class="fc" id="L834">            final CheckedFunction4&lt;T1, T2, T3, T4, Condition&gt; implication = (t1, t2, t3, t4) -&gt; {</span>
<span class="fc" id="L835">                final Condition precondition = predicate.apply(t1, t2, t3, t4);</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L837">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L839">                    return new Condition(true, postcondition.apply(t1, t2, t3, t4));</span>
                }
            };
<span class="fc" id="L842">            return new Property4&lt;&gt;(name, a1, a2, a3, a4, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L847">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L849">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L851">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L853">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L854">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L855">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="pc" id="L856">                final Gen&lt;T4&gt; gen4 = Try.of(() -&gt; a4.apply(size)).recover(x -&gt; { throw arbitraryError(4, size, x); }).get();</span>
<span class="fc" id="L857">                boolean exhausted = true;</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L860">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L861">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L862">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
<span class="pc" id="L863">                        final T4 val4 = Try.of(() -&gt; gen4.apply(random)).recover(x -&gt; { throw genError(4, size, x); }).get();</span>
                        try {
<span class="fc" id="L865">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3, val4)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L867">                                exhausted = false;</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L869">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L870">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3, val4));</span>
                                }
                            }
<span class="fc" id="L873">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L874">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L875">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3, val4)));</span>
<span class="fc" id="L876">                        }</span>
<span class="fc" id="L877">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L878">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L879">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L880">                    }</span>
                }
<span class="fc" id="L882">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L883">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L884">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L885">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L886">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 5-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property5&lt;T1, T2, T3, T4, T5&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final CheckedFunction5&lt;T1, T2, T3, T4, T5, Condition&gt; predicate;

<span class="fc" id="L907">        Property5(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, CheckedFunction5&lt;T1, T2, T3, T4, T5, Condition&gt; predicate) {</span>
<span class="fc" id="L908">            this.name = name;</span>
<span class="fc" id="L909">            this.a1 = a1;</span>
<span class="fc" id="L910">            this.a2 = a2;</span>
<span class="fc" id="L911">            this.a3 = a3;</span>
<span class="fc" id="L912">            this.a4 = a4;</span>
<span class="fc" id="L913">            this.a5 = a5;</span>
<span class="fc" id="L914">            this.predicate = predicate;</span>
<span class="fc" id="L915">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction5&lt;T1, T2, T3, T4, T5, Boolean&gt; postcondition) {
<span class="fc" id="L924">            final CheckedFunction5&lt;T1, T2, T3, T4, T5, Condition&gt; implication = (t1, t2, t3, t4, t5) -&gt; {</span>
<span class="fc" id="L925">                final Condition precondition = predicate.apply(t1, t2, t3, t4, t5);</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L927">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L929">                    return new Condition(true, postcondition.apply(t1, t2, t3, t4, t5));</span>
                }
            };
<span class="fc" id="L932">            return new Property5&lt;&gt;(name, a1, a2, a3, a4, a5, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L937">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L939">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L941">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L943">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L944">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L945">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="pc" id="L946">                final Gen&lt;T4&gt; gen4 = Try.of(() -&gt; a4.apply(size)).recover(x -&gt; { throw arbitraryError(4, size, x); }).get();</span>
<span class="pc" id="L947">                final Gen&lt;T5&gt; gen5 = Try.of(() -&gt; a5.apply(size)).recover(x -&gt; { throw arbitraryError(5, size, x); }).get();</span>
<span class="fc" id="L948">                boolean exhausted = true;</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L951">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L952">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L953">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
<span class="pc" id="L954">                        final T4 val4 = Try.of(() -&gt; gen4.apply(random)).recover(x -&gt; { throw genError(4, size, x); }).get();</span>
<span class="pc" id="L955">                        final T5 val5 = Try.of(() -&gt; gen5.apply(random)).recover(x -&gt; { throw genError(5, size, x); }).get();</span>
                        try {
<span class="fc" id="L957">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3, val4, val5)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L959">                                exhausted = false;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L961">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L962">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3, val4, val5));</span>
                                }
                            }
<span class="fc" id="L965">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L966">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L967">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3, val4, val5)));</span>
<span class="fc" id="L968">                        }</span>
<span class="fc" id="L969">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L970">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L971">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L972">                    }</span>
                }
<span class="fc" id="L974">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L975">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L976">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L977">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L978">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 6-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property6&lt;T1, T2, T3, T4, T5, T6&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;
        private final CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Condition&gt; predicate;

<span class="fc" id="L1000">        Property6(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Condition&gt; predicate) {</span>
<span class="fc" id="L1001">            this.name = name;</span>
<span class="fc" id="L1002">            this.a1 = a1;</span>
<span class="fc" id="L1003">            this.a2 = a2;</span>
<span class="fc" id="L1004">            this.a3 = a3;</span>
<span class="fc" id="L1005">            this.a4 = a4;</span>
<span class="fc" id="L1006">            this.a5 = a5;</span>
<span class="fc" id="L1007">            this.a6 = a6;</span>
<span class="fc" id="L1008">            this.predicate = predicate;</span>
<span class="fc" id="L1009">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Boolean&gt; postcondition) {
<span class="fc" id="L1018">            final CheckedFunction6&lt;T1, T2, T3, T4, T5, T6, Condition&gt; implication = (t1, t2, t3, t4, t5, t6) -&gt; {</span>
<span class="fc" id="L1019">                final Condition precondition = predicate.apply(t1, t2, t3, t4, t5, t6);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L1021">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L1023">                    return new Condition(true, postcondition.apply(t1, t2, t3, t4, t5, t6));</span>
                }
            };
<span class="fc" id="L1026">            return new Property6&lt;&gt;(name, a1, a2, a3, a4, a5, a6, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L1031">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L1033">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L1035">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L1037">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L1038">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L1039">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="pc" id="L1040">                final Gen&lt;T4&gt; gen4 = Try.of(() -&gt; a4.apply(size)).recover(x -&gt; { throw arbitraryError(4, size, x); }).get();</span>
<span class="pc" id="L1041">                final Gen&lt;T5&gt; gen5 = Try.of(() -&gt; a5.apply(size)).recover(x -&gt; { throw arbitraryError(5, size, x); }).get();</span>
<span class="pc" id="L1042">                final Gen&lt;T6&gt; gen6 = Try.of(() -&gt; a6.apply(size)).recover(x -&gt; { throw arbitraryError(6, size, x); }).get();</span>
<span class="fc" id="L1043">                boolean exhausted = true;</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L1046">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L1047">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L1048">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
<span class="pc" id="L1049">                        final T4 val4 = Try.of(() -&gt; gen4.apply(random)).recover(x -&gt; { throw genError(4, size, x); }).get();</span>
<span class="pc" id="L1050">                        final T5 val5 = Try.of(() -&gt; gen5.apply(random)).recover(x -&gt; { throw genError(5, size, x); }).get();</span>
<span class="pc" id="L1051">                        final T6 val6 = Try.of(() -&gt; gen6.apply(random)).recover(x -&gt; { throw genError(6, size, x); }).get();</span>
                        try {
<span class="fc" id="L1053">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3, val4, val5, val6)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L1055">                                exhausted = false;</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L1057">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L1058">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3, val4, val5, val6));</span>
                                }
                            }
<span class="fc" id="L1061">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1062">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1063">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3, val4, val5, val6)));</span>
<span class="fc" id="L1064">                        }</span>
<span class="fc" id="L1065">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1066">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1067">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L1068">                    }</span>
                }
<span class="fc" id="L1070">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L1071">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L1072">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1073">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1074">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 7-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property7&lt;T1, T2, T3, T4, T5, T6, T7&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;
        private final Arbitrary&lt;T7&gt; a7;
        private final CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Condition&gt; predicate;

<span class="fc" id="L1097">        Property7(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7, CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Condition&gt; predicate) {</span>
<span class="fc" id="L1098">            this.name = name;</span>
<span class="fc" id="L1099">            this.a1 = a1;</span>
<span class="fc" id="L1100">            this.a2 = a2;</span>
<span class="fc" id="L1101">            this.a3 = a3;</span>
<span class="fc" id="L1102">            this.a4 = a4;</span>
<span class="fc" id="L1103">            this.a5 = a5;</span>
<span class="fc" id="L1104">            this.a6 = a6;</span>
<span class="fc" id="L1105">            this.a7 = a7;</span>
<span class="fc" id="L1106">            this.predicate = predicate;</span>
<span class="fc" id="L1107">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Boolean&gt; postcondition) {
<span class="fc" id="L1116">            final CheckedFunction7&lt;T1, T2, T3, T4, T5, T6, T7, Condition&gt; implication = (t1, t2, t3, t4, t5, t6, t7) -&gt; {</span>
<span class="fc" id="L1117">                final Condition precondition = predicate.apply(t1, t2, t3, t4, t5, t6, t7);</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L1119">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L1121">                    return new Condition(true, postcondition.apply(t1, t2, t3, t4, t5, t6, t7));</span>
                }
            };
<span class="fc" id="L1124">            return new Property7&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L1129">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L1130" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L1131">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L1133">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L1135">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L1136">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L1137">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="pc" id="L1138">                final Gen&lt;T4&gt; gen4 = Try.of(() -&gt; a4.apply(size)).recover(x -&gt; { throw arbitraryError(4, size, x); }).get();</span>
<span class="pc" id="L1139">                final Gen&lt;T5&gt; gen5 = Try.of(() -&gt; a5.apply(size)).recover(x -&gt; { throw arbitraryError(5, size, x); }).get();</span>
<span class="pc" id="L1140">                final Gen&lt;T6&gt; gen6 = Try.of(() -&gt; a6.apply(size)).recover(x -&gt; { throw arbitraryError(6, size, x); }).get();</span>
<span class="pc" id="L1141">                final Gen&lt;T7&gt; gen7 = Try.of(() -&gt; a7.apply(size)).recover(x -&gt; { throw arbitraryError(7, size, x); }).get();</span>
<span class="fc" id="L1142">                boolean exhausted = true;</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L1145">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L1146">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L1147">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
<span class="pc" id="L1148">                        final T4 val4 = Try.of(() -&gt; gen4.apply(random)).recover(x -&gt; { throw genError(4, size, x); }).get();</span>
<span class="pc" id="L1149">                        final T5 val5 = Try.of(() -&gt; gen5.apply(random)).recover(x -&gt; { throw genError(5, size, x); }).get();</span>
<span class="pc" id="L1150">                        final T6 val6 = Try.of(() -&gt; gen6.apply(random)).recover(x -&gt; { throw genError(6, size, x); }).get();</span>
<span class="pc" id="L1151">                        final T7 val7 = Try.of(() -&gt; gen7.apply(random)).recover(x -&gt; { throw genError(7, size, x); }).get();</span>
                        try {
<span class="fc" id="L1153">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3, val4, val5, val6, val7)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L1155">                                exhausted = false;</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L1157">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L1158">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3, val4, val5, val6, val7));</span>
                                }
                            }
<span class="fc" id="L1161">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1162">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1163">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3, val4, val5, val6, val7)));</span>
<span class="fc" id="L1164">                        }</span>
<span class="fc" id="L1165">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1166">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1167">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L1168">                    }</span>
                }
<span class="fc" id="L1170">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L1171">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L1172">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1173">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1174">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Represents a 8-ary checkable property.
     *
     * @author Daniel Dietrich
     * @since 1.2.0
     */
    public static class Property8&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; implements Checkable {

        private final String name;
        private final Arbitrary&lt;T1&gt; a1;
        private final Arbitrary&lt;T2&gt; a2;
        private final Arbitrary&lt;T3&gt; a3;
        private final Arbitrary&lt;T4&gt; a4;
        private final Arbitrary&lt;T5&gt; a5;
        private final Arbitrary&lt;T6&gt; a6;
        private final Arbitrary&lt;T7&gt; a7;
        private final Arbitrary&lt;T8&gt; a8;
        private final CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Condition&gt; predicate;

<span class="fc" id="L1198">        Property8(String name, Arbitrary&lt;T1&gt; a1, Arbitrary&lt;T2&gt; a2, Arbitrary&lt;T3&gt; a3, Arbitrary&lt;T4&gt; a4, Arbitrary&lt;T5&gt; a5, Arbitrary&lt;T6&gt; a6, Arbitrary&lt;T7&gt; a7, Arbitrary&lt;T8&gt; a8, CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Condition&gt; predicate) {</span>
<span class="fc" id="L1199">            this.name = name;</span>
<span class="fc" id="L1200">            this.a1 = a1;</span>
<span class="fc" id="L1201">            this.a2 = a2;</span>
<span class="fc" id="L1202">            this.a3 = a3;</span>
<span class="fc" id="L1203">            this.a4 = a4;</span>
<span class="fc" id="L1204">            this.a5 = a5;</span>
<span class="fc" id="L1205">            this.a6 = a6;</span>
<span class="fc" id="L1206">            this.a7 = a7;</span>
<span class="fc" id="L1207">            this.a8 = a8;</span>
<span class="fc" id="L1208">            this.predicate = predicate;</span>
<span class="fc" id="L1209">        }</span>

        /**
         * Returns an implication which composes this Property as pre-condition and a given post-condition.
         *
         * @param postcondition The postcondition of this implication
         * @return A new Checkable implication
         */
        public Checkable implies(CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Boolean&gt; postcondition) {
<span class="fc" id="L1218">            final CheckedFunction8&lt;T1, T2, T3, T4, T5, T6, T7, T8, Condition&gt; implication = (t1, t2, t3, t4, t5, t6, t7, t8) -&gt; {</span>
<span class="fc" id="L1219">                final Condition precondition = predicate.apply(t1, t2, t3, t4, t5, t6, t7, t8);</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">                if (precondition.isFalse()) {</span>
<span class="fc" id="L1221">                    return Condition.EX_FALSO_QUODLIBET;</span>
                } else {
<span class="fc" id="L1223">                    return new Condition(true, postcondition.apply(t1, t2, t3, t4, t5, t6, t7, t8));</span>
                }
            };
<span class="fc" id="L1226">            return new Property8&lt;&gt;(name, a1, a2, a3, a4, a5, a6, a7, a8, implication);</span>
        }

        @Override
        public CheckResult check(Random random, int size, int tries) {
<span class="fc" id="L1231">            Objects.requireNonNull(random, &quot;random is null&quot;);</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">            if (tries &lt; 0) {</span>
<span class="fc" id="L1233">                throw new IllegalArgumentException(&quot;tries &lt; 0&quot;);</span>
            }
<span class="fc" id="L1235">            final long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L1237">                final Gen&lt;T1&gt; gen1 = Try.of(() -&gt; a1.apply(size)).recover(x -&gt; { throw arbitraryError(1, size, x); }).get();</span>
<span class="pc" id="L1238">                final Gen&lt;T2&gt; gen2 = Try.of(() -&gt; a2.apply(size)).recover(x -&gt; { throw arbitraryError(2, size, x); }).get();</span>
<span class="pc" id="L1239">                final Gen&lt;T3&gt; gen3 = Try.of(() -&gt; a3.apply(size)).recover(x -&gt; { throw arbitraryError(3, size, x); }).get();</span>
<span class="pc" id="L1240">                final Gen&lt;T4&gt; gen4 = Try.of(() -&gt; a4.apply(size)).recover(x -&gt; { throw arbitraryError(4, size, x); }).get();</span>
<span class="pc" id="L1241">                final Gen&lt;T5&gt; gen5 = Try.of(() -&gt; a5.apply(size)).recover(x -&gt; { throw arbitraryError(5, size, x); }).get();</span>
<span class="pc" id="L1242">                final Gen&lt;T6&gt; gen6 = Try.of(() -&gt; a6.apply(size)).recover(x -&gt; { throw arbitraryError(6, size, x); }).get();</span>
<span class="pc" id="L1243">                final Gen&lt;T7&gt; gen7 = Try.of(() -&gt; a7.apply(size)).recover(x -&gt; { throw arbitraryError(7, size, x); }).get();</span>
<span class="pc" id="L1244">                final Gen&lt;T8&gt; gen8 = Try.of(() -&gt; a8.apply(size)).recover(x -&gt; { throw arbitraryError(8, size, x); }).get();</span>
<span class="fc" id="L1245">                boolean exhausted = true;</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                for (int i = 1; i &lt;= tries; i++) {</span>
                    try {
<span class="fc" id="L1248">                        final T1 val1 = Try.of(() -&gt; gen1.apply(random)).recover(x -&gt; { throw genError(1, size, x); }).get();</span>
<span class="pc" id="L1249">                        final T2 val2 = Try.of(() -&gt; gen2.apply(random)).recover(x -&gt; { throw genError(2, size, x); }).get();</span>
<span class="pc" id="L1250">                        final T3 val3 = Try.of(() -&gt; gen3.apply(random)).recover(x -&gt; { throw genError(3, size, x); }).get();</span>
<span class="pc" id="L1251">                        final T4 val4 = Try.of(() -&gt; gen4.apply(random)).recover(x -&gt; { throw genError(4, size, x); }).get();</span>
<span class="pc" id="L1252">                        final T5 val5 = Try.of(() -&gt; gen5.apply(random)).recover(x -&gt; { throw genError(5, size, x); }).get();</span>
<span class="pc" id="L1253">                        final T6 val6 = Try.of(() -&gt; gen6.apply(random)).recover(x -&gt; { throw genError(6, size, x); }).get();</span>
<span class="pc" id="L1254">                        final T7 val7 = Try.of(() -&gt; gen7.apply(random)).recover(x -&gt; { throw genError(7, size, x); }).get();</span>
<span class="pc" id="L1255">                        final T8 val8 = Try.of(() -&gt; gen8.apply(random)).recover(x -&gt; { throw genError(8, size, x); }).get();</span>
                        try {
<span class="fc" id="L1257">                            final Condition condition = Try.of(() -&gt; predicate.apply(val1, val2, val3, val4, val5, val6, val7, val8)).recover(x -&gt; { throw predicateError(x); }).get();</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">                            if (condition.precondition) {</span>
<span class="fc" id="L1259">                                exhausted = false;</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">                                if (!condition.postcondition) {</span>
<span class="fc" id="L1261">                                    logFalsified(name, i, System.currentTimeMillis() - startTime);</span>
<span class="fc" id="L1262">                                    return new CheckResult.Falsified(name, i, Tuple.of(val1, val2, val3, val4, val5, val6, val7, val8));</span>
                                }
                            }
<span class="fc" id="L1265">                        } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1266">                            logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1267">                            return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.some(Tuple.of(val1, val2, val3, val4, val5, val6, val7, val8)));</span>
<span class="fc" id="L1268">                        }</span>
<span class="fc" id="L1269">                    } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1270">                        logErroneous(name, i, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1271">                        return new CheckResult.Erroneous(name, i, (Error) nonFatal.getCause(), Option.none());</span>
<span class="fc" id="L1272">                    }</span>
                }
<span class="fc" id="L1274">                logSatisfied(name, tries, System.currentTimeMillis() - startTime, exhausted);</span>
<span class="fc" id="L1275">                return new CheckResult.Satisfied(name, tries, exhausted);</span>
<span class="fc" id="L1276">            } catch(NonFatalException nonFatal) {</span>
<span class="fc" id="L1277">                logErroneous(name, 0, System.currentTimeMillis() - startTime, nonFatal.getCause().getMessage());</span>
<span class="fc" id="L1278">                return new CheckResult.Erroneous(name, 0, (Error) nonFatal.getCause(), Option.none());</span>
            }
        }
    }

    /**
     * Internally used to model conditions composed of pre- and post-condition.
     */
    static class Condition {

<span class="fc" id="L1288">        static final Condition EX_FALSO_QUODLIBET = new Condition(false, true);</span>

        final boolean precondition;
        final boolean postcondition;

<span class="fc" id="L1293">        Condition(boolean precondition, boolean postcondition) {</span>
<span class="fc" id="L1294">            this.precondition = precondition;</span>
<span class="fc" id="L1295">            this.postcondition = postcondition;</span>
<span class="fc" id="L1296">        }</span>

        // ¬(p =&gt; q) ≡ ¬(¬p ∨ q) ≡ p ∧ ¬q
        boolean isFalse() {
<span class="fc bfc" id="L1300" title="All 4 branches covered.">            return precondition &amp;&amp; !postcondition;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>