<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Traversable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">Traversable.java</span></div><h1>Traversable.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Tuple2;
import javaslang.Tuple3;
import javaslang.Value;
import javaslang.algebra.Monad;
import javaslang.control.Match;
import javaslang.control.Option;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * An interface for inherently recursive, multi-valued data structures. The order of elements is determined by
 * {@link Iterable#iterator()}, which may vary each time it is called.
 * &lt;p&gt;
 * Implementations of {@code Traversable} should calculate the {@code hashCode} via {@link #hash(Iterable)}.
 *
 * &lt;p&gt;
 * Basic operations:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #clear()}&lt;/li&gt;
 * &lt;li&gt;{@link #contains(Object)}&lt;/li&gt;
 * &lt;li&gt;{@link #containsAll(Iterable)}&lt;/li&gt;
 * &lt;li&gt;{@link #head()}&lt;/li&gt;
 * &lt;li&gt;{@link #headOption()}&lt;/li&gt;
 * &lt;li&gt;{@link #init()}&lt;/li&gt;
 * &lt;li&gt;{@link #initOption()}&lt;/li&gt;
 * &lt;li&gt;{@link #isEmpty()}&lt;/li&gt;
 * &lt;li&gt;{@link #last()}&lt;/li&gt;
 * &lt;li&gt;{@link #lastOption()}&lt;/li&gt;
 * &lt;li&gt;{@link #length()}&lt;/li&gt;
 * &lt;li&gt;{@link #size()}&lt;/li&gt;
 * &lt;li&gt;{@link #tail()}&lt;/li&gt;
 * &lt;li&gt;{@link #tailOption()}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Iteration:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #grouped(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #iterator()}&lt;/li&gt;
 * &lt;li&gt;{@link #sliding(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #sliding(int, int)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Numeric operations:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #average()}&lt;/li&gt;
 * &lt;li&gt;{@link #max()}&lt;/li&gt;
 * &lt;li&gt;{@link #maxBy(Comparator)}&lt;/li&gt;
 * &lt;li&gt;{@link #maxBy(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #min()}&lt;/li&gt;
 * &lt;li&gt;{@link #minBy(Comparator)}&lt;/li&gt;
 * &lt;li&gt;{@link #minBy(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #product()}&lt;/li&gt;
 * &lt;li&gt;{@link #sum()}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Reduction:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #count(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #foldLeft(Object, BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #foldRight(Object, BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #mkString()}&lt;/li&gt;
 * &lt;li&gt;{@link #mkString(CharSequence)}&lt;/li&gt;
 * &lt;li&gt;{@link #mkString(CharSequence, CharSequence, CharSequence)}&lt;/li&gt;
 * &lt;li&gt;{@link #reduce(BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #reduceLeft(BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #reduceRight(BiFunction)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Selection:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #drop(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #dropRight(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #dropUntil(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #dropWhile(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #filter(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #findFirst(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #findLast(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #groupBy(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #partition(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #retainAll(Iterable)}&lt;/li&gt;
 * &lt;li&gt;{@link #take(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #takeRight(int)}&lt;/li&gt;
 * &lt;li&gt;{@link #takeUntil(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #takeWhile(Predicate)}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Tests:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #existsUnique(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #hasDefiniteSize()}&lt;/li&gt;
 * &lt;li&gt;{@link #isTraversableAgain()}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Transformation:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #distinct()}&lt;/li&gt;
 * &lt;li&gt;{@link #distinctBy(Comparator)}&lt;/li&gt;
 * &lt;li&gt;{@link #distinctBy(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #flatMap(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #map(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #replace(Object, Object)}&lt;/li&gt;
 * &lt;li&gt;{@link #replaceAll(Object, Object)}&lt;/li&gt;
 * &lt;li&gt;{@link #scan(Object, BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #scanLeft(Object, BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #scanRight(Object, BiFunction)}&lt;/li&gt;
 * &lt;li&gt;{@link #span(Predicate)}&lt;/li&gt;
 * &lt;li&gt;{@link #unzip(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #unzip3(Function)}&lt;/li&gt;
 * &lt;li&gt;{@link #zip(Iterable)}&lt;/li&gt;
 * &lt;li&gt;{@link #zipAll(Iterable, Object, Object)}&lt;/li&gt;
 * &lt;li&gt;{@link #zipWithIndex()}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @param &lt;T&gt; Component type
 * @author Daniel Dietrich and others
 * @since 1.1.0
 */
public interface Traversable&lt;T&gt; extends Value&lt;T&gt;, Monad&lt;T&gt; {

    /**
     * Used by collections to compute the hashCode only once.
     * &lt;p&gt;
     * Idiom:
     * &lt;pre&gt;
     * &lt;code&gt;
     * class MyCollection implements Serializable {
     *
     *     // Not allowed to be serialized!
     *     private final transient Lazy&amp;lt;Integer&amp;gt; hashCode = Lazy.of(() -&amp;gt; Traversable.hash(this));
     *
     *     &amp;#64;Override
     *     public int hashCode() {
     *         return hashCode.get();
     *     }
     * }
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * &lt;strong&gt;Note:&lt;/strong&gt; In the case of an empty collection, such as {@code Nil} it is recommended to
     * directly return {@code Traversable.hash(this)} instead of asking a {@code Lazy} value:
     * &lt;pre&gt;
     * &lt;code&gt;
     * interface List&amp;lt;T&amp;gt; {
     *
     *     class Nil&amp;lt;T&amp;gt; {
     *
     *         &amp;#64;Override
     *         public int hashCode() {
     *             return Traversable.hash(this);
     *         }
     *     }
     * }
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param &lt;T&gt;     Component type
     * @param objects An Iterable
     * @return The hashCode of the given Iterable
     * @throws NullPointerException if objects is null
     */
    static &lt;T&gt; int hash(Iterable&lt;? extends T&gt; objects) {
<span class="fc" id="L184">        int hashCode = 1;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (Object o : objects) {</span>
<span class="fc" id="L186">            hashCode = 31 * hashCode + Objects.hashCode(o);</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">        return hashCode;</span>
    }

    /**
     * Calculates the average of this elements. Returns {@code None} if this is empty, otherwise {@code Some(average)}.
     * Supported component types are {@code Byte}, {@code Double}, {@code Float}, {@code Integer}, {@code Long},
     * {@code Short}, {@code BigInteger} and {@code BigDecimal}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * List.empty().average()              // = None
     * List.of(1, 2, 3).average()          // = Some(2.0)
     * List.of(0.1, 0.2, 0.3).average()    // = Some(0.2)
     * List.of(&quot;apple&quot;, &quot;pear&quot;).average()  // throws
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @return {@code Some(average)} or {@code None}, if there are no elements
     * @throws UnsupportedOperationException if this elements are not numeric
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Option&lt;Double&gt; average() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L212">            return Option.none();</span>
        } else {
<span class="fc bfc" id="L214" title="All 2 branches covered.">            final Traversable&lt;?&gt; objects = isTraversableAgain() ? this : toStream();</span>
<span class="fc" id="L215">            final Object head = objects.head();</span>
            final double d;
<span class="fc bfc" id="L217" title="All 6 branches covered.">            if (head instanceof Integer || head instanceof Short || head instanceof Byte) {</span>
<span class="fc" id="L218">                d = ((Traversable&lt;Number&gt;) objects)</span>
<span class="fc" id="L219">                        .toJavaStream()</span>
<span class="fc" id="L220">                        .mapToInt(Number::intValue)</span>
<span class="fc" id="L221">                        .average()</span>
<span class="fc" id="L222">                        .getAsDouble();</span>
<span class="fc bfc" id="L223" title="All 6 branches covered.">            } else if (head instanceof Double || head instanceof Float || head instanceof BigDecimal) {</span>
<span class="fc" id="L224">                d = ((Traversable&lt;Number&gt;) objects)</span>
<span class="fc" id="L225">                        .toJavaStream()</span>
<span class="fc" id="L226">                        .mapToDouble(Number::doubleValue)</span>
<span class="fc" id="L227">                        .average()</span>
<span class="fc" id="L228">                        .getAsDouble();</span>
<span class="fc bfc" id="L229" title="All 4 branches covered.">            } else if (head instanceof Long || head instanceof BigInteger) {</span>
<span class="fc" id="L230">                d = ((Traversable&lt;Number&gt;) objects)</span>
<span class="fc" id="L231">                        .toJavaStream()</span>
<span class="fc" id="L232">                        .mapToLong(Number::longValue)</span>
<span class="fc" id="L233">                        .average()</span>
<span class="fc" id="L234">                        .getAsDouble();</span>
            } else {
<span class="fc" id="L236">                throw new UnsupportedOperationException(&quot;not numeric&quot;);</span>
            }
<span class="fc" id="L238">            return Option.some(d);</span>
        }
    }

    /**
     * Returns an empty version of this traversable, i.e. {@code this.clear().isEmpty() == true}.
     *
     * @return an empty Traversable.
     */
    Traversable&lt;T&gt; clear();

    /**
     * Tests if this Traversable contains all given elements.
     * &lt;p&gt;
     * The result is equivalent to
     * {@code elements.isEmpty() ? true : contains(elements.head()) &amp;&amp; containsAll(elements.tail())} but implemented
     * without recursion.
     *
     * @param elements A List of values of type T.
     * @return true, if this List contains all given elements, false otherwise.
     * @throws NullPointerException if {@code elements} is null
     */
    default boolean containsAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L261">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        return List.ofAll(elements).distinct().findFirst(e -&gt; !this.contains(e)).isEmpty();</span>
    }

    /**
     * Counts the elements which satisfy the given predicate.
     *
     * @param predicate A predicate
     * @return A number {@code &gt;= 0}
     * @throws NullPointerException if {@code predicate} is null.
     */
    default int count(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L273">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        return foldLeft(0, (i, t) -&gt; predicate.test(t) ? i + 1 : i);</span>
    }

    /**
     * Returns a new version of this which contains no duplicates. Elements are compared using {@code equals}.
     *
     * @return a new {@code Traversable} containing this elements without duplicates
     */
    Traversable&lt;T&gt; distinct();

    /**
     * Returns a new version of this which contains no duplicates. Elements are compared using the given
     * {@code comparator}.
     *
     * @param comparator A comparator
     * @return a new {@code Traversable} containing this elements without duplicates
     * @throws NullPointerException if {@code comparator} is null.
     */
    Traversable&lt;T&gt; distinctBy(Comparator&lt;? super T&gt; comparator);

    /**
     * Returns a new version of this which contains no duplicates. Elements mapped to keys which are compared using
     * {@code equals}.
     * &lt;p&gt;
     * The elements of the result are determined in the order of their occurrence - first match wins.
     *
     * @param keyExtractor A key extractor
     * @param &lt;U&gt;          key type
     * @return a new {@code Traversable} containing this elements without duplicates
     * @throws NullPointerException if {@code keyExtractor} is null
     */
    &lt;U&gt; Traversable&lt;T&gt; distinctBy(Function&lt;? super T, ? extends U&gt; keyExtractor);

    /**
     * Drops the first n elements of this or all elements, if this length &amp;lt; n.
     *
     * @param n The number of elements to drop.
     * @return a new instance consisting of all elements of this except the first n ones, or else the empty instance,
     * if this has less than n elements.
     */
    Traversable&lt;T&gt; drop(int n);

    /**
     * Drops the last n elements of this or all elements, if this length &amp;lt; n.
     *
     * @param n The number of elements to drop.
     * @return a new instance consisting of all elements of this except the last n ones, or else the empty instance,
     * if this has less than n elements.
     */
    Traversable&lt;T&gt; dropRight(int n);

    /**
     * Drops elements until the predicate holds for the current element.
     * &lt;p&gt;
     * Note: This is essentially the same as {@code dropWhile(predicate.negate())}. It is intended to be used with
     * method references, which cannot be negated directly.
     *
     * @param predicate A condition tested subsequently for this elements.
     * @return a new instance consisting of all elements starting from the first one which does satisfy the given
     * predicate.
     * @throws NullPointerException if {@code predicate} is null
     */
    Traversable&lt;T&gt; dropUntil(Predicate&lt;? super T&gt; predicate);

    /**
     * Drops elements while the predicate holds for the current element.
     *
     * @param predicate A condition tested subsequently for this elements starting with the first.
     * @return a new instance consisting of all elements starting from the first one which does not satisfy the
     * given predicate.
     * @throws NullPointerException if {@code predicate} is null
     */
    Traversable&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate);

    /**
     * Checks, if a unique elements exists such that the predicate holds.
     *
     * @param predicate A Predicate
     * @return true, if predicate holds for a unique element, false otherwise
     * @throws NullPointerException if {@code predicate} is null
     */
    default boolean existsUnique(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L356">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L357">        boolean exists = false;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        for (T t : this) {</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">            if (predicate.test(t)) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                if (exists) {</span>
<span class="fc" id="L361">                    return false;</span>
                } else {
<span class="fc" id="L363">                    exists = true;</span>
                }
            }
<span class="fc" id="L366">        }</span>
<span class="fc" id="L367">        return exists;</span>
    }

    /**
     * Returns a new traversable consisting of all elements which satisfy the given predicate.
     *
     * @param predicate A predicate
     * @return a new traversable
     * @throws NullPointerException if {@code predicate} is null
     */
    @Override
    Traversable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);
    
    @Override
    Traversable&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns the first element of this which satisfies the given predicate.
     *
     * @param predicate A predicate.
     * @return Some(element) or None, where element may be null (i.e. {@code List.of(null).findFirst(e -&gt; e == null)}).
     * @throws NullPointerException if {@code predicate} is null
     */
    default Option&lt;T&gt; findFirst(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L391">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        for (T a : this) {</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if (predicate.test(a)) {</span>
<span class="fc" id="L394">                return Option.some(a); // may be Some(null)</span>
            }
<span class="fc" id="L396">        }</span>
<span class="fc" id="L397">        return Option.none();</span>
    }

    /**
     * Returns the last element of this which satisfies the given predicate.
     * &lt;p&gt;
     * Same as {@code reverse().findFirst(predicate)}.
     *
     * @param predicate A predicate.
     * @return Some(element) or None, where element may be null (i.e. {@code List.of(null).findFirst(e -&gt; e == null)}).
     * @throws NullPointerException if {@code predicate} is null
     */
    default Option&lt;T&gt; findLast(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L410">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L411">        return iterator().findLast(predicate);</span>
    }

    /**
     * FlatMaps this Traversable.
     *
     * @param mapper A mapper
     * @param &lt;U&gt;    The resulting component type.
     * @return A new Traversable instance.
     */
    @Override
    &lt;U&gt; Traversable&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper);

    /**
     * Accumulates the elements of this Traversable by successively calling the given function {@code f} from the left,
     * starting with a value {@code zero} of type B.
     * &lt;p&gt;
     * Example: Reverse and map a Traversable in one pass
     * &lt;pre&gt;&lt;code&gt;
     * List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).foldLeft(List.empty(), (xs, x) -&amp;gt; xs.prepend(x.toUpperCase()))
     * // = List(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param zero Value to start the accumulation with.
     * @param f    The accumulator function.
     * @param &lt;U&gt;  Result type of the accumulator.
     * @return an accumulated version of this.
     * @throws NullPointerException if {@code f} is null
     */
    @Override
    default &lt;U&gt; U foldLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; f) {
<span class="fc" id="L442">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L443">        U xs = zero;</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        for (T x : this) {</span>
<span class="fc" id="L445">            xs = f.apply(xs, x);</span>
<span class="fc" id="L446">        }</span>
<span class="fc" id="L447">        return xs;</span>
    }

    /**
     * Accumulates the elements of this Traversable by successively calling the given function {@code f} from the right,
     * starting with a value {@code zero} of type B.
     * &lt;p&gt;
     * Example: {@code List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).foldRight(&quot;&quot;, (x, xs) -&gt; x + xs) = &quot;abc&quot;}
     *
     * @param zero Value to start the accumulation with.
     * @param f    The accumulator function.
     * @param &lt;U&gt;  Result type of the accumulator.
     * @return an accumulated version of this.
     * @throws NullPointerException if {@code f} is null
     */
    @Override
    &lt;U&gt; U foldRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; f);

    @Override
    default T get() {
<span class="fc" id="L467">        return iterator().next();</span>
    }

    /**
     * Groups this elements by classifying the elements.
     *
     * @param classifier A function which classifies elements into classes
     * @param &lt;C&gt;        classified class type
     * @return A Map containing the grouped elements
     * @throws NullPointerException if {@code classifier} is null.
     */
    &lt;C&gt; Map&lt;C, ? extends Traversable&lt;T&gt;&gt; groupBy(Function&lt;? super T, ? extends C&gt; classifier);

    /**
     * Groups this {@code Traversable} into fixed size blocks.
     * &lt;p&gt;
     * Let length be the length of this Iterable. Then grouped is defined as follows:
     * &lt;ul&gt;
     * &lt;li&gt;If {@code this.isEmpty()}, the resulting {@code Iterator} is empty.&lt;/li&gt;
     * &lt;li&gt;If {@code size &lt;= length}, the resulting {@code Iterator} will contain {@code length / size} blocks of size
     * {@code size} and maybe a non-empty block of size {@code length % size}, if there are remaining elements.&lt;/li&gt;
     * &lt;li&gt;If {@code size &gt; length}, the resulting {@code Iterator} will contain one block of size {@code length}.&lt;/li&gt;
     * &lt;/ul&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * [].grouped(1) = []
     * [].grouped(0) throws
     * [].grouped(-1) throws
     * [1,2,3,4].grouped(2) = [[1,2],[3,4]]
     * [1,2,3,4,5].grouped(2) = [[1,2],[3,4],[5]]
     * [1,2,3,4].grouped(5) = [[1,2,3,4]]
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * Please note that {@code grouped(int)} is a special case of {@linkplain #sliding(int, int)}, i.e.
     * {@code grouped(size)} is the same as {@code sliding(size, size)}.
     *
     * @param size a positive block size
     * @return A new Iterator of grouped blocks of the given size
     * @throws IllegalArgumentException if {@code size} is negative or zero
     */
    Iterator&lt;? extends Traversable&lt;T&gt;&gt; grouped(int size);

    /**
     * Checks if this Traversable is known to have a finite size.
     * &lt;p&gt;
     * This method should be implemented by classes only, i.e. not by interfaces.
     *
     * @return true, if this Traversable is known to hafe a finite size, false otherwise.
     */
    boolean hasDefiniteSize();

    /**
     * Returns the first element of a non-empty Traversable.
     *
     * @return The first element of this Traversable.
     * @throws NoSuchElementException if this is empty
     */
    T head();

    /**
     * Returns the first element of a non-empty Traversable as {@code Option}.
     *
     * @return {@code Some(element)} or {@code None} if this is empty.
     */
    Option&lt;T&gt; headOption();

    /**
     * Dual of {@linkplain #tail()}, returning all elements except the last.
     *
     * @return a new instance containing all elements except the last.
     * @throws UnsupportedOperationException if this is empty
     */
    Traversable&lt;T&gt; init();

    /**
     * Dual of {@linkplain #tailOption()}, returning all elements except the last as {@code Option}.
     *
     * @return {@code Some(traversable)} or {@code None} if this is empty.
     */
    Option&lt;? extends Traversable&lt;T&gt;&gt; initOption();

    /**
     * Checks if this Traversable is empty.
     *
     * @return true, if this Traversable contains no elements, false otherwise.
     */
    @Override
    boolean isEmpty();

    /**
     * Each of Javaslang's collections may contain more than one element.
     *
     * @return {@code false}
     */
    @Override
    default boolean isSingleValued() {
<span class="fc" id="L565">        return false;</span>
    }

    /**
     * Checks if this Traversable can be repeatedly traversed.
     * &lt;p&gt;
     * This method should be implemented by classes only, i.e. not by interfaces.
     *
     * @return true, if this Traversable is known to be traversable repeatedly, false otherwise.
     */
    boolean isTraversableAgain();

    /**
     * An iterator by means of head() and tail(). Subclasses may want to override this method.
     *
     * @return A new Iterator of this Traversable elements.
     */
    @Override
    default Iterator&lt;T&gt; iterator() {
<span class="fc" id="L584">        final Traversable&lt;T&gt; that = this;</span>
<span class="fc" id="L585">        return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L587">            Traversable&lt;T&gt; traversable = that;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L591" title="All 2 branches covered.">                return !traversable.isEmpty();</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L596">                final T result = traversable.head();</span>
<span class="fc" id="L597">                traversable = traversable.tail();</span>
<span class="fc" id="L598">                return result;</span>
            }
        };
    }

    /**
     * Dual of {@linkplain #head()}, returning the last element.
     *
     * @return the last element.
     * @throws NoSuchElementException is this is empty
     */
    default T last() {
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L611">            throw new NoSuchElementException(&quot;last of empty Traversable&quot;);</span>
        } else {
<span class="fc" id="L613">            final Iterator&lt;T&gt; it = iterator();</span>
<span class="fc" id="L614">            T result = null;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L616">                result = it.next();</span>
            }
<span class="fc" id="L618">            return result;</span>
        }
    }

    /**
     * Dual of {@linkplain #headOption()}, returning the last element as {@code Opiton}.
     *
     * @return {@code Some(element)} or {@code None} if this is empty.
     */
    default Option&lt;T&gt; lastOption() {
<span class="fc bfc" id="L628" title="All 2 branches covered.">        return isEmpty() ? Option.none() : Option.some(last());</span>
    }

    /**
     * Computes the number of elements of this Traversable.
     * &lt;p&gt;
     * Same as {@link #size()}.
     *
     * @return the number of elements
     */
    int length();

    /**
     * Maps the elements of this {@code Traversable} to elements of a new type preserving their order, if any.
     *
     * @param mapper A mapper.
     * @param &lt;U&gt;    Component type of the target Traversable
     * @return a mapped Traversable
     * @throws NullPointerException if {@code mapper} is null
     */
    @Override
    &lt;U&gt; Traversable&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper);

    @Override
    Match.MatchMonad.Of&lt;? extends Traversable&lt;T&gt;&gt; match();

    /**
     * Calculates the maximum of this elements according to their natural order.
     *
     * @return {@code Some(maximum)} of this elements or {@code None} if this is empty or this elements are not comparable
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Option&lt;T&gt; max() {
<span class="fc" id="L661">        final Stream&lt;T&gt; stream = Stream.ofAll(iterator());</span>
<span class="pc bpc" id="L662" title="1 of 4 branches missed.">        if (isEmpty() || !(stream.head() instanceof Comparable)) {</span>
<span class="fc" id="L663">            return Option.none();</span>
        } else {
<span class="fc" id="L665">            return stream.maxBy((o1, o2) -&gt; ((Comparable&lt;T&gt;) o1).compareTo(o2));</span>
        }
    }

    /**
     * Calculates the maximum of this elements using a specific comparator.
     *
     * @param comparator A non-null element comparator
     * @return {@code Some(maximum)} of this elements or {@code None} if this is empty
     * @throws NullPointerException if {@code comparator} is null
     */
    default Option&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L677">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L679">            return Option.none();</span>
        } else {
<span class="fc bfc" id="L681" title="All 2 branches covered.">            final T value = reduce((t1, t2) -&gt; comparator.compare(t1, t2) &gt;= 0 ? t1 : t2);</span>
<span class="fc" id="L682">            return Option.some(value);</span>
        }
    }

    /**
     * Calculates the maximum of this elements within the co-domain of a specific function.
     *
     * @param f   A function that maps this elements to comparable elements
     * @param &lt;U&gt; The type where elements are compared
     * @return The element of type T which is the maximum within U
     * @throws NullPointerException if {@code f} is null.
     */
    default &lt;U extends Comparable&lt;? super U&gt;&gt; Option&lt;T&gt; maxBy(Function&lt;? super T, ? extends U&gt; f) {
<span class="fc" id="L695">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L697">            return Option.none();</span>
        } else {
<span class="fc" id="L699">            final Iterator&lt;T&gt; iter = iterator();</span>
<span class="fc" id="L700">            T tm = iter.next();</span>
<span class="fc" id="L701">            U um = f.apply(tm);</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L703">                final T t = iter.next();</span>
<span class="fc" id="L704">                final U u = f.apply(t);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                if (u.compareTo(um) &gt; 0) {</span>
<span class="fc" id="L706">                    um = u;</span>
<span class="fc" id="L707">                    tm = t;</span>
                }
<span class="fc" id="L709">            }</span>
<span class="fc" id="L710">            return Option.some(tm);</span>
        }
    }

    /**
     * Calculates the minimum of this elements according to their natural order.
     *
     * @return {@code Some(minimum)} of this elements or {@code None} if this is empty or this elements are not comparable
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Option&lt;T&gt; min() {
<span class="fc" id="L721">        final Stream&lt;T&gt; stream = Stream.ofAll(iterator());</span>
<span class="pc bpc" id="L722" title="1 of 4 branches missed.">        if (isEmpty() || !(stream.head() instanceof Comparable)) {</span>
<span class="fc" id="L723">            return Option.none();</span>
        } else {
<span class="fc" id="L725">            return stream.minBy((o1, o2) -&gt; ((Comparable&lt;T&gt;) o1).compareTo(o2));</span>
        }
    }

    /**
     * Calculates the minimum of this elements using a specific comparator.
     *
     * @param comparator A non-null element comparator
     * @return {@code Some(minimum)} of this elements or {@code None} if this is empty
     * @throws NullPointerException if {@code comparator} is null
     */
    default Option&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L737">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L739">            return Option.none();</span>
        } else {
<span class="fc bfc" id="L741" title="All 2 branches covered.">            final T value = reduce((t1, t2) -&gt; comparator.compare(t1, t2) &lt;= 0 ? t1 : t2);</span>
<span class="fc" id="L742">            return Option.some(value);</span>
        }
    }

    /**
     * Calculates the minimum of this elements within the co-domain of a specific function.
     *
     * @param f   A function that maps this elements to comparable elements
     * @param &lt;U&gt; The type where elements are compared
     * @return The element of type T which is the minimum within U
     * @throws NullPointerException if {@code f} is null.
     */
    default &lt;U extends Comparable&lt;? super U&gt;&gt; Option&lt;T&gt; minBy(Function&lt;? super T, ? extends U&gt; f) {
<span class="fc" id="L755">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L757">            return Option.none();</span>
        } else {
<span class="fc" id="L759">            final Iterator&lt;T&gt; iter = iterator();</span>
<span class="fc" id="L760">            T tm = iter.next();</span>
<span class="fc" id="L761">            U um = f.apply(tm);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L763">                final T t = iter.next();</span>
<span class="fc" id="L764">                final U u = f.apply(t);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                if (u.compareTo(um) &lt; 0) {</span>
<span class="fc" id="L766">                    um = u;</span>
<span class="fc" id="L767">                    tm = t;</span>
                }
<span class="fc" id="L769">            }</span>
<span class="fc" id="L770">            return Option.some(tm);</span>
        }
    }

    /**
     * Joins the elements of this by concatenating their string representations.
     * &lt;p&gt;
     * This has the same effect as calling {@code mkString(&quot;&quot;, &quot;&quot;, &quot;&quot;)}.
     *
     * @return a new String
     */
    default String mkString() {
<span class="fc" id="L782">        return mkString(&quot;&quot;, &quot;&quot;, &quot;&quot;);</span>
    }

    /**
     * Joins the string representations of this elements using a specific delimiter.
     * &lt;p&gt;
     * This has the same effect as calling {@code mkString(delimiter, &quot;&quot;, &quot;&quot;)}.
     *
     * @param delimiter A delimiter string put between string representations of elements of this
     * @return A new String
     */
    default String mkString(CharSequence delimiter) {
<span class="fc" id="L794">        return mkString(&quot;&quot;, delimiter, &quot;&quot;);</span>
    }

    /**
     * Joins the string representations of this elements using a specific delimiter, prefix and suffix.
     * &lt;p&gt;
     * Example: {@code List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).mkString(&quot;, &quot;, &quot;Chars(&quot;, &quot;)&quot;) = &quot;Chars(a, b, c)&quot;}
     *
     * @param prefix    prefix of the resulting string
     * @param delimiter A delimiter string put between string representations of elements of this
     * @param suffix    suffix of the resulting string
     * @return a new String
     */
    default String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
<span class="fc" id="L808">        final StringBuilder builder = new StringBuilder(prefix);</span>
<span class="fc" id="L809">        iterator().map(String::valueOf).intersperse(String.valueOf(delimiter)).forEach(builder::append);</span>
<span class="fc" id="L810">        return builder.append(suffix).toString();</span>
    }

    /**
     * Creates a partition of this {@code Traversable} by splitting this elements in two in distinct tarversables
     * according to a predicate.
     *
     * @param predicate A predicate which classifies an element if it is in the first or the second traversable.
     * @return A disjoint union of two traversables. The first {@code Traversable} contains all elements that satisfy the given {@code predicate}, the second {@code Traversable} contains all elements that don't. The original order of elements is preserved.
     * @throws NullPointerException if predicate is null
     */
    Tuple2&lt;? extends Traversable&lt;T&gt;, ? extends Traversable&lt;T&gt;&gt; partition(Predicate&lt;? super T&gt; predicate);

    @Override
    Traversable&lt;T&gt; peek(Consumer&lt;? super T&gt; action);

    /**
     * Calculates the product of this elements. Supported component types are {@code Byte}, {@code Double}, {@code Float},
     * {@code Integer}, {@code Long}, {@code Short}, {@code BigInteger} and {@code BigDecimal}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * List.empty().product()              // = 1
     * List.of(1, 2, 3).product()          // = 6
     * List.of(0.1, 0.2, 0.3).product()    // = 0.006
     * List.of(&quot;apple&quot;, &quot;pear&quot;).product()  // throws
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @return a {@code Number} representing the sum of this elements
     * @throws UnsupportedOperationException if this elements are not numeric
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Number product() {
<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L846">            return 1;</span>
        } else {
<span class="fc bfc" id="L848" title="All 2 branches covered.">            final Traversable&lt;?&gt; objects = isTraversableAgain() ? this : toStream();</span>
<span class="fc" id="L849">            final Object head = objects.head();</span>
<span class="fc bfc" id="L850" title="All 6 branches covered.">            if (head instanceof Integer || head instanceof Short || head instanceof Byte) {</span>
<span class="fc" id="L851">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToInt(Number::intValue).reduce(1,</span>
<span class="fc" id="L852">                        (i1, i2) -&gt; i1 * i2);</span>
<span class="fc bfc" id="L853" title="All 6 branches covered.">            } else if (head instanceof Double || head instanceof Float || head instanceof BigDecimal) {</span>
<span class="fc" id="L854">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToDouble(Number::doubleValue).reduce(1.0,</span>
<span class="fc" id="L855">                        (d1, d2) -&gt; d1 * d2);</span>
<span class="fc bfc" id="L856" title="All 4 branches covered.">            } else if (head instanceof Long || head instanceof BigInteger) {</span>
<span class="fc" id="L857">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToLong(Number::longValue).reduce(1L,</span>
<span class="fc" id="L858">                        (l1, l2) -&gt; l1 * l2);</span>
            } else {
<span class="fc" id="L860">                throw new UnsupportedOperationException(&quot;not numeric&quot;);</span>
            }
        }
    }

    /**
     * Accumulates the elements of this Traversable by successively calling the given operation {@code op} from the left.
     *
     * @param op A BiFunction of type T
     * @return the reduced value.
     * @throws NoSuchElementException if this is empty
     * @throws NullPointerException   if {@code op} is null
     */
    @Override
    default T reduceLeft(BiFunction&lt;? super T, ? super T, ? extends T&gt; op) {
<span class="fc" id="L875">        Objects.requireNonNull(op, &quot;op is null&quot;);</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L877">            throw new NoSuchElementException(&quot;reduceLeft on Nil&quot;);</span>
        } else {
<span class="fc" id="L879">            return tail().foldLeft(head(), op);</span>
        }
    }

    /**
     * Accumulates the elements of this Traversable by successively calling the given operation {@code op} from the right.
     *
     * @param op An operation of type T
     * @return the reduced value.
     * @throws NoSuchElementException if this is empty
     * @throws NullPointerException   if {@code op} is null
     */
    @Override
    default T reduceRight(BiFunction&lt;? super T, ? super T, ? extends T&gt; op) {
<span class="fc" id="L893">        Objects.requireNonNull(op, &quot;op is null&quot;);</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L895">            throw new NoSuchElementException(&quot;reduceRight on empty&quot;);</span>
        } else {
<span class="fc" id="L897">            return iterator().reduceRight(op);</span>
        }
    }

    /**
     * Replaces the first occurrence (if exists) of the given currentElement with newElement.
     *
     * @param currentElement An element to be substituted.
     * @param newElement     A replacement for currentElement.
     * @return a Traversable containing all elements of this where the first occurrence of currentElement is replaced with newELement.
     */
    Traversable&lt;T&gt; replace(T currentElement, T newElement);

    /**
     * Replaces all occurrences of the given currentElement with newElement.
     *
     * @param currentElement An element to be substituted.
     * @param newElement     A replacement for currentElement.
     * @return a Traversable containing all elements of this where all occurrences of currentElement are replaced with newELement.
     */
    Traversable&lt;T&gt; replaceAll(T currentElement, T newElement);

    /**
     * Keeps all occurrences of the given elements from this.
     *
     * @param elements Elements to be kept.
     * @return a Traversable containing all occurrences of the given elements.
     * @throws NullPointerException if {@code elements} is null
     */
    Traversable&lt;T&gt; retainAll(Iterable&lt;? extends T&gt; elements);

    /**
     * Computes a prefix scan of the elements of the collection.
     *
     * Note: The neutral element z may be applied more than once.
     *
     * @param zero      neutral element for the operator op
     * @param operation the associative operator for the scan
     * @return a new traversable collection containing the prefix scan of the elements in this traversable collection
     * @throws NullPointerException if {@code operation} is null.
     */
    Traversable&lt;T&gt; scan(T zero, BiFunction&lt;? super T, ? super T, ? extends T&gt; operation);

    /**
     * Produces a collection containing cumulative results of applying the
     * operator going left to right.
     *
     * Note: will not terminate for infinite-sized collections.
     *
     * Note: might return different results for different runs, unless the
     * underlying collection type is ordered.
     *
     * @param &lt;U&gt;       the type of the elements in the resulting collection
     * @param zero      the initial value
     * @param operation the binary operator applied to the intermediate result and the element
     * @return collection with intermediate results
     * @throws NullPointerException if {@code operation} is null.
     */
    &lt;U&gt; Traversable&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; operation);

    /**
     * Produces a collection containing cumulative results of applying the
     * operator going right to left. The head of the collection is the last
     * cumulative result.
     *
     * Note: will not terminate for infinite-sized collections.
     *
     * Note: might return different results for different runs, unless the
     * underlying collection type is ordered.
     *
     * @param &lt;U&gt;       the type of the elements in the resulting collection
     * @param zero      the initial value
     * @param operation the binary operator applied to the intermediate result and the element
     * @return collection with intermediate results
     * @throws NullPointerException if {@code operation} is null.
     */
    &lt;U&gt; Traversable&lt;U&gt; scanRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; operation);

    /**
     * Computes the number of elements of this Traversable.
     * &lt;p&gt;
     * Same as {@link #length()}.
     *
     * @return the number of elements
     */
    default int size() {
<span class="fc" id="L983">        return length();</span>
    }

    /**
     * Slides a window of a specific {@code size} and step size 1 over this {@code Traversable} by calling
     * {@link #sliding(int, int)}.
     *
     * @param size a positive window size
     * @return a new Iterator of windows of a specific size using step size 1
     * @throws IllegalArgumentException if {@code size} is negative or zero
     */
    Iterator&lt;? extends Traversable&lt;T&gt;&gt; sliding(int size);

    /**
     * Slides a window of a specific {@code size} and {@code step} size over this {@code Traversable}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * [].sliding(1,1) = []
     * [1,2,3,4,5].sliding(2,3) = [[1,2],[4,5]]
     * [1,2,3,4,5].sliding(2,4) = [[1,2],[5]]
     * [1,2,3,4,5].sliding(2,5) = [[1,2]]
     * [1,2,3,4].sliding(5,3) = [[1,2,3,4],[4]]
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param size a positive window size
     * @param step a positive step size
     * @return a new Iterator of windows of a specific size using a specific step size
     * @throws IllegalArgumentException if {@code size} or {@code step} are negative or zero
     */
    Iterator&lt;? extends Traversable&lt;T&gt;&gt; sliding(int size, int step);

    /**
     * Returns a tuple where the first element is the longest prefix of elements that satisfy the given
     * {@code predicate} and the second element is the remainder.
     *
     * @param predicate A predicate.
     * @return a Tuple containing the longest prefix of elements that satisfy p and the remainder.
     * @throws NullPointerException if {@code predicate} is null
     */
    Tuple2&lt;? extends Traversable&lt;T&gt;, ? extends Traversable&lt;T&gt;&gt; span(Predicate&lt;? super T&gt; predicate);

    /**
     * Calculates the sum of this elements. Supported component types are {@code Byte}, {@code Double}, {@code Float},
     * {@code Integer}, {@code Long}, {@code Short}, {@code BigInteger} and {@code BigDecimal}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * List.empty().sum()              // = 0
     * List.of(1, 2, 3).sum()          // = 6
     * List.of(0.1, 0.2, 0.3).sum()    // = 0.6
     * List.of(&quot;apple&quot;, &quot;pear&quot;).sum()  // throws
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @return a {@code Number} representing the sum of this elements
     * @throws UnsupportedOperationException if this elements are not numeric
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Number sum() {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1047">            return 0;</span>
        } else {
<span class="fc bfc" id="L1049" title="All 2 branches covered.">            final Traversable&lt;?&gt; objects = isTraversableAgain() ? this : toStream();</span>
<span class="fc" id="L1050">            final Object head = objects.head();</span>
<span class="fc bfc" id="L1051" title="All 6 branches covered.">            if (head instanceof Integer || head instanceof Short || head instanceof Byte) {</span>
<span class="fc" id="L1052">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToInt(Number::intValue).sum();</span>
<span class="fc bfc" id="L1053" title="All 6 branches covered.">            } else if (head instanceof Double || head instanceof Float || head instanceof BigDecimal) {</span>
<span class="fc" id="L1054">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToDouble(Number::doubleValue).sum();</span>
<span class="fc bfc" id="L1055" title="All 4 branches covered.">            } else if (head instanceof Long || head instanceof BigInteger) {</span>
<span class="fc" id="L1056">                return ((Traversable&lt;Number&gt;) objects).toJavaStream().mapToLong(Number::longValue).sum();</span>
            } else {
<span class="fc" id="L1058">                throw new UnsupportedOperationException(&quot;not numeric&quot;);</span>
            }
        }
    }

    /**
     * Drops the first element of a non-empty Traversable.
     *
     * @return A new instance of Traversable containing all elements except the first.
     * @throws UnsupportedOperationException if this is empty
     */
    Traversable&lt;T&gt; tail();

    /**
     * Drops the first element of a non-empty Traversable and returns an {@code Option}.
     *
     * @return {@code Some(traversable)} or {@code None} if this is empty.
     */
    Option&lt;? extends Traversable&lt;T&gt;&gt; tailOption();

    /**
     * Takes the first n elements of this or all elements, if this length &amp;lt; n.
     * &lt;p&gt;
     * The result is equivalent to {@code sublist(0, max(0, min(length(), n)))} but does not throw if {@code n &lt; 0} or
     * {@code n &gt; length()}.
     * &lt;p&gt;
     * In the case of {@code n &lt; 0} the empty instance is returned, in the case of {@code n &gt; length()} this is returned.
     *
     * @param n The number of elements to take.
     * @return A new instance consisting the first n elements of this or all elements, if this has less than n elements.
     */
    Traversable&lt;T&gt; take(int n);

    /**
     * Takes the last n elements of this or all elements, if this length &amp;lt; n.
     * &lt;p&gt;
     * The result is equivalent to {@code sublist(max(0, min(length(), length() - n)), n)}, i.e. takeRight will not
     * throw if {@code n &lt; 0} or {@code n &gt; length()}.
     * &lt;p&gt;
     * In the case of {@code n &lt; 0} the empty instance is returned, in the case of {@code n &gt; length()} this is returned.
     *
     * @param n The number of elements to take.
     * @return A new instance consisting the first n elements of this or all elements, if this has less than n elements.
     */
    Traversable&lt;T&gt; takeRight(int n);

    /**
     * Takes elements until the predicate holds for the current element.
     * &lt;p&gt;
     * Note: This is essentially the same as {@code takeWhile(predicate.negate())}. It is intended to be used with
     * method references, which cannot be negated directly.
     *
     * @param predicate A condition tested subsequently for this elements.
     * @return a new instance consisting of all elements until the first which does satisfy the given predicate.
     * @throws NullPointerException if {@code predicate} is null
     */
    Traversable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate);

    /**
     * Takes elements while the predicate holds for the current element.
     *
     * @param predicate A condition tested subsequently for the contained elements.
     * @return a new instance consisting of all elements until the first which does not satisfy the given predicate.
     * @throws NullPointerException if {@code predicate} is null
     */
    Traversable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate);
    
    @Override
    &lt;U&gt; Traversable&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable);

    /**
     * Unzips this elements by mapping this elements to pairs which are subsequently split into two distinct
     * sets.
     *
     * @param unzipper a function which converts elements of this to pairs
     * @param &lt;T1&gt;     1st element type of a pair returned by unzipper
     * @param &lt;T2&gt;     2nd element type of a pair returned by unzipper
     * @return A pair of set containing elements split by unzipper
     * @throws NullPointerException if {@code unzipper} is null
     */
    &lt;T1, T2&gt; Tuple2&lt;? extends Traversable&lt;T1&gt;, ? extends Traversable&lt;T2&gt;&gt; unzip(
            Function&lt;? super T, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper);

    /**
     * Unzips this elements by mapping this elements to triples which are subsequently split into three distinct
     * sets.
     *
     * @param unzipper a function which converts elements of this to pairs
     * @param &lt;T1&gt;     1st element type of a triplet returned by unzipper
     * @param &lt;T2&gt;     2nd element type of a triplet returned by unzipper
     * @param &lt;T3&gt;     3rd element type of a triplet returned by unzipper
     * @return A triplet of set containing elements split by unzipper
     * @throws NullPointerException if {@code unzipper} is null
     */
    &lt;T1, T2, T3&gt; Tuple3&lt;? extends Traversable&lt;T1&gt;, ? extends Traversable&lt;T2&gt;, ? extends Traversable&lt;T3&gt;&gt; unzip3(
            Function&lt;? super T, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper);

    /**
     * Returns a traversable formed from this traversable and another Iterable collection by combining
     * corresponding elements in pairs. If one of the two iterables is longer than the other, its remaining elements
     * are ignored.
     * &lt;p&gt;
     * The length of the returned traversable is the minimum of the lengths of this traversable and {@code that}
     * iterable.
     *
     * @param &lt;U&gt;  The type of the second half of the returned pairs.
     * @param that The Iterable providing the second half of each result pair.
     * @return a new traversable containing pairs consisting of corresponding elements of this traversable and {@code that} iterable.
     * @throws NullPointerException if {@code that} is null
     */
    &lt;U&gt; Traversable&lt;Tuple2&lt;T, U&gt;&gt; zip(Iterable&lt;U&gt; that);

    /**
     * Returns a traversable formed from this traversable and another Iterable by combining corresponding elements in
     * pairs. If one of the two collections is shorter than the other, placeholder elements are used to extend the
     * shorter collection to the length of the longer.
     * &lt;p&gt;
     * The length of the returned traversable is the maximum of the lengths of this traversable and {@code that}
     * iterable.
     * &lt;p&gt;
     * Special case: if this traversable is shorter than that elements, and that elements contains duplicates, the
     * resulting traversable may be shorter than the maximum of the lengths of this and that because a traversable
     * contains an element at most once.
     * &lt;p&gt;
     * If this Traversable is shorter than that, thisElem values are used to fill the result.
     * If that is shorter than this Traversable, thatElem values are used to fill the result.
     *
     * @param &lt;U&gt;      The type of the second half of the returned pairs.
     * @param that     The Iterable providing the second half of each result pair.
     * @param thisElem The element to be used to fill up the result if this traversable is shorter than that.
     * @param thatElem The element to be used to fill up the result if that is shorter than this traversable.
     * @return A new traversable containing pairs consisting of corresponding elements of this traversable and that.
     * @throws NullPointerException if {@code that} is null
     */
    &lt;U&gt; Traversable&lt;Tuple2&lt;T, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, T thisElem, U thatElem);

    /**
     * Zips this traversable with its indices.
     *
     * @return A new traversable containing all elements of this traversable paired with their index, starting with 0.
     */
    Traversable&lt;Tuple2&lt;T, Integer&gt;&gt; zipWithIndex();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>