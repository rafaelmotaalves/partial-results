<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Vector.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">Vector.java</span></div><h1>Vector.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.*;
import javaslang.collection.VectorModule.Combinations;
import javaslang.control.Match;
import javaslang.control.Option;

import java.io.Serializable;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collector;

/**
 * Vector is the default Seq implementation. It provides the best performance in between Array (with constant time element access)
 * and List (with constant time element addition).
 *
 * @param &lt;T&gt; Component type of the Vector.
 * @author Ruslan Sennov
 * @since 2.0.0
 */
public final class Vector&lt;T&gt; implements IndexedSeq&lt;T&gt;, Serializable {

    private static final long serialVersionUID = 1L;

<span class="fc" id="L30">    private static final Vector&lt;?&gt; EMPTY = new Vector&lt;&gt;(HashArrayMappedTrie.empty());</span>

    private final HashArrayMappedTrie&lt;Integer, T&gt; trie;
    private final int indexShift;
<span class="fc" id="L34">    private final transient Lazy&lt;Integer&gt; hashCode = Lazy.of(() -&gt; Traversable.hash(this));</span>

    private Vector(HashArrayMappedTrie&lt;Integer, T&gt; trie) {
<span class="fc" id="L37">        this(0, trie);</span>
<span class="fc" id="L38">    }</span>

<span class="fc" id="L40">    private Vector(int indexShift, HashArrayMappedTrie&lt;Integer, T&gt; trie) {</span>
<span class="fc" id="L41">        this.trie = trie;</span>
<span class="fc" id="L42">        this.indexShift = indexShift;</span>
<span class="fc" id="L43">    }</span>

    /**
     * Returns the empty Vector.
     *
     * @param &lt;T&gt; Component type.
     * @return The empty Vector.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Vector&lt;T&gt; empty() {
<span class="fc" id="L53">        return (Vector&lt;T&gt;) EMPTY;</span>
    }

    /**
     * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.Vector}.
     *
     * @param &lt;T&gt; Component type of the Vector.
     * @return A javaslang.collection.List Collector.
     */
    public static &lt;T&gt; Collector&lt;T, ArrayList&lt;T&gt;, Vector&lt;T&gt;&gt; collector() {
<span class="fc" id="L64">        final Supplier&lt;ArrayList&lt;T&gt;&gt; supplier = ArrayList::new;</span>
<span class="fc" id="L65">        final BiConsumer&lt;ArrayList&lt;T&gt;, T&gt; accumulator = ArrayList::add;</span>
<span class="fc" id="L66">        final BinaryOperator&lt;ArrayList&lt;T&gt;&gt; combiner = (left, right) -&gt; {</span>
<span class="fc" id="L67">            left.addAll(right);</span>
<span class="fc" id="L68">            return left;</span>
        };
<span class="fc" id="L70">        final Function&lt;ArrayList&lt;T&gt;, Vector&lt;T&gt;&gt; finisher = Vector::ofAll;</span>
<span class="fc" id="L71">        return Collector.of(supplier, accumulator, combiner, finisher);</span>
    }

    /**
     * Returns a singleton {@code Vector}, i.e. a {@code Vector} of one element.
     *
     * @param element An element.
     * @param &lt;T&gt;     The component type
     * @return A new Vector instance containing the given element
     */
    public static &lt;T&gt; Vector&lt;T&gt; of(T element) {
<span class="fc" id="L82">        return new Vector&lt;&gt;(HashArrayMappedTrie.&lt;Integer, T&gt; empty().put(0, element));</span>
    }

    /**
     * Creates a Vector of the given elements.
     *
     * @param &lt;T&gt;      Component type of the Vector.
     * @param elements Zero or more elements.
     * @return A vector containing the given elements in the same order.
     * @throws NullPointerException if {@code elements} is null
     */
    @SafeVarargs
    public static &lt;T&gt; Vector&lt;T&gt; of(T... elements) {
<span class="fc" id="L95">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L96">        HashArrayMappedTrie&lt;Integer, T&gt; result = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L98">            result = result.put(result.size(), element);</span>
        }
<span class="fc" id="L100">        return wrap(result);</span>
    }

    /**
     * Returns a Vector containing {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     *
     * @param &lt;T&gt; Component type of the Vector
     * @param n The number of elements in the Vector
     * @param f The Function computing element values
     * @return A Vector consisting of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code f} is null
     */
    public static &lt;T&gt; Vector&lt;T&gt; tabulate(int n, Function&lt;? super Integer, ? extends T&gt; f) {
<span class="fc" id="L114">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L115">        return Collections.tabulate(n, f, Vector.empty(), Vector::of);</span>
    }

    /**
     * Returns a Vector containing {@code n} values supplied by a given Supplier {@code s}.
     *
     * @param &lt;T&gt; Component type of the Vector
     * @param n The number of elements in the Vector
     * @param s The Supplier computing element values
     * @return A Vector of size {@code n}, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code s} is null
     */
    public static &lt;T&gt; Vector&lt;T&gt; fill(int n, Supplier&lt;? extends T&gt; s) {
<span class="fc" id="L128">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L129">        return Collections.fill(n, s, Vector.empty(), Vector::of);</span>
    }

    /**
     * Creates a Vector of the given elements.
     *
     * The resulting vector has the same iteration order as the given iterable of elements
     * if the iteration order of the elements is stable.
     *
     * @param &lt;T&gt;      Component type of the Vector.
     * @param elements An Iterable of elements.
     * @return A vector containing the given elements in the same order.
     * @throws NullPointerException if {@code elements} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Vector&lt;T&gt; ofAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L145">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (elements instanceof Vector) {</span>
<span class="fc" id="L147">            return (Vector&lt;T&gt;) elements;</span>
        } else {
<span class="fc" id="L149">            HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            for (T element : elements) {</span>
<span class="fc" id="L151">                trie = trie.put(trie.size(), element);</span>
<span class="fc" id="L152">            }</span>
<span class="fc" id="L153">            return wrap(trie);</span>
        }
    }

    /**
     * Creates a Vector based on the elements of a boolean array.
     *
     * @param array a boolean array
     * @return A new Vector of Boolean values
     */
    public static Vector&lt;Boolean&gt; ofAll(boolean[] array) {
<span class="fc" id="L164">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L165">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a byte array.
     *
     * @param array a byte array
     * @return A new Vector of Byte values
     */
    public static Vector&lt;Byte&gt; ofAll(byte[] array) {
<span class="fc" id="L175">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L176">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a char array.
     *
     * @param array a char array
     * @return A new Vector of Character values
     */
    public static Vector&lt;Character&gt; ofAll(char[] array) {
<span class="fc" id="L186">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L187">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a double array.
     *
     * @param array a double array
     * @return A new Vector of Double values
     */
    public static Vector&lt;Double&gt; ofAll(double[] array) {
<span class="fc" id="L197">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L198">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a float array.
     *
     * @param array a float array
     * @return A new Vector of Float values
     */
    public static Vector&lt;Float&gt; ofAll(float[] array) {
<span class="fc" id="L208">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L209">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of an int array.
     *
     * @param array an int array
     * @return A new Vector of Integer values
     */
    public static Vector&lt;Integer&gt; ofAll(int[] array) {
<span class="fc" id="L219">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L220">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a long array.
     *
     * @param array a long array
     * @return A new Vector of Long values
     */
    public static Vector&lt;Long&gt; ofAll(long[] array) {
<span class="fc" id="L230">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L231">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a Vector based on the elements of a short array.
     *
     * @param array a short array
     * @return A new Vector of Short values
     */
    public static Vector&lt;Short&gt; ofAll(short[] array) {
<span class="fc" id="L241">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L242">        return Vector.ofAll(Iterator.ofAll(array));</span>
    }

    public static Vector&lt;Character&gt; range(char from, char toExclusive) {
<span class="fc" id="L246">        return Vector.ofAll(Iterator.range(from, toExclusive));</span>
    }

    public static Vector&lt;Character&gt; rangeBy(char from, char toExclusive, int step) {
<span class="fc" id="L250">        return Vector.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static Vector&lt;Double&gt; rangeBy(double from, double toExclusive, double step) {
<span class="fc" id="L254">        return Vector.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a Vector of int numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.range(0, 0)  // = Vector()
     * Vector.range(2, 0)  // = Vector()
     * Vector.range(-2, 2) // = Vector(-2, -1, 0, 1)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of int values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static Vector&lt;Integer&gt; range(int from, int toExclusive) {
<span class="fc" id="L274">        return Vector.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a Vector of int numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeBy(1, 3, 1)  // = Vector(1, 2)
     * Vector.rangeBy(1, 4, 2)  // = Vector(1, 3)
     * Vector.rangeBy(4, 1, -2) // = Vector(4, 2)
     * Vector.rangeBy(4, 1, 2)  // = Vector()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static Vector&lt;Integer&gt; rangeBy(int from, int toExclusive, int step) {
<span class="fc" id="L300">        return Vector.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a Vector of long numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.range(0L, 0L)  // = Vector()
     * Vector.range(2L, 0L)  // = Vector()
     * Vector.range(-2L, 2L) // = Vector(-2L, -1L, 0L, 1L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of long values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static Vector&lt;Long&gt; range(long from, long toExclusive) {
<span class="fc" id="L320">        return Vector.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a Vector of long numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeBy(1L, 3L, 1L)  // = Vector(1L, 2L)
     * Vector.rangeBy(1L, 4L, 2L)  // = Vector(1L, 3L)
     * Vector.rangeBy(4L, 1L, -2L) // = Vector(4L, 2L)
     * Vector.rangeBy(4L, 1L, 2L)  // = Vector()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static Vector&lt;Long&gt; rangeBy(long from, long toExclusive, long step) {
<span class="fc" id="L346">        return Vector.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static Vector&lt;Character&gt; rangeClosed(char from, char toInclusive) {
<span class="fc" id="L350">        return Vector.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    public static Vector&lt;Character&gt; rangeClosedBy(char from, char toInclusive, int step) {
<span class="fc" id="L354">        return Vector.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    public static Vector&lt;Double&gt; rangeClosedBy(double from, double toInclusive, double step) {
<span class="fc" id="L358">        return Vector.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    /**
     * Creates a Vector of int numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeClosed(0, 0)  // = Vector(0)
     * Vector.rangeClosed(2, 0)  // = Vector()
     * Vector.rangeClosed(-2, 2) // = Vector(-2, -1, 0, 1, 2)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of int values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static Vector&lt;Integer&gt; rangeClosed(int from, int toInclusive) {
<span class="fc" id="L378">        return Vector.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a Vector of int numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeClosedBy(1, 3, 1)  // = Vector(1, 2, 3)
     * Vector.rangeClosedBy(1, 4, 2)  // = Vector(1, 3)
     * Vector.rangeClosedBy(4, 1, -2) // = Vector(4, 2)
     * Vector.rangeClosedBy(4, 1, 2)  // = Vector()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static Vector&lt;Integer&gt; rangeClosedBy(int from, int toInclusive, int step) {
<span class="fc" id="L404">        return Vector.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    /**
     * Creates a Vector of long numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeClosed(0L, 0L)  // = Vector(0L)
     * Vector.rangeClosed(2L, 0L)  // = Vector()
     * Vector.rangeClosed(-2L, 2L) // = Vector(-2L, -1L, 0L, 1L, 2L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of long values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static Vector&lt;Long&gt; rangeClosed(long from, long toInclusive) {
<span class="fc" id="L424">        return Vector.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a Vector of long numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Vector.rangeClosedBy(1L, 3L, 1L)  // = Vector(1L, 2L, 3L)
     * Vector.rangeClosedBy(1L, 4L, 2L)  // = Vector(1L, 3L)
     * Vector.rangeClosedBy(4L, 1L, -2L) // = Vector(4L, 2L)
     * Vector.rangeClosedBy(4L, 1L, 2L)  // = Vector()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static Vector&lt;Long&gt; rangeClosedBy(long from, long toInclusive, long step) {
<span class="fc" id="L450">        return Vector.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    @Override
    public Vector&lt;T&gt; append(T element) {
<span class="fc" id="L455">        return new Vector&lt;&gt;(indexShift, trie.put(length() + indexShift, element));</span>
    }

    @Override
    public Vector&lt;T&gt; appendAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L460">        HashArrayMappedTrie&lt;Integer, T&gt; result = trie;</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L462">            result = result.put(result.size() + indexShift, element);</span>
<span class="fc" id="L463">        }</span>
<span class="fc" id="L464">        return new Vector&lt;&gt;(indexShift, result);</span>
    }

    @Override
    public Vector&lt;T&gt; clear() {
<span class="fc" id="L469">        return Vector.empty();</span>
    }

    @Override
    public Vector&lt;Vector&lt;T&gt;&gt; combinations() {
<span class="fc" id="L474">        return Vector.rangeClosed(0, length()).map(this::combinations).flatMap(Function.identity());</span>
    }

    @Override
    public Vector&lt;Vector&lt;T&gt;&gt; combinations(int k) {
<span class="fc" id="L479">        return Combinations.apply(this, Math.max(k, 0));</span>
    }

    @Override
    public Vector&lt;Tuple2&lt;T, T&gt;&gt; crossProduct() {
<span class="fc" id="L484">        return crossProduct(this);</span>
    }

    @Override
    public Vector&lt;Vector&lt;T&gt;&gt; crossProduct(int power) {
<span class="fc" id="L489">        return Collections.crossProduct(this, power).map(Vector::ofAll).toVector();</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;Tuple2&lt;T, U&gt;&gt; crossProduct(Iterable&lt;? extends U&gt; that) {
<span class="fc" id="L494">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L495">        final Vector&lt;U&gt; other = Vector.ofAll(that);</span>
<span class="fc" id="L496">        return flatMap(a -&gt; other.map((Function&lt;U, Tuple2&lt;T, U&gt;&gt;) b -&gt; Tuple.of(a, b)));</span>
    }

    @Override
    public Vector&lt;T&gt; distinct() {
<span class="fc" id="L501">        return distinctBy(Function.identity());</span>
    }

    @Override
    public Vector&lt;T&gt; distinctBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L506">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L507">        final java.util.Set&lt;T&gt; seen = new java.util.TreeSet&lt;&gt;(comparator);</span>
<span class="fc" id="L508">        return filter(seen::add);</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;T&gt; distinctBy(Function&lt;? super T, ? extends U&gt; keyExtractor) {
<span class="fc" id="L513">        Objects.requireNonNull(keyExtractor, &quot;keyExtractor is null&quot;);</span>
<span class="fc" id="L514">        final java.util.Set&lt;U&gt; seen = new java.util.HashSet&lt;&gt;();</span>
<span class="fc" id="L515">        return filter(t -&gt; seen.add(keyExtractor.apply(t)));</span>
    }

    @Override
    public Vector&lt;T&gt; drop(int n) {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L521">            return this;</span>
        }
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L524">            return empty();</span>
        }
<span class="fc" id="L526">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">        for (int i = n; i &lt; length(); i++) {</span>
<span class="fc" id="L528">            trie = trie.put(i - n, get(i));</span>
        }
<span class="fc" id="L530">        return wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; dropRight(int n) {
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L536">            return this;</span>
        }
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L539">            return empty();</span>
        }
<span class="fc" id="L541">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        for (int i = 0; i &lt; length() - n; i++) {</span>
<span class="fc" id="L543">            trie = trie.put(trie.size(), get(i));</span>
        }
<span class="fc" id="L545">        return wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; dropUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L550">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L551">        return dropWhile(predicate.negate());</span>
    }

    @Override
    public Vector&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L556">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (!predicate.test(get(i))) {</span>
<span class="fc" id="L559">                return drop(i);</span>
            }
        }
<span class="fc" id="L562">        return empty();</span>
    }

    @Override
    public Vector&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L567">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L568">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        for (T t : this) {</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (predicate.test(t)) {</span>
<span class="fc" id="L571">                trie = trie.put(trie.size(), t);</span>
            }
<span class="fc" id="L573">        }</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (trie.size() == length()) {</span>
<span class="fc" id="L575">            return this;</span>
        } else {
<span class="fc" id="L577">            return wrap(trie);</span>
        }
    }

    @Override
    public Vector&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L583">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L584">        return filter(predicate.negate());</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L589">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L591">            return empty();</span>
        } else {
<span class="fc" id="L593">            HashArrayMappedTrie&lt;Integer, U&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">            for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                for (U u : mapper.apply(get(i))) {</span>
<span class="fc" id="L596">                    trie = trie.put(trie.size(), u);</span>
<span class="fc" id="L597">                }</span>
            }
<span class="fc" id="L599">            return wrap(trie);</span>
        }
    }

    @Override
    public T get(int index) {
<span class="fc bfc" id="L605" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= length()) {</span>
<span class="fc" id="L606">            throw new IndexOutOfBoundsException(&quot;get(&quot; + index + &quot;)&quot;);</span>
        }
<span class="fc" id="L608">        return trie.get(index + indexShift).get();</span>
    }

    @Override
    public T head() {
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L614">            throw new NoSuchElementException(&quot;head of empty vector&quot;);</span>
        } else {
<span class="fc" id="L616">            return get(0);</span>
        }
    }

    @Override
    public Option&lt;T&gt; headOption() {
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L623">            return Option.none();</span>
        } else {
<span class="fc" id="L625">            return Option.some(get(0));</span>
        }
    }

    @Override
    public &lt;C&gt; Map&lt;C, Vector&lt;T&gt;&gt; groupBy(Function&lt;? super T, ? extends C&gt; classifier) {
<span class="fc" id="L631">        Objects.requireNonNull(classifier, &quot;classifier is null&quot;);</span>
<span class="fc" id="L632">        return iterator().groupBy(classifier).map((c, it) -&gt; Tuple.of(c, Vector.ofAll(it)));</span>
    }

    @Override
    public Iterator&lt;Vector&lt;T&gt;&gt; grouped(int size) {
<span class="fc" id="L637">        return sliding(size, size);</span>
    }

    @Override
    public boolean hasDefiniteSize() {
<span class="fc" id="L642">        return true;</span>
    }

    @Override
    public int indexOf(T element, int from) {
<span class="fc bfc" id="L647" title="All 2 branches covered.">        for (int i = from; i &lt; length(); i++) {</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">            if (Objects.equals(get(i), element)) {</span>
<span class="fc" id="L649">                return i;</span>
            }
        }
<span class="fc" id="L652">        return -1;</span>
    }

    @Override
    public Vector&lt;T&gt; init() {
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L658">            throw new UnsupportedOperationException(&quot;init of empty vector&quot;);</span>
        }
<span class="fc" id="L660">        return new Vector&lt;&gt;(indexShift, trie.remove(length() + indexShift - 1));</span>
    }

    @Override
    public Option&lt;? extends Vector&lt;T&gt;&gt; initOption() {
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L666">            return Option.none();</span>
        } else {
<span class="fc" id="L668">            return Option.some(init());</span>
        }
    }

    @Override
    public Vector&lt;T&gt; insert(int index, T element) {
<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L675">            throw new IndexOutOfBoundsException(&quot;insert(&quot; + index + &quot;, e)&quot;);</span>
        }
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (index &gt; length()) {</span>
<span class="fc" id="L678">            throw new IndexOutOfBoundsException(&quot;insert(&quot; + index + &quot;, e) on Vector of length &quot; + length());</span>
        }
<span class="fc" id="L680">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        for (int i = 0; i &lt;= length(); i++) {</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">            if (i == index) {</span>
<span class="fc" id="L683">                trie = trie.put(trie.size(), element);</span>
            }
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (i &lt; length()) {</span>
<span class="fc" id="L686">                trie = trie.put(trie.size(), get(i));</span>
            }
        }
<span class="fc" id="L689">        return new Vector&lt;&gt;(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; insertAll(int index, Iterable&lt;? extends T&gt; elements) {
<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L695">            throw new IndexOutOfBoundsException(&quot;insert(&quot; + index + &quot;, e)&quot;);</span>
        }
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (index &gt; length()) {</span>
<span class="fc" id="L698">            throw new IndexOutOfBoundsException(&quot;insert(&quot; + index + &quot;, e) on Vector of length &quot; + length());</span>
        }
<span class="fc" id="L700">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (int i = 0; i &lt;= length(); i++) {</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">            if (i == index) {</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                for (T element : elements) {</span>
<span class="fc" id="L704">                    trie = trie.put(trie.size(), element);</span>
<span class="fc" id="L705">                }</span>
            }
<span class="fc bfc" id="L707" title="All 2 branches covered.">            if (i &lt; length()) {</span>
<span class="fc" id="L708">                trie = trie.put(trie.size(), get(i));</span>
            }
        }
<span class="fc" id="L711">        return new Vector&lt;&gt;(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; intersperse(T element) {
<span class="fc" id="L716">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (i &gt; 0) {</span>
<span class="fc" id="L719">                trie = trie.put(trie.size(), element);</span>
            }
<span class="fc" id="L721">            trie = trie.put(trie.size(), get(i));</span>
        }
<span class="fc" id="L723">        return wrap(trie);</span>
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L728">        return trie.isEmpty();</span>
    }

    @Override
    public boolean isTraversableAgain() {
<span class="fc" id="L733">        return true;</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L738">        return new AbstractIterator&lt;T&gt;() {</span>
<span class="fc" id="L739">            private int index = indexShift;</span>
<span class="fc" id="L740">            private final int size = trie.size() + indexShift;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L744" title="All 2 branches covered.">                return index &lt; size;</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L749">                return trie.get(index++).get();</span>
            }
        };
    }

    @Override
    public int lastIndexOf(T element, int end) {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (int i = Math.min(end, length() - 1); i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">            if (Objects.equals(get(i), element)) {</span>
<span class="fc" id="L758">                return i;</span>
            }
        }
<span class="fc" id="L761">        return -1;</span>
    }

    @Override
    public int length() {
<span class="fc" id="L766">        return trie.size();</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L771">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L772">        HashArrayMappedTrie&lt;Integer, U&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L774">            trie = trie.put(i, mapper.apply(get(i)));</span>
        }
<span class="fc" id="L776">        return wrap(trie);</span>
    }

    @Override
    public Match.MatchMonad.Of&lt;Vector&lt;T&gt;&gt; match() {
<span class="fc" id="L781">        return Match.of(this);</span>
    }

    @Override
    public Vector&lt;T&gt; padTo(int length, T element) {
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (length &lt;= length()) {</span>
<span class="fc" id="L787">            return this;</span>
        } else {
<span class="fc" id="L789">            return appendAll(Iterator.gen(() -&gt; element).take(length - length()));</span>
        }
    }

    @Override
    public Vector&lt;T&gt; patch(int from, Iterable&lt;? extends T&gt; that, int replaced) {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        from = from &lt; 0 ? 0 : from;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        replaced = replaced &lt; 0 ? 0 : replaced;</span>
<span class="fc" id="L797">        Vector&lt;T&gt; result = take(from).appendAll(that);</span>
<span class="fc" id="L798">        from += replaced;</span>
<span class="fc" id="L799">        result = result.appendAll(drop(from));</span>
<span class="fc" id="L800">        return result;</span>
    }

    @Override
    public Tuple2&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; partition(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L805">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L806">        final java.util.List&lt;T&gt; left = new ArrayList&lt;&gt;(), right = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L808">            T t = get(i);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            (predicate.test(t) ? left : right).add(t);</span>
        }
<span class="fc" id="L811">        return Tuple.of(Vector.ofAll(left), Vector.ofAll(right));</span>
    }

    @Override
    public Vector&lt;T&gt; peek(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L816">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (!isEmpty()) {</span>
<span class="fc" id="L818">            action.accept(head());</span>
        }
<span class="fc" id="L820">        return this;</span>
    }

    @Override
    public Vector&lt;Vector&lt;T&gt;&gt; permutations() {
<span class="fc bfc" id="L825" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L826">            return Vector.empty();</span>
        } else {
<span class="fc" id="L828">            final Vector&lt;T&gt; tail = tail();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (tail.isEmpty()) {</span>
<span class="fc" id="L830">                return Vector.of(this);</span>
            } else {
<span class="fc" id="L832">                final Vector&lt;Vector&lt;T&gt;&gt; zero = empty();</span>
<span class="fc" id="L833">                return distinct().foldLeft(zero, (xs, x) -&gt; {</span>
<span class="fc" id="L834">                    final Function&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; prepend = l -&gt; l.prepend(x);</span>
<span class="fc" id="L835">                    return xs.appendAll(remove(x).permutations().map(prepend));</span>
                });
            }
        }
    }

    @Override
    public Vector&lt;T&gt; prepend(T element) {
<span class="fc" id="L843">        final int newIndexShift = indexShift - 1;</span>
<span class="fc" id="L844">        return new Vector&lt;&gt;(newIndexShift, trie.put(newIndexShift, element));</span>
    }

    @Override
    public Vector&lt;T&gt; prependAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L849">        List&lt;T&gt; list = List.ofAll(elements);</span>
<span class="fc" id="L850">        final int newIndexShift = indexShift - list.length();</span>
<span class="fc" id="L851">        HashArrayMappedTrie&lt;Integer, T&gt; newTrie = trie;</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">        for (int i = newIndexShift; !list.isEmpty(); i++) {</span>
<span class="fc" id="L853">            newTrie = newTrie.put(i, list.head());</span>
<span class="fc" id="L854">            list = list.tail();</span>
        }
<span class="fc" id="L856">        return new Vector&lt;&gt;(newIndexShift, newTrie);</span>
    }

    @Override
    public Vector&lt;T&gt; remove(T element) {
<span class="fc" id="L861">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L862">        boolean found = false;</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L864">            final T value = get(i);</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L866">                trie = trie.put(trie.size(), value);</span>
            } else {
<span class="fc bfc" id="L868" title="All 2 branches covered.">                if (element.equals(value)) {</span>
<span class="fc" id="L869">                    found = true;</span>
                } else {
<span class="fc" id="L871">                    trie = trie.put(trie.size(), value);</span>
                }
            }
        }
<span class="fc bfc" id="L875" title="All 2 branches covered.">        return trie.size() == length() ? this : wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; removeFirst(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L880">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L881">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L882">        boolean found = false;</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L884">            final T value = get(i);</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L886">                trie = trie.put(trie.size(), value);</span>
            } else {
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (predicate.test(value)) {</span>
<span class="fc" id="L889">                    found = true;</span>
                } else {
<span class="fc" id="L891">                    trie = trie.put(trie.size(), value);</span>
                }
            }
        }
<span class="fc bfc" id="L895" title="All 2 branches covered.">        return trie.size() == length() ? this : wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; removeLast(Predicate&lt;T&gt; predicate) {
<span class="fc" id="L900">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = length() - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (predicate.test(get(i))) {</span>
<span class="fc" id="L903">                return removeAt(i);</span>
            }
        }
<span class="fc" id="L906">        return this;</span>
    }

    @Override
    public Vector&lt;T&gt; removeAt(int index) {
<span class="fc bfc" id="L911" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L912">            throw new IndexOutOfBoundsException(&quot;removeAt(&quot; + index + &quot;)&quot;);</span>
        }
<span class="fc bfc" id="L914" title="All 2 branches covered.">        if (index &gt;= length()) {</span>
<span class="fc" id="L915">            throw new IndexOutOfBoundsException(&quot;removeAt(&quot; + index + &quot;)&quot;);</span>
        }
<span class="fc" id="L917">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">            if (i != index) {</span>
<span class="fc" id="L920">                trie = trie.put(trie.size(), get(i));</span>
            }
        }
<span class="fc" id="L923">        return wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; removeAll(T element) {
<span class="fc" id="L928">        HashArrayMappedTrie&lt;Integer, T&gt; result = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L930">            final T value = get(i);</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">            if (!element.equals(value)) {</span>
<span class="fc" id="L932">                result = result.put(result.size(), value);</span>
            }
        }
<span class="fc bfc" id="L935" title="All 2 branches covered.">        return result.size() == length() ? this : wrap(result);</span>

    }

    @Override
    public Vector&lt;T&gt; removeAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L941">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L942">        HashArrayMappedTrie&lt;T, T&gt; removed = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L944">            removed = removed.put(element, element);</span>
<span class="fc" id="L945">        }</span>
<span class="fc" id="L946">        HashArrayMappedTrie&lt;Integer, T&gt; result = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L947">        boolean found = false;</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L949">            T element = get(i);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            if (removed.get(element).isDefined()) {</span>
<span class="fc" id="L951">                found = true;</span>
            } else {
<span class="fc" id="L953">                result = result.put(result.size(), element);</span>
            }
        }
<span class="fc bfc" id="L956" title="All 2 branches covered.">        return found ? wrap(result) : this;</span>
    }

    @Override
    public Vector&lt;T&gt; replace(T currentElement, T newElement) {
<span class="fc" id="L961">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L962">        boolean found = false;</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L964">            final T value = get(i);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">            if (found) {</span>
<span class="fc" id="L966">                trie = trie.put(trie.size(), value);</span>
            } else {
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (currentElement.equals(value)) {</span>
<span class="fc" id="L969">                    trie = trie.put(trie.size(), newElement);</span>
<span class="fc" id="L970">                    found = true;</span>
                } else {
<span class="fc" id="L972">                    trie = trie.put(trie.size(), value);</span>
                }
            }
        }
<span class="fc bfc" id="L976" title="All 2 branches covered.">        return found ? new Vector&lt;&gt;(trie) : this;</span>
    }

    @Override
    public Vector&lt;T&gt; replaceAll(T currentElement, T newElement) {
<span class="fc" id="L981">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L982">        boolean changed = false;</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L984">            final T value = get(i);</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (currentElement.equals(value)) {</span>
<span class="fc" id="L986">                trie = trie.put(trie.size(), newElement);</span>
<span class="fc" id="L987">                changed = true;</span>
            } else {
<span class="fc" id="L989">                trie = trie.put(trie.size(), value);</span>
            }
        }
<span class="fc bfc" id="L992" title="All 2 branches covered.">        return changed ? wrap(trie) : this;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Vector&lt;T&gt; retainAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L998">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
        // TODO(Eclipse bug): remove cast + SuppressWarnings
<span class="fc" id="L1000">        final Vector&lt;T&gt; kept = (Vector&lt;T&gt;) (Object) Vector.ofAll(elements).distinct();</span>
<span class="fc" id="L1001">        HashArrayMappedTrie&lt;Integer, T&gt; result = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        for (T element : this) {</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            if (kept.contains(element)) {</span>
<span class="fc" id="L1004">                result = result.put(result.size(), element);</span>
            }
<span class="fc" id="L1006">        }</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        return result.size() == trie.size() ? this : wrap(result);</span>
    }

    @Override
    public Vector&lt;T&gt; reverse() {
<span class="fc" id="L1012">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L1014">            trie = trie.put(i, get(length() - 1 - i));</span>
        }
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        return trie.isEmpty() ? empty() : new Vector&lt;&gt;(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; scan(T zero, BiFunction&lt;? super T, ? super T, ? extends T&gt; operation) {
<span class="fc" id="L1021">        return scanLeft(zero, operation);</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; operation) {
<span class="fc" id="L1026">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L1027">        return Collections.scanLeft(this, zero, operation, Vector.empty(), Vector::append, Function.identity());</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;U&gt; scanRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; operation) {
<span class="fc" id="L1032">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L1033">        return Collections.scanRight(this, zero, operation, Vector.empty(), Vector::prepend, Function.identity());</span>
    }

    @Override
    public Vector&lt;T&gt; slice(int beginIndex, int endIndex) {
<span class="fc bfc" id="L1038" title="All 6 branches covered.">        if (beginIndex &gt;= endIndex || beginIndex &gt;= length() || isEmpty()) {</span>
<span class="fc" id="L1039">            return Vector.empty();</span>
        }
<span class="fc bfc" id="L1041" title="All 4 branches covered.">        if (beginIndex &lt;= 0 &amp;&amp; endIndex &gt;= length()) {</span>
<span class="fc" id="L1042">            return this;</span>
        }
<span class="fc" id="L1044">        final int index = Math.max(beginIndex, 0);</span>
<span class="fc" id="L1045">        final int length = Math.min(endIndex, length());</span>
<span class="fc" id="L1046">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        for (int i = index; i &lt; length; i++) {</span>
<span class="fc" id="L1048">            trie = trie.put(trie.size(), get(i));</span>
        }
<span class="fc" id="L1050">        return wrap(trie);</span>
    }

    @Override
    public Iterator&lt;Vector&lt;T&gt;&gt; sliding(int size) {
<span class="fc" id="L1055">        return sliding(size, 1);</span>
    }

    @Override
    public Iterator&lt;Vector&lt;T&gt;&gt; sliding(int size, int step) {
<span class="fc" id="L1060">        return iterator().sliding(size, step).map(Vector::ofAll);</span>
    }

    @Override
    public Vector&lt;T&gt; sort() {
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        return isEmpty() ? this : toJavaStream().sorted().collect(Vector.collector());</span>
    }

    @Override
    public Vector&lt;T&gt; sort(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L1070">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">        return isEmpty() ? this : toJavaStream().sorted(comparator).collect(Vector.collector());</span>
    }

    @Override
    public &lt;U extends Comparable&lt;? super U&gt;&gt; Vector&lt;T&gt; sortBy(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L1076">        return sortBy(U::compareTo, mapper);</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;T&gt; sortBy(Comparator&lt;? super U&gt; comparator, Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L1081">        final Function&lt;? super T, ? extends U&gt; domain = Function1.of(mapper::apply).memoized();</span>
<span class="fc" id="L1082">        return toJavaStream()</span>
<span class="fc" id="L1083">                .sorted((e1, e2) -&gt; comparator.compare(domain.apply(e1), domain.apply(e2)))</span>
<span class="fc" id="L1084">                .collect(collector());</span>
    }

    @Override
    public Tuple2&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; span(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1089">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1090">        return Tuple.of(takeWhile(predicate), dropWhile(predicate));</span>
    }

    @Override
    public Tuple2&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; splitAt(int n) {
<span class="fc" id="L1095">        return Tuple.of(take(n), drop(n));</span>
    }

    @Override
    public Tuple2&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; splitAt(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1100">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1101">        final Vector&lt;T&gt; init = takeWhile(predicate.negate());</span>
<span class="fc" id="L1102">        return Tuple.of(init, drop(init.length()));</span>
    }

    @Override
    public Tuple2&lt;Vector&lt;T&gt;, Vector&lt;T&gt;&gt; splitAtInclusive(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1107">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1108">        HashArrayMappedTrie&lt;Integer, T&gt; init = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        for (T t : this) {</span>
<span class="fc" id="L1110">            init = init.put(init.size(), t);</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">            if (predicate.test(t)) {</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">                if (init.size() == length()) {</span>
<span class="fc" id="L1113">                    Tuple.of(this, empty());</span>
                } else {
<span class="fc" id="L1115">                    return Tuple.of(new Vector&lt;&gt;(init), drop(init.size()));</span>
                }
            }
<span class="fc" id="L1118">        }</span>
<span class="fc" id="L1119">        return Tuple.of(this, empty());</span>
    }

    @Override
    public Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L1124">        return Spliterators.spliterator(iterator(), length(), Spliterator.ORDERED | Spliterator.IMMUTABLE);</span>
    }

    @Override
    public Vector&lt;T&gt; subSequence(int beginIndex) {
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        if (beginIndex &lt; 0) {</span>
<span class="fc" id="L1130">            throw new IndexOutOfBoundsException(&quot;slice(&quot; + beginIndex + &quot;)&quot;);</span>
        }
<span class="fc bfc" id="L1132" title="All 2 branches covered.">        if (beginIndex &gt; length()) {</span>
<span class="fc" id="L1133">            throw new IndexOutOfBoundsException(&quot;slice(&quot; + beginIndex + &quot;)&quot;);</span>
        }
<span class="fc" id="L1135">        return drop(beginIndex);</span>
    }

    @Override
    public Vector&lt;T&gt; subSequence(int beginIndex, int endIndex) {
<span class="fc bfc" id="L1140" title="All 6 branches covered.">        if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; length()) {</span>
<span class="fc" id="L1141">            throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L1142">                    String.format(&quot;slice(%s, %s) on List of length %s&quot;, beginIndex, endIndex, length()));</span>
        }
<span class="fc bfc" id="L1144" title="All 2 branches covered.">        if (beginIndex == endIndex) {</span>
<span class="fc" id="L1145">            return Vector.empty();</span>
        }
<span class="fc" id="L1147">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1148" title="All 2 branches covered.">        for (int i = beginIndex; i &lt; endIndex; i++) {</span>
<span class="fc" id="L1149">            trie = trie.put(trie.size(), get(i));</span>
        }
<span class="fc" id="L1151">        return wrap(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; tail() {
<span class="fc bfc" id="L1156" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1157">            throw new UnsupportedOperationException(&quot;tail of empty vector&quot;);</span>
        }
<span class="fc bfc" id="L1159" title="All 2 branches covered.">        if (length() == 1) {</span>
<span class="fc" id="L1160">            return empty();</span>
        } else {
<span class="fc" id="L1162">            final int newIndexShift = indexShift + 1;</span>
<span class="fc" id="L1163">            return new Vector&lt;&gt;(newIndexShift, trie.remove(indexShift));</span>
        }
    }

    @Override
    public Option&lt;Vector&lt;T&gt;&gt; tailOption() {
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1170">            return Option.none();</span>
        } else {
<span class="fc" id="L1172">            return Option.some(tail());</span>
        }
    }

    @Override
    public Vector&lt;T&gt; take(int n) {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L1179">            return this;</span>
        }
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L1182">            return empty();</span>
        }
<span class="fc" id="L1184">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1186">            trie = trie.put(i, get(i));</span>
        }
<span class="fc" id="L1188">        return new Vector&lt;&gt;(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; takeRight(int n) {
<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L1194">            return this;</span>
        }
<span class="fc bfc" id="L1196" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L1197">            return empty();</span>
        }
<span class="fc" id="L1199">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1201">            trie = trie.put(i, get(length() - n + i));</span>
        }
<span class="fc" id="L1203">        return new Vector&lt;&gt;(trie);</span>
    }

    @Override
    public Vector&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1208">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1209">        return takeWhile(predicate.negate());</span>
    }

    @Override
    public Vector&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1214">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1215">        HashArrayMappedTrie&lt;Integer, T&gt; trie = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        for (int i = 0; i &lt; length(); i++) {</span>
<span class="fc" id="L1217">            T value = get(i);</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">            if (!predicate.test(value)) {</span>
<span class="fc" id="L1219">                break;</span>
            }
<span class="fc" id="L1221">            trie = trie.put(i, get(i));</span>
        }
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        return trie.size() == length() ? this : wrap(trie);</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="fc" id="L1228">        return Vector.ofAll(iterable);</span>
    }

    @Override
    public &lt;T1, T2&gt; Tuple2&lt;Vector&lt;T1&gt;, Vector&lt;T2&gt;&gt; unzip(
            Function&lt;? super T, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L1234">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L1235">        HashArrayMappedTrie&lt;Integer, T1&gt; xs = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L1236">        HashArrayMappedTrie&lt;Integer, T2&gt; ys = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        for (T element : this) {</span>
<span class="fc" id="L1238">            final Tuple2&lt;? extends T1, ? extends T2&gt; t = unzipper.apply(element);</span>
<span class="fc" id="L1239">            xs = xs.put(xs.size(), t._1);</span>
<span class="fc" id="L1240">            ys = ys.put(ys.size(), t._2);</span>
<span class="fc" id="L1241">        }</span>
<span class="fc" id="L1242">        return Tuple.of(new Vector&lt;&gt;(xs), new Vector&lt;&gt;(ys));</span>
    }

    @Override
    public &lt;T1, T2, T3&gt; Tuple3&lt;Vector&lt;T1&gt;, Vector&lt;T2&gt;, Vector&lt;T3&gt;&gt; unzip3(Function&lt;? super T, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L1247">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L1248">        HashArrayMappedTrie&lt;Integer, T1&gt; xs = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L1249">        HashArrayMappedTrie&lt;Integer, T2&gt; ys = HashArrayMappedTrie.empty();</span>
<span class="fc" id="L1250">        HashArrayMappedTrie&lt;Integer, T3&gt; zs = HashArrayMappedTrie.empty();</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">        for (T element : this) {</span>
<span class="fc" id="L1252">            final Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt; t = unzipper.apply(element);</span>
<span class="fc" id="L1253">            xs = xs.put(xs.size(), t._1);</span>
<span class="fc" id="L1254">            ys = ys.put(ys.size(), t._2);</span>
<span class="fc" id="L1255">            zs = zs.put(zs.size(), t._3);</span>
<span class="fc" id="L1256">        }</span>
<span class="fc" id="L1257">        return Tuple.of(new Vector&lt;&gt;(xs), new Vector&lt;&gt;(ys), new Vector&lt;&gt;(zs));</span>
    }

    @Override
    public Vector&lt;T&gt; update(int index, T element) {
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L1263">            throw new IndexOutOfBoundsException(&quot;update(&quot; + index + &quot;)&quot;);</span>
        }
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        if (index &gt;= length()) {</span>
<span class="fc" id="L1266">            throw new IndexOutOfBoundsException(&quot;update(&quot; + index + &quot;)&quot;);</span>
        }
<span class="fc" id="L1268">        return new Vector&lt;&gt;(indexShift, trie.put(index + indexShift, element));</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;Tuple2&lt;T, U&gt;&gt; zip(Iterable&lt;U&gt; that) {
<span class="fc" id="L1273">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L1274">        return Vector.ofAll(iterator().zip(that));</span>
    }

    @Override
    public &lt;U&gt; Vector&lt;Tuple2&lt;T, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, T thisElem, U thatElem) {
<span class="fc" id="L1279">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L1280">        return Vector.ofAll(iterator().zipAll(that, thisElem, thatElem));</span>
    }

    @Override
    public Vector&lt;Tuple2&lt;T, Integer&gt;&gt; zipWithIndex() {
<span class="fc" id="L1285">        return Vector.ofAll(iterator().zipWithIndex());</span>
    }

    private Object readResolve() {
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        return isEmpty() ? EMPTY : this;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        if (o == this) {</span>
<span class="fc" id="L1295">            return true;</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        } else if (o instanceof Vector) {</span>
<span class="fc" id="L1297">            Vector&lt;?&gt; vector1 = this;</span>
<span class="fc" id="L1298">            Vector&lt;?&gt; vector2 = (Vector&lt;?&gt;) o;</span>
<span class="fc bfc" id="L1299" title="All 4 branches covered.">            while (!vector1.isEmpty() &amp;&amp; !vector2.isEmpty()) {</span>
<span class="fc" id="L1300">                final boolean isEqual = Objects.equals(vector1.head(), vector2.head());</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">                if (!isEqual) {</span>
<span class="fc" id="L1302">                    return false;</span>
                }
<span class="fc" id="L1304">                vector1 = vector1.tail();</span>
<span class="fc" id="L1305">                vector2 = vector2.tail();</span>
<span class="fc" id="L1306">            }</span>
<span class="fc bfc" id="L1307" title="All 4 branches covered.">            return vector1.isEmpty() &amp;&amp; vector2.isEmpty();</span>
        } else {
<span class="fc" id="L1309">            return false;</span>
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1315">        return hashCode.get();</span>
    }

    @Override
    public String stringPrefix() {
<span class="fc" id="L1320">        return &quot;Vector&quot;;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L1325">        return mkString(stringPrefix() + &quot;(&quot;, &quot;, &quot;, &quot;)&quot;);</span>
    }

    private static &lt;T&gt; Vector&lt;T&gt; wrap(HashArrayMappedTrie&lt;Integer, T&gt; trie) {
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        return trie.isEmpty() ? empty() : new Vector&lt;&gt;(trie);</span>
    }
}

interface VectorModule {

<span class="nc" id="L1335">    final class Combinations {</span>

        static &lt;T&gt; Vector&lt;Vector&lt;T&gt;&gt; apply(Vector&lt;T&gt; elements, int k) {
<span class="fc bfc" id="L1338" title="All 2 branches covered.">            if (k == 0) {</span>
<span class="fc" id="L1339">                return Vector.of(Vector.empty());</span>
            } else {
<span class="fc" id="L1341">                return elements.zipWithIndex().flatMap(t -&gt; apply(elements.drop(t._2 + 1), (k - 1))</span>
<span class="fc" id="L1342">                        .map((Vector&lt;T&gt; c) -&gt; c.prepend(t._1))</span>
                );
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>