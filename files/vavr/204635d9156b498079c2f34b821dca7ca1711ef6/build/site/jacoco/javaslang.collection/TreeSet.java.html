<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TreeSet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">TreeSet.java</span></div><h1>TreeSet.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.Tuple3;
import javaslang.control.Match;
import javaslang.control.Option;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.*;
import java.util.stream.Collector;

import static javaslang.collection.Comparators.naturalComparator;

/**
 * SortedSet implementation, backed by a Red/Black Tree.
 *
 * @param &lt;T&gt; Component type
 * @author Daniel Dietrich
 * @since 2.0.0
 */
// DEV-NOTE: it is not possible to create an EMPTY TreeSet without a Comparator type in scope
public final class TreeSet&lt;T&gt; implements SortedSet&lt;T&gt;, Serializable {

    private static final long serialVersionUID = 1L;

    private final RedBlackTree&lt;T&gt; tree;

<span class="fc" id="L38">    TreeSet(RedBlackTree&lt;T&gt; tree) {</span>
<span class="fc" id="L39">        this.tree = tree;</span>
<span class="fc" id="L40">    }</span>

    /**
     * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.TreeSet}.
     *
     * @param &lt;T&gt; Component type of the List.
     * @return A javaslang.collection.List Collector.
     */
    public static &lt;T&gt; Collector&lt;T, ArrayList&lt;T&gt;, TreeSet&lt;T&gt;&gt; collector() {
<span class="fc" id="L50">        final Supplier&lt;ArrayList&lt;T&gt;&gt; supplier = ArrayList::new;</span>
<span class="fc" id="L51">        final BiConsumer&lt;ArrayList&lt;T&gt;, T&gt; accumulator = ArrayList::add;</span>
<span class="fc" id="L52">        final BinaryOperator&lt;ArrayList&lt;T&gt;&gt; combiner = (left, right) -&gt; {</span>
<span class="fc" id="L53">            left.addAll(right);</span>
<span class="fc" id="L54">            return left;</span>
        };
<span class="fc" id="L56">        final Function&lt;ArrayList&lt;T&gt;, TreeSet&lt;T&gt;&gt; finisher = list -&gt; TreeSet.ofAll(naturalComparator(), list);</span>
<span class="fc" id="L57">        return Collector.of(supplier, accumulator, combiner, finisher);</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; empty() {
<span class="fc" id="L61">        return new TreeSet&lt;&gt;(RedBlackTree.&lt;T&gt; empty());</span>
    }

    public static &lt;T&gt; TreeSet&lt;T&gt; empty(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L65">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L66">        return new TreeSet&lt;&gt;(RedBlackTree.empty(comparator));</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; of(T value) {
<span class="nc" id="L70">        return new TreeSet&lt;&gt;(RedBlackTree.of(value));</span>
    }

    public static &lt;T&gt; TreeSet&lt;T&gt; of(Comparator&lt;? super T&gt; comparator, T value) {
<span class="fc" id="L74">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L75">        return new TreeSet&lt;&gt;(RedBlackTree.of(comparator, value));</span>
    }

    @SuppressWarnings(&quot;varargs&quot;)
    @SafeVarargs
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; of(T... values) {
<span class="fc" id="L81">        Objects.requireNonNull(values, &quot;values is null&quot;);</span>
<span class="fc" id="L82">        return new TreeSet&lt;&gt;(RedBlackTree.of(values));</span>
    }

    @SuppressWarnings(&quot;varargs&quot;)
    @SafeVarargs
    public static &lt;T&gt; TreeSet&lt;T&gt; of(Comparator&lt;? super T&gt; comparator, T... values) {
<span class="fc" id="L88">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L89">        Objects.requireNonNull(values, &quot;values is null&quot;);</span>
<span class="fc" id="L90">        return new TreeSet&lt;&gt;(RedBlackTree.of(comparator, values));</span>
    }

    /**
     * Returns a TreeSet containing {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     *
     * @param &lt;T&gt;        Component type of the TreeSet
     * @param comparator The comparator used to sort the elements
     * @param n          The number of elements in the TreeSet
     * @param f          The Function computing element values
     * @return A TreeSet consisting of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code comparator} or {@code f} are null
     */
    public static &lt;T&gt; TreeSet&lt;T&gt; tabulate(Comparator&lt;? super T&gt; comparator, int n, Function&lt;? super Integer, ? extends T&gt; f) {
<span class="fc" id="L105">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L106">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L107">        return Collections.tabulate(n, f, TreeSet.empty(comparator), values -&gt; TreeSet.of(comparator, values));</span>
    }

    /**
     * Returns a TreeSet containing {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     * The underlying comparator is the natural comparator of T.
     *
     * @param &lt;T&gt; Component type of the TreeSet
     * @param n   The number of elements in the TreeSet
     * @param f   The Function computing element values
     * @return A TreeSet consisting of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code f} is null
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; tabulate(int n, Function&lt;? super Integer, ? extends T&gt; f) {
<span class="nc" id="L122">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="nc" id="L123">        return tabulate((Comparator&lt;? super T&gt; &amp; Serializable) T::compareTo, n, f);</span>
    }

    /**
     * Returns a TreeSet containing {@code n} values supplied by a given Supplier {@code s}.
     *
     * @param &lt;T&gt;        Component type of the TreeSet
     * @param comparator The comparator used to sort the elements
     * @param n          The number of elements in the TreeSet
     * @param s          The Supplier computing element values
     * @return A TreeSet of size {@code n}, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code comparator} or {@code s} are null
     */
    public static &lt;T&gt; TreeSet&lt;T&gt; fill(Comparator&lt;? super T&gt; comparator, int n, Supplier&lt;? extends T&gt; s) {
<span class="fc" id="L137">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L138">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L139">        return Collections.fill(n, s, TreeSet.empty(comparator), values -&gt; TreeSet.of(comparator, values));</span>
    }

    /**
     * Returns a TreeSet containing {@code n} values supplied by a given Supplier {@code s}.
     * The underlying comparator is the natural comparator of T.
     *
     * @param &lt;T&gt; Component type of the TreeSet
     * @param n   The number of elements in the TreeSet
     * @param s   The Supplier computing element values
     * @return A TreeSet of size {@code n}, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code s} is null
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; fill(int n, Supplier&lt;? extends T&gt; s) {
<span class="nc" id="L153">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="nc" id="L154">        return fill((Comparator&lt;? super T&gt; &amp; Serializable) T::compareTo, n, s);</span>
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; TreeSet&lt;T&gt; ofAll(Iterable&lt;? extends T&gt; values) {
<span class="fc" id="L158">        Objects.requireNonNull(values, &quot;values is null&quot;);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        return values.iterator().hasNext() ? new TreeSet&lt;&gt;(RedBlackTree.ofAll(values)) : empty();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; TreeSet&lt;T&gt; ofAll(Comparator&lt;? super T&gt; comparator, Iterable&lt;? extends T&gt; values) {
<span class="fc" id="L164">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L165">        Objects.requireNonNull(values, &quot;values is null&quot;);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        return values.iterator().hasNext()</span>
<span class="fc" id="L167">                ? new TreeSet&lt;&gt;(RedBlackTree.ofAll(comparator, values))</span>
<span class="fc" id="L168">                : (TreeSet&lt;T&gt;) empty();</span>
    }

    /**
     * Creates a TreeSet based on the elements of a boolean array.
     *
     * @param array a boolean array
     * @return A new TreeSet of Boolean values
     */
    public static TreeSet&lt;Boolean&gt; ofAll(boolean[] array) {
<span class="fc" id="L178">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L179">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a byte array.
     *
     * @param array a byte array
     * @return A new TreeSet of Byte values
     */
    public static TreeSet&lt;Byte&gt; ofAll(byte[] array) {
<span class="fc" id="L189">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L190">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a char array.
     *
     * @param array a char array
     * @return A new TreeSet of Character values
     */
    public static TreeSet&lt;Character&gt; ofAll(char[] array) {
<span class="fc" id="L200">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L201">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a double array.
     *
     * @param array a double array
     * @return A new TreeSet of Double values
     */
    public static TreeSet&lt;Double&gt; ofAll(double[] array) {
<span class="fc" id="L211">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L212">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a float array.
     *
     * @param array a float array
     * @return A new TreeSet of Float values
     */
    public static TreeSet&lt;Float&gt; ofAll(float[] array) {
<span class="fc" id="L222">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L223">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of an int array.
     *
     * @param array an int array
     * @return A new TreeSet of Integer values
     */
    public static TreeSet&lt;Integer&gt; ofAll(int[] array) {
<span class="fc" id="L233">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L234">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a long array.
     *
     * @param array a long array
     * @return A new TreeSet of Long values
     */
    public static TreeSet&lt;Long&gt; ofAll(long[] array) {
<span class="fc" id="L244">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L245">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet based on the elements of a short array.
     *
     * @param array a short array
     * @return A new TreeSet of Short values
     */
    public static TreeSet&lt;Short&gt; ofAll(short[] array) {
<span class="fc" id="L255">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L256">        return TreeSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a TreeSet of int numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.range(0, 0)  // = TreeSet()
     * TreeSet.range(2, 0)  // = TreeSet()
     * TreeSet.range(-2, 2) // = TreeSet(-2, -1, 0, 1)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of int values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static TreeSet&lt;Integer&gt; range(int from, int toExclusive) {
<span class="fc" id="L276">        return TreeSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    public static TreeSet&lt;Character&gt; range(char from, char toExclusive) {
<span class="fc" id="L280">        return TreeSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a TreeSet of int numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeBy(1, 3, 1)  // = TreeSet(1, 2)
     * TreeSet.rangeBy(1, 4, 2)  // = TreeSet(1, 3)
     * TreeSet.rangeBy(4, 1, -2) // = TreeSet(4, 2)
     * TreeSet.rangeBy(4, 1, 2)  // = TreeSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static TreeSet&lt;Integer&gt; rangeBy(int from, int toExclusive, int step) {
<span class="fc" id="L306">        return TreeSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static TreeSet&lt;Character&gt; rangeBy(char from, char toExclusive, int step) {
<span class="fc" id="L310">        return TreeSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static TreeSet&lt;Double&gt; rangeBy(double from, double toExclusive, double step) {
<span class="fc" id="L314">        return TreeSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a TreeSet of long numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.range(0L, 0L)  // = TreeSet()
     * TreeSet.range(2L, 0L)  // = TreeSet()
     * TreeSet.range(-2L, 2L) // = TreeSet(-2L, -1L, 0L, 1L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of long values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static TreeSet&lt;Long&gt; range(long from, long toExclusive) {
<span class="fc" id="L334">        return TreeSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a TreeSet of long numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeBy(1L, 3L, 1L)  // = TreeSet(1L, 2L)
     * TreeSet.rangeBy(1L, 4L, 2L)  // = TreeSet(1L, 3L)
     * TreeSet.rangeBy(4L, 1L, -2L) // = TreeSet(4L, 2L)
     * TreeSet.rangeBy(4L, 1L, 2L)  // = TreeSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static TreeSet&lt;Long&gt; rangeBy(long from, long toExclusive, long step) {
<span class="fc" id="L360">        return TreeSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a TreeSet of int numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeClosed(0, 0)  // = TreeSet(0)
     * TreeSet.rangeClosed(2, 0)  // = TreeSet()
     * TreeSet.rangeClosed(-2, 2) // = TreeSet(-2, -1, 0, 1, 2)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of int values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static TreeSet&lt;Integer&gt; rangeClosed(int from, int toInclusive) {
<span class="fc" id="L380">        return TreeSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    public static TreeSet&lt;Character&gt; rangeClosed(char from, char toInclusive) {
<span class="fc" id="L384">        return TreeSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a TreeSet of int numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeClosedBy(1, 3, 1)  // = TreeSet(1, 2, 3)
     * TreeSet.rangeClosedBy(1, 4, 2)  // = TreeSet(1, 3)
     * TreeSet.rangeClosedBy(4, 1, -2) // = TreeSet(4, 2)
     * TreeSet.rangeClosedBy(4, 1, 2)  // = TreeSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static TreeSet&lt;Integer&gt; rangeClosedBy(int from, int toInclusive, int step) {
<span class="fc" id="L410">        return TreeSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    public static TreeSet&lt;Character&gt; rangeClosedBy(char from, char toInclusive, int step) {
<span class="fc" id="L414">        return TreeSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    public static TreeSet&lt;Double&gt; rangeClosedBy(double from, double toInclusive, double step) {
<span class="fc" id="L418">        return TreeSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    /**
     * Creates a TreeSet of long numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeClosed(0L, 0L)  // = TreeSet(0L)
     * TreeSet.rangeClosed(2L, 0L)  // = TreeSet()
     * TreeSet.rangeClosed(-2L, 2L) // = TreeSet(-2L, -1L, 0L, 1L, 2L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of long values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static TreeSet&lt;Long&gt; rangeClosed(long from, long toInclusive) {
<span class="fc" id="L438">        return TreeSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a TreeSet of long numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * TreeSet.rangeClosedBy(1L, 3L, 1L)  // = TreeSet(1L, 2L, 3L)
     * TreeSet.rangeClosedBy(1L, 4L, 2L)  // = TreeSet(1L, 3L)
     * TreeSet.rangeClosedBy(4L, 1L, -2L) // = TreeSet(4L, 2L)
     * TreeSet.rangeClosedBy(4L, 1L, 2L)  // = TreeSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static TreeSet&lt;Long&gt; rangeClosedBy(long from, long toInclusive, long step) {
<span class="fc" id="L464">        return TreeSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    @Override
    public TreeSet&lt;T&gt; add(T element) {
<span class="fc" id="L469">        return new TreeSet&lt;&gt;(tree.insert(element));</span>
    }

    @Override
    public TreeSet&lt;T&gt; addAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L474">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L475">        RedBlackTree&lt;T&gt; that = tree;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L477">            that = that.insert(element);</span>
<span class="fc" id="L478">        }</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (tree == that) {</span>
<span class="fc" id="L480">            return this;</span>
        } else {
<span class="fc" id="L482">            return new TreeSet&lt;&gt;(that);</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; clear() {
<span class="fc bfc" id="L488" title="All 2 branches covered.">        return isEmpty() ? this : new TreeSet&lt;&gt;(tree.clear());</span>
    }

    @Override
    public Comparator&lt;T&gt; comparator() {
<span class="fc" id="L493">        return tree.comparator();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public TreeSet&lt;T&gt; diff(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L499">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if (elements instanceof TreeSet) {</span>
<span class="fc" id="L501">            final RedBlackTree&lt;T&gt; that = ((TreeSet&lt;T&gt;) elements).tree;</span>
<span class="fc" id="L502">            return new TreeSet&lt;&gt;(tree.difference(that));</span>
        } else {
<span class="nc" id="L504">            return removeAll(elements);</span>
        }
    }

    @Override
    public boolean contains(T element) {
<span class="fc" id="L510">        return tree.contains(element);</span>
    }

    @Override
    public TreeSet&lt;T&gt; distinct() {
<span class="fc" id="L515">        return this;</span>
    }

    @Override
    public TreeSet&lt;T&gt; distinctBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L520">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L521">        return TreeSet.ofAll(tree.comparator(), iterator().distinctBy(comparator));</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;T&gt; distinctBy(Function&lt;? super T, ? extends U&gt; keyExtractor) {
<span class="fc" id="L526">        Objects.requireNonNull(keyExtractor, &quot;keyExtractor is null&quot;);</span>
<span class="fc" id="L527">        return TreeSet.ofAll(tree.comparator(), iterator().distinctBy(keyExtractor));</span>
    }

    @Override
    public TreeSet&lt;T&gt; drop(int n) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L533">            return this;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        } else if (n &gt;= length()) {</span>
<span class="fc" id="L535">            return empty(tree.comparator());</span>
        } else {
<span class="fc" id="L537">            return TreeSet.ofAll(tree.comparator(), iterator().drop(n));</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; dropRight(int n) {
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L544">            return this;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        } else if (n &gt;= length()) {</span>
<span class="fc" id="L546">            return empty(tree.comparator());</span>
        } else {
<span class="fc" id="L548">            return TreeSet.ofAll(tree.comparator(), iterator().dropRight(n));</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; dropUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L554">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L555">        return dropWhile(predicate.negate());</span>
    }

    @Override
    public TreeSet&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L560">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L561">        final TreeSet&lt;T&gt; treeSet = TreeSet.ofAll(tree.comparator(), iterator().dropWhile(predicate));</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        return (treeSet.length() == length()) ? this : treeSet;</span>
    }

    @Override
    public TreeSet&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L567">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L568">        final TreeSet&lt;T&gt; treeSet = TreeSet.ofAll(tree.comparator(), iterator().filter(predicate));</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        return (treeSet.length() == length()) ? this : treeSet;</span>
    }

    @Override
    public TreeSet&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L574">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L575">        return filter(predicate.negate());</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;U&gt; flatMap(Comparator&lt;? super U&gt; comparator,
                                  Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="nc" id="L581">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="nc" id="L582">        return TreeSet.ofAll(comparator, iterator().flatMap(mapper));</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="nc" id="L587">        return flatMap(naturalComparator(), mapper);</span>
    }

    @Override
    public &lt;U&gt; U foldRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; f) {
<span class="fc" id="L592">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L593">        return iterator().foldRight(zero, f);</span>
    }

    @Override
    public &lt;C&gt; Map&lt;C, TreeSet&lt;T&gt;&gt; groupBy(Function&lt;? super T, ? extends C&gt; classifier) {
<span class="fc" id="L598">        Objects.requireNonNull(classifier, &quot;classifier is null&quot;);</span>
<span class="fc" id="L599">        return iterator().groupBy(classifier).map(</span>
<span class="fc" id="L600">                (key, iterator) -&gt; Tuple.of(key, TreeSet.ofAll(tree.comparator(), iterator)));</span>
    }

    @Override
    public Iterator&lt;TreeSet&lt;T&gt;&gt; grouped(int size) {
<span class="fc" id="L605">        return sliding(size, size);</span>
    }

    @Override
    public boolean hasDefiniteSize() {
<span class="fc" id="L610">        return true;</span>
    }

    @Override
    public T head() {
<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L616">            throw new NoSuchElementException(&quot;head of empty TreeSet&quot;);</span>
        } else {
<span class="fc" id="L618">            return tree.min().get();</span>
        }
    }

    @Override
    public Option&lt;T&gt; headOption() {
<span class="fc" id="L624">        return tree.min();</span>
    }

    @Override
    public TreeSet&lt;T&gt; init() {
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L630">            throw new UnsupportedOperationException(&quot;init of empty TreeSet&quot;);</span>
        } else {
<span class="fc" id="L632">            return new TreeSet&lt;&gt;(tree.delete(tree.max().get()));</span>
        }
    }

    @Override
    public Option&lt;TreeSet&lt;T&gt;&gt; initOption() {
<span class="fc bfc" id="L638" title="All 2 branches covered.">        return isEmpty() ? Option.none() : Option.some(init());</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public TreeSet&lt;T&gt; intersect(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L644">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (elements instanceof TreeSet) {</span>
<span class="fc" id="L646">            final RedBlackTree&lt;T&gt; that = ((TreeSet&lt;T&gt;) elements).tree;</span>
<span class="fc" id="L647">            return new TreeSet&lt;&gt;(tree.intersection(that));</span>
        } else {
<span class="nc" id="L649">            return retainAll(elements);</span>
        }
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L655">        return tree.isEmpty();</span>
    }

    @Override
    public boolean isTraversableAgain() {
<span class="fc" id="L660">        return true;</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L665">        return tree.iterator();</span>
    }

    @Override
    public int length() {
<span class="fc" id="L670">        return tree.size();</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;U&gt; map(Comparator&lt;? super U&gt; comparator, Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L675">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L676">        return TreeSet.ofAll(comparator, iterator().map(mapper));</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L681">        return map(naturalComparator(), mapper);</span>
    }

    @Override
    public Match.MatchMonad.Of&lt;TreeSet&lt;T&gt;&gt; match() {
<span class="fc" id="L686">        return Match.of(this);</span>
    }

    @Override
    public Option&lt;T&gt; max() {
<span class="fc" id="L691">        return tree.max();</span>
    }

    @Override
    public Option&lt;T&gt; min() {
<span class="fc" id="L696">        return tree.min();</span>
    }

    @Override
    public Tuple2&lt;TreeSet&lt;T&gt;, TreeSet&lt;T&gt;&gt; partition(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L701">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L702">        return iterator().partition(predicate).map(i1 -&gt; TreeSet.ofAll(tree.comparator(), i1),</span>
<span class="fc" id="L703">                i2 -&gt; TreeSet.ofAll(tree.comparator(), i2));</span>
    }

    @Override
    public TreeSet&lt;T&gt; peek(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L708">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (!isEmpty()) {</span>
<span class="fc" id="L710">            action.accept(head());</span>
        }
<span class="fc" id="L712">        return this;</span>
    }

    @Override
    public TreeSet&lt;T&gt; remove(T element) {
<span class="fc" id="L717">        return new TreeSet&lt;&gt;(tree.delete(element));</span>
    }

    @Override
    public TreeSet&lt;T&gt; removeAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L722">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L724">            return this;</span>
        } else {
<span class="fc" id="L726">            RedBlackTree&lt;T&gt; that = tree;</span>
<span class="fc" id="L727">            final java.util.Iterator&lt;? extends T&gt; iter = elements.iterator();</span>
<span class="pc bpc" id="L728" title="1 of 4 branches missed.">            while (!that.isEmpty() &amp;&amp; iter.hasNext()) {</span>
<span class="fc" id="L729">                that = that.delete(iter.next());</span>
            }
<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (that == tree) {</span>
<span class="fc" id="L732">                return this;</span>
            } else {
<span class="fc" id="L734">                return new TreeSet&lt;&gt;(that);</span>
            }
        }
    }

    @Override
    public TreeSet&lt;T&gt; replace(T currentElement, T newElement) {
<span class="fc bfc" id="L741" title="All 2 branches covered.">        if (tree.contains(currentElement)) {</span>
<span class="fc" id="L742">            return new TreeSet&lt;&gt;(tree.delete(currentElement).insert(newElement));</span>
        } else {
<span class="fc" id="L744">            return this;</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; replaceAll(T currentElement, T newElement) {
        // a set has only one occurrence
<span class="fc" id="L751">        return replace(currentElement, newElement);</span>
    }

    @Override
    public TreeSet&lt;T&gt; retainAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L756">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L758">            return this;</span>
        } else {
<span class="fc" id="L760">            final RedBlackTree&lt;T&gt; kept = RedBlackTree.ofAll(tree.comparator(), elements);</span>
<span class="fc" id="L761">            final RedBlackTree&lt;T&gt; newTree = tree.intersection(kept);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            return newTree.size() == tree.size() ? this : new TreeSet&lt;&gt;(tree.intersection(kept));</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; scan(T zero, BiFunction&lt;? super T, ? super T, ? extends T&gt; operation) {
<span class="fc" id="L768">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L769">        return Collections.scanLeft(this, zero, operation, TreeSet.empty(comparator()), TreeSet::add, Function.identity());</span>
    }

    @Override
    public &lt;U&gt; Set&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; operation) {
<span class="fc" id="L774">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (zero instanceof Comparable) {</span>
<span class="fc" id="L776">            final Comparator&lt;U&gt; comparator = naturalComparator();</span>
<span class="fc" id="L777">            return Collections.scanLeft(this, zero, operation, TreeSet.empty(comparator), TreeSet::add, Function.identity());</span>
        } else {
<span class="fc" id="L779">            return Collections.scanLeft(this, zero, operation, new java.util.ArrayList&lt;&gt;(), (c, u) -&gt; {</span>
<span class="fc" id="L780">                c.add(u);</span>
<span class="fc" id="L781">                return c;</span>
            }, HashSet::ofAll);
        }
    }

    @Override
    public &lt;U&gt; Set&lt;U&gt; scanRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; operation) {
<span class="fc" id="L788">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (zero instanceof Comparable) {</span>
<span class="fc" id="L790">            final Comparator&lt;U&gt; comparator = naturalComparator();</span>
<span class="fc" id="L791">            return Collections.scanRight(this, zero, operation, TreeSet.empty(comparator), TreeSet::add, Function.identity());</span>
        } else {
<span class="fc" id="L793">            return Collections.scanRight(this, zero, operation, new java.util.ArrayList&lt;&gt;(), (c, u) -&gt; {</span>
<span class="fc" id="L794">                c.add(u);</span>
<span class="fc" id="L795">                return c;</span>
            }, HashSet::ofAll);
        }
    }

    @Override
    public Iterator&lt;TreeSet&lt;T&gt;&gt; sliding(int size) {
<span class="fc" id="L802">        return sliding(size, 1);</span>
    }

    @Override
    public Iterator&lt;TreeSet&lt;T&gt;&gt; sliding(int size, int step) {
<span class="fc" id="L807">        return iterator().sliding(size, step).map(seq -&gt; TreeSet.ofAll(tree.comparator(), seq));</span>
    }

    @Override
    public Tuple2&lt;TreeSet&lt;T&gt;, TreeSet&lt;T&gt;&gt; span(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L812">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L813">        return iterator().span(predicate).map(i1 -&gt; TreeSet.ofAll(tree.comparator(), i1),</span>
<span class="fc" id="L814">                i2 -&gt; TreeSet.ofAll(tree.comparator(), i2));</span>
    }

    @Override
    public TreeSet&lt;T&gt; tail() {
<span class="fc bfc" id="L819" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L820">            throw new UnsupportedOperationException(&quot;tail of empty TreeSet&quot;);</span>
        } else {
<span class="fc" id="L822">            return new TreeSet&lt;&gt;(tree.delete(tree.min().get()));</span>
        }
    }

    @Override
    public Option&lt;TreeSet&lt;T&gt;&gt; tailOption() {
<span class="fc bfc" id="L828" title="All 2 branches covered.">        return isEmpty() ? Option.none() : Option.some(tail());</span>
    }

    @Override
    public TreeSet&lt;T&gt; take(int n) {
<span class="fc bfc" id="L833" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L834">            return empty(tree.comparator());</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">        } else if (n &gt;= length()) {</span>
<span class="fc" id="L836">            return this;</span>
        } else {
<span class="fc" id="L838">            return TreeSet.ofAll(tree.comparator(), iterator().take(n));</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; takeRight(int n) {
<span class="fc bfc" id="L844" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L845">            return empty(tree.comparator());</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">        } else if (n &gt;= length()) {</span>
<span class="fc" id="L847">            return this;</span>
        } else {
<span class="fc" id="L849">            return TreeSet.ofAll(tree.comparator(), iterator().takeRight(n));</span>
        }
    }

    @Override
    public TreeSet&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L855">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L856">        final TreeSet&lt;T&gt; treeSet = takeWhile(predicate.negate());</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        return (treeSet.length() == length()) ? this : treeSet;</span>
    }

    @Override
    public TreeSet&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L862">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L863">        final TreeSet&lt;T&gt; treeSet = TreeSet.ofAll(tree.comparator(), iterator().takeWhile(predicate));</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        return (treeSet.length() == length()) ? this : treeSet;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public TreeSet&lt;T&gt; union(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L870">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">        if (elements instanceof TreeSet) {</span>
<span class="fc" id="L872">            final RedBlackTree&lt;T&gt; that = ((TreeSet&lt;T&gt;) elements).tree;</span>
<span class="fc" id="L873">            return new TreeSet&lt;&gt;(tree.union(that));</span>
        } else {
<span class="nc" id="L875">            return addAll(elements);</span>
        }
    }
    
    @Override
    public &lt;U&gt; TreeSet&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="nc" id="L881">    	return TreeSet.ofAll(naturalComparator(), iterable);</span>
    }

    @Override
    public &lt;T1, T2&gt; Tuple2&lt;TreeSet&lt;T1&gt;, TreeSet&lt;T2&gt;&gt; unzip(
            Function&lt;? super T, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L887">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L888">        return iterator().unzip(unzipper).map(i1 -&gt; TreeSet.ofAll(naturalComparator(), i1),</span>
<span class="fc" id="L889">                i2 -&gt; TreeSet.ofAll(naturalComparator(), i2));</span>
    }

    @Override
    public &lt;T1, T2, T3&gt; Tuple3&lt;TreeSet&lt;T1&gt;, TreeSet&lt;T2&gt;, TreeSet&lt;T3&gt;&gt; unzip3(
            Function&lt;? super T, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L895">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L896">        return iterator().unzip3(unzipper).map(</span>
<span class="fc" id="L897">                i1 -&gt; TreeSet.ofAll(naturalComparator(), i1),</span>
<span class="fc" id="L898">                i2 -&gt; TreeSet.ofAll(naturalComparator(), i2),</span>
<span class="fc" id="L899">                i3 -&gt; TreeSet.ofAll(naturalComparator(), i3));</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;Tuple2&lt;T, U&gt;&gt; zip(Iterable&lt;U&gt; that) {
<span class="fc" id="L904">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L905">        final Comparator&lt;Tuple2&lt;T, U&gt;&gt; tuple2Comparator = Tuple2.comparator(tree.comparator(), naturalComparator());</span>
<span class="fc" id="L906">        return TreeSet.ofAll(tuple2Comparator, iterator().zip(that));</span>
    }

    @Override
    public &lt;U&gt; TreeSet&lt;Tuple2&lt;T, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, T thisElem, U thatElem) {
<span class="fc" id="L911">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L912">        final Comparator&lt;Tuple2&lt;T, U&gt;&gt; tuple2Comparator = Tuple2.comparator(tree.comparator(), naturalComparator());</span>
<span class="fc" id="L913">        return TreeSet.ofAll(tuple2Comparator, iterator().zipAll(that, thisElem, thatElem));</span>
    }

    @Override
    public TreeSet&lt;Tuple2&lt;T, Integer&gt;&gt; zipWithIndex() {
<span class="fc" id="L918">        final Comparator&lt;? super T&gt; component1Comparator = tree.comparator();</span>
<span class="fc" id="L919">        final Comparator&lt;Tuple2&lt;T, Integer&gt;&gt; tuple2Comparator = (t1, t2) -&gt; component1Comparator.compare(t1._1, t2._1);</span>
<span class="fc" id="L920">        return TreeSet.ofAll(tuple2Comparator, iterator().zipWithIndex());</span>
    }

    // -- Object

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (o == this) {</span>
<span class="fc" id="L928">            return true;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        } else if (o instanceof TreeSet) {</span>
<span class="fc" id="L930">            final TreeSet&lt;?&gt; that = (TreeSet&lt;?&gt;) o;</span>
<span class="fc" id="L931">            return tree.equals(that.tree);</span>
        } else {
<span class="fc" id="L933">            return false;</span>
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L939">        return tree.hashCode();</span>
    }

    @Override
    public String stringPrefix() {
<span class="fc" id="L944">        return &quot;TreeSet&quot;;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L949">        return mkString(stringPrefix() + &quot;(&quot;, &quot;, &quot;, &quot;)&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>