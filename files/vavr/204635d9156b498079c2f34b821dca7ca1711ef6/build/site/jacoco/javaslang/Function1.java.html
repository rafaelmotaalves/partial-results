<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Function1.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang</a> &gt; <span class="el_source">Function1.java</span></div><h1>Function1.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import javaslang.control.Option;
import javaslang.control.Try;

/**
 * Represents a function with one argument.
 *
 * @param &lt;T1&gt; argument 1 of the function
 * @param &lt;R&gt; return type of the function
 * @author Daniel Dietrich
 * @since 1.1.0
 */
@FunctionalInterface
public interface Function1&lt;T1, R&gt; extends 位&lt;R&gt;, Function&lt;T1, R&gt; {

    /**
     * The &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/index.html&quot;&gt;serial version uid&lt;/a&gt;.
     */
    long serialVersionUID = 1L;

    /**
     * Creates a {@code Function1} based on
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&quot;&gt;method reference&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax&quot;&gt;lambda expression&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * Examples (w.l.o.g. referring to Function1):
     * &lt;pre&gt;&lt;code&gt;// using a lambda expression
     * Function1&amp;lt;Integer, Integer&amp;gt; add1 = Function1.of(i -&amp;gt; i + 1);
     *
     * // using a method reference (, e.g. Integer method(Integer i) { return i + 1; })
     * Function1&amp;lt;Integer, Integer&amp;gt; add2 = Function1.of(this::method);
     *
     * // using a lambda reference
     * Function1&amp;lt;Integer, Integer&amp;gt; add3 = Function1.of(add1::apply);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Caution:&lt;/strong&gt; Reflection loses type information of lambda references.
     * &lt;pre&gt;&lt;code&gt;// type of a lambda expression
     * Type&amp;lt;?, ?&amp;gt; type1 = add1.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a method reference
     * Type&amp;lt;?, ?&amp;gt; type2 = add2.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a lambda reference
     * Type&amp;lt;?, ?&amp;gt; type3 = add3.getType(); // (Object) -&amp;gt; Object
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param methodReference (typically) a method reference, e.g. {@code Type::method}
     * @param &lt;R&gt; return type
     * @param &lt;T1&gt; 1st argument
     * @return a {@code Function1}
     */
    static &lt;T1, R&gt; Function1&lt;T1, R&gt; of(Function1&lt;T1, R&gt; methodReference) {
<span class="fc" id="L70">        return methodReference;</span>
    }

    /**
     * Lifts the given {@code partialFunction} into a total function that returns an {@code Option} result.
     *
     * @param partialFunction a function that is not defined for all values of the domain (e.g. by throwing)
     * @param &lt;R&gt; return type
     * @param &lt;T1&gt; 1st argument
     * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Some(result)}
     *         if the function is defined for the given arguments, and {@code None} otherwise.
     */
    static &lt;T1, R&gt; Function1&lt;T1, Option&lt;R&gt;&gt; lift(Function1&lt;T1, R&gt; partialFunction) {
<span class="pc" id="L83">        return (t1) -&gt; Try.of(() -&gt; partialFunction.apply(t1)).getOption();</span>
    }

    /**
     * Returns the identity Function1, i.e. the function that returns its input.
     *
     * @param &lt;T&gt; argument type (and return type) of the identity function
     * @return the identity Function1
     */
    static &lt;T&gt; Function1&lt;T, T&gt; identity() {
<span class="fc" id="L93">        return t -&gt; t;</span>
    }

    /**
     * Applies this function to one argument and returns the result.
     *
     * @param t1 argument 1
     * @return the result of function application
     * 
     */
    R apply(T1 t1);

    @Override
    default int arity() {
<span class="fc" id="L107">        return 1;</span>
    }

    @Override
    default Function1&lt;T1, R&gt; curried() {
<span class="fc" id="L112">        return this;</span>
    }

    @Override
    default Function1&lt;Tuple1&lt;T1&gt;, R&gt; tupled() {
<span class="pc" id="L117">        return t -&gt; apply(t._1);</span>
    }

    @Override
    default Function1&lt;T1, R&gt; reversed() {
<span class="fc" id="L122">        return this;</span>
    }

    @Override
    default Function1&lt;T1, R&gt; memoized() {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (isMemoized()) {</span>
<span class="fc" id="L128">            return this;</span>
        } else {
<span class="fc" id="L130">            final Lazy&lt;R&gt; forNull = Lazy.of(() -&gt; apply(null));</span>
<span class="fc" id="L131">            final Object lock = new Object();</span>
<span class="fc" id="L132">            final Map&lt;T1, R&gt; cache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L133">            return (Function1&lt;T1, R&gt; &amp; Memoized) t1 -&gt; {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                if (t1 == null) {</span>
<span class="fc" id="L135">                    return forNull.get();</span>
                } else {
                    final R result;
<span class="fc" id="L138">                    synchronized (lock) {</span>
<span class="fc" id="L139">                        result = cache.computeIfAbsent(t1, this::apply);</span>
<span class="pc" id="L140">                    }</span>
<span class="fc" id="L141">                    return result;</span>
                }
            };
        }
    }

    /**
     * Returns a composed function that first applies this Function1 to the given argument and then applies
     * {@linkplain Function} {@code after} to the result.
     *
     * @param &lt;V&gt; return type of after
     * @param after the function applied after this
     * @return a function composed of this and after
     * @throws NullPointerException if after is null
     */
    default &lt;V&gt; Function1&lt;T1, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
<span class="fc" id="L157">        Objects.requireNonNull(after, &quot;after is null&quot;);</span>
<span class="pc" id="L158">        return (t1) -&gt; after.apply(apply(t1));</span>
    }

    /**
     * Returns a composed function that first applies the {@linkplain Function} {@code before} the
     * given argument and then applies this Function1 to the result.
     *
     * @param &lt;V&gt; argument type of before
     * @param before the function applied before this
     * @return a function composed of before and this
     * @throws NullPointerException if before is null
     */
    default &lt;V&gt; Function1&lt;V, R&gt; compose(Function&lt;? super V, ? extends T1&gt; before) {
<span class="fc" id="L171">        Objects.requireNonNull(before, &quot;before is null&quot;);</span>
<span class="pc" id="L172">        return v -&gt; apply(before.apply(v));</span>
    }

    @Override
    default Type&lt;T1, R&gt; getType() {
<span class="fc" id="L177">        return new Type&lt;&gt;(this);</span>
    }

    /**
     * Represents the type of a {@code Function1} which consists of one parameter type
     * and a return type.
     *
     *
     * @param &lt;T1&gt; the 1st parameter type of the function
     * @param &lt;R&gt; the return type of the function
     * @author Daniel Dietrich
     * @since 2.0.0
     */
    final class Type&lt;T1, R&gt; extends 位.Type&lt;R&gt; {

        private static final long serialVersionUID = 1L;

        private Type(Function1&lt;T1, R&gt; 位) {
<span class="fc" id="L195">            super(位);</span>
<span class="fc" id="L196">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        public Class&lt;T1&gt; parameterType1() {
<span class="fc" id="L200">            return (Class&lt;T1&gt;) parameterTypes()[0];</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>