<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Function4.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang</a> &gt; <span class="el_source">Function4.java</span></div><h1>Function4.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import javaslang.control.Option;
import javaslang.control.Try;

/**
 * Represents a function with 4 arguments.
 *
 * @param &lt;T1&gt; argument 1 of the function
 * @param &lt;T2&gt; argument 2 of the function
 * @param &lt;T3&gt; argument 3 of the function
 * @param &lt;T4&gt; argument 4 of the function
 * @param &lt;R&gt; return type of the function
 * @author Daniel Dietrich
 * @since 1.1.0
 */
@FunctionalInterface
public interface Function4&lt;T1, T2, T3, T4, R&gt; extends λ&lt;R&gt; {

    /**
     * The &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/index.html&quot;&gt;serial version uid&lt;/a&gt;.
     */
    long serialVersionUID = 1L;

    /**
     * Creates a {@code Function4} based on
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&quot;&gt;method reference&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax&quot;&gt;lambda expression&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * Examples (w.l.o.g. referring to Function1):
     * &lt;pre&gt;&lt;code&gt;// using a lambda expression
     * Function1&amp;lt;Integer, Integer&amp;gt; add1 = Function1.of(i -&amp;gt; i + 1);
     *
     * // using a method reference (, e.g. Integer method(Integer i) { return i + 1; })
     * Function1&amp;lt;Integer, Integer&amp;gt; add2 = Function1.of(this::method);
     *
     * // using a lambda reference
     * Function1&amp;lt;Integer, Integer&amp;gt; add3 = Function1.of(add1::apply);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Caution:&lt;/strong&gt; Reflection loses type information of lambda references.
     * &lt;pre&gt;&lt;code&gt;// type of a lambda expression
     * Type&amp;lt;?, ?&amp;gt; type1 = add1.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a method reference
     * Type&amp;lt;?, ?&amp;gt; type2 = add2.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a lambda reference
     * Type&amp;lt;?, ?&amp;gt; type3 = add3.getType(); // (Object) -&amp;gt; Object
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param methodReference (typically) a method reference, e.g. {@code Type::method}
     * @param &lt;R&gt; return type
     * @param &lt;T1&gt; 1st argument
     * @param &lt;T2&gt; 2nd argument
     * @param &lt;T3&gt; 3rd argument
     * @param &lt;T4&gt; 4th argument
     * @return a {@code Function4}
     */
    static &lt;T1, T2, T3, T4, R&gt; Function4&lt;T1, T2, T3, T4, R&gt; of(Function4&lt;T1, T2, T3, T4, R&gt; methodReference) {
<span class="fc" id="L76">        return methodReference;</span>
    }

    /**
     * Lifts the given {@code partialFunction} into a total function that returns an {@code Option} result.
     *
     * @param partialFunction a function that is not defined for all values of the domain (e.g. by throwing)
     * @param &lt;R&gt; return type
     * @param &lt;T1&gt; 1st argument
     * @param &lt;T2&gt; 2nd argument
     * @param &lt;T3&gt; 3rd argument
     * @param &lt;T4&gt; 4th argument
     * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Some(result)}
     *         if the function is defined for the given arguments, and {@code None} otherwise.
     */
    static &lt;T1, T2, T3, T4, R&gt; Function4&lt;T1, T2, T3, T4, Option&lt;R&gt;&gt; lift(Function4&lt;T1, T2, T3, T4, R&gt; partialFunction) {
<span class="pc" id="L92">        return (t1, t2, t3, t4) -&gt; Try.of(() -&gt; partialFunction.apply(t1, t2, t3, t4)).getOption();</span>
    }

    /**
     * Applies this function to 4 arguments and returns the result.
     *
     * @param t1 argument 1
     * @param t2 argument 2
     * @param t3 argument 3
     * @param t4 argument 4
     * @return the result of function application
     * 
     */
    R apply(T1 t1, T2 t2, T3 t3, T4 t4);

    /**
     * Applies this function partially to one argument.
     *
     * @param t1 argument 1
     * @return a partial application of this function
     * 
     */
    default Function3&lt;T2, T3, T4, R&gt; apply(T1 t1) {
<span class="pc" id="L115">        return (T2 t2, T3 t3, T4 t4) -&gt; apply(t1, t2, t3, t4);</span>
    }

    /**
     * Applies this function partially to two arguments.
     *
     * @param t1 argument 1
     * @param t2 argument 2
     * @return a partial application of this function
     * 
     */
    default Function2&lt;T3, T4, R&gt; apply(T1 t1, T2 t2) {
<span class="pc" id="L127">        return (T3 t3, T4 t4) -&gt; apply(t1, t2, t3, t4);</span>
    }

    /**
     * Applies this function partially to three arguments.
     *
     * @param t1 argument 1
     * @param t2 argument 2
     * @param t3 argument 3
     * @return a partial application of this function
     * 
     */
    default Function1&lt;T4, R&gt; apply(T1 t1, T2 t2, T3 t3) {
<span class="pc" id="L140">        return (T4 t4) -&gt; apply(t1, t2, t3, t4);</span>
    }

    @Override
    default int arity() {
<span class="fc" id="L145">        return 4;</span>
    }

    @Override
    default Function1&lt;T1, Function1&lt;T2, Function1&lt;T3, Function1&lt;T4, R&gt;&gt;&gt;&gt; curried() {
<span class="fc" id="L150">        return t1 -&gt; t2 -&gt; t3 -&gt; t4 -&gt; apply(t1, t2, t3, t4);</span>
    }

    @Override
    default Function1&lt;Tuple4&lt;T1, T2, T3, T4&gt;, R&gt; tupled() {
<span class="fc" id="L155">        return t -&gt; apply(t._1, t._2, t._3, t._4);</span>
    }

    @Override
    default Function4&lt;T4, T3, T2, T1, R&gt; reversed() {
<span class="pc" id="L160">        return (t4, t3, t2, t1) -&gt; apply(t1, t2, t3, t4);</span>
    }

    @Override
    default Function4&lt;T1, T2, T3, T4, R&gt; memoized() {
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (isMemoized()) {</span>
<span class="fc" id="L166">            return this;</span>
        } else {
<span class="fc" id="L168">            final Object lock = new Object();</span>
<span class="fc" id="L169">            final Map&lt;Tuple4&lt;T1, T2, T3, T4&gt;, R&gt; cache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L170">            final Function1&lt;Tuple4&lt;T1, T2, T3, T4&gt;, R&gt; tupled = tupled();</span>
<span class="fc" id="L171">            return (Function4&lt;T1, T2, T3, T4, R&gt; &amp; Memoized) (t1, t2, t3, t4) -&gt; {</span>
                final R result;
<span class="fc" id="L173">                synchronized (lock) {</span>
<span class="fc" id="L174">                    result = cache.computeIfAbsent(Tuple.of(t1, t2, t3, t4), tupled::apply);</span>
<span class="pc" id="L175">                }</span>
<span class="fc" id="L176">                return result;</span>
            };
        }
    }

    /**
     * Returns a composed function that first applies this Function4 to the given argument and then applies
     * {@linkplain Function} {@code after} to the result.
     *
     * @param &lt;V&gt; return type of after
     * @param after the function applied after this
     * @return a function composed of this and after
     * @throws NullPointerException if after is null
     */
    default &lt;V&gt; Function4&lt;T1, T2, T3, T4, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
<span class="fc" id="L191">        Objects.requireNonNull(after, &quot;after is null&quot;);</span>
<span class="pc" id="L192">        return (t1, t2, t3, t4) -&gt; after.apply(apply(t1, t2, t3, t4));</span>
    }

    @Override
    default Type&lt;T1, T2, T3, T4, R&gt; getType() {
<span class="fc" id="L197">        return new Type&lt;&gt;(this);</span>
    }

    /**
     * Represents the type of a {@code Function4} which consists of 4 parameter types
     * and a return type.
     *
     *
     * @param &lt;T1&gt; the 1st parameter type of the function
     * @param &lt;T2&gt; the 2nd parameter type of the function
     * @param &lt;T3&gt; the 3rd parameter type of the function
     * @param &lt;T4&gt; the 4th parameter type of the function
     * @param &lt;R&gt; the return type of the function
     * @author Daniel Dietrich
     * @since 2.0.0
     */
    final class Type&lt;T1, T2, T3, T4, R&gt; extends λ.Type&lt;R&gt; {

        private static final long serialVersionUID = 1L;

        private Type(Function4&lt;T1, T2, T3, T4, R&gt; λ) {
<span class="fc" id="L218">            super(λ);</span>
<span class="fc" id="L219">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        public Class&lt;T1&gt; parameterType1() {
<span class="fc" id="L223">            return (Class&lt;T1&gt;) parameterTypes()[0];</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Class&lt;T2&gt; parameterType2() {
<span class="fc" id="L228">            return (Class&lt;T2&gt;) parameterTypes()[1];</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Class&lt;T3&gt; parameterType3() {
<span class="fc" id="L233">            return (Class&lt;T3&gt;) parameterTypes()[2];</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Class&lt;T4&gt; parameterType4() {
<span class="fc" id="L238">            return (Class&lt;T4&gt;) parameterTypes()[3];</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>