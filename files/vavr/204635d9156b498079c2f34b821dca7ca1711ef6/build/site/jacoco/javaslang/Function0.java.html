<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Function0.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang</a> &gt; <span class="el_source">Function0.java</span></div><h1>Function0.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

import java.util.Objects;
import java.util.function.Function;
import java.util.function.Supplier;
import javaslang.control.Option;
import javaslang.control.Try;

/**
 * Represents a function with no arguments.
 *
 * @param &lt;R&gt; return type of the function
 * @author Daniel Dietrich
 * @since 1.1.0
 */
@FunctionalInterface
public interface Function0&lt;R&gt; extends 位&lt;R&gt;, Supplier&lt;R&gt; {

    /**
     * The &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/index.html&quot;&gt;serial version uid&lt;/a&gt;.
     */
    long serialVersionUID = 1L;

    /**
     * Creates a {@code Function0} based on
     * &lt;ul&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html&quot;&gt;method reference&lt;/a&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#syntax&quot;&gt;lambda expression&lt;/a&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * Examples (w.l.o.g. referring to Function1):
     * &lt;pre&gt;&lt;code&gt;// using a lambda expression
     * Function1&amp;lt;Integer, Integer&amp;gt; add1 = Function1.of(i -&amp;gt; i + 1);
     *
     * // using a method reference (, e.g. Integer method(Integer i) { return i + 1; })
     * Function1&amp;lt;Integer, Integer&amp;gt; add2 = Function1.of(this::method);
     *
     * // using a lambda reference
     * Function1&amp;lt;Integer, Integer&amp;gt; add3 = Function1.of(add1::apply);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Caution:&lt;/strong&gt; Reflection loses type information of lambda references.
     * &lt;pre&gt;&lt;code&gt;// type of a lambda expression
     * Type&amp;lt;?, ?&amp;gt; type1 = add1.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a method reference
     * Type&amp;lt;?, ?&amp;gt; type2 = add2.getType(); // (Integer) -&amp;gt; Integer
     *
     * // type of a lambda reference
     * Type&amp;lt;?, ?&amp;gt; type3 = add3.getType(); // (Object) -&amp;gt; Object
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param methodReference (typically) a method reference, e.g. {@code Type::method}
     * @param &lt;R&gt; return type
     * @return a {@code Function0}
     */
    static &lt;R&gt; Function0&lt;R&gt; of(Function0&lt;R&gt; methodReference) {
<span class="fc" id="L67">        return methodReference;</span>
    }

    /**
     * Lifts the given {@code partialFunction} into a total function that returns an {@code Option} result.
     *
     * @param partialFunction a function that is not defined for all values of the domain (e.g. by throwing)
     * @param &lt;R&gt; return type
     * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Some(result)}
     *         if the function is defined for the given arguments, and {@code None} otherwise.
     */
    static &lt;R&gt; Function0&lt;Option&lt;R&gt;&gt; lift(Function0&lt;R&gt; partialFunction) {
<span class="pc" id="L79">        return () -&gt; Try.of(() -&gt; partialFunction.apply()).getOption();</span>
    }

    /**
     * Applies this function to no arguments and returns the result.
     *
     * @return the result of function application
     * 
     */
    R apply();

    /**
     * Implementation of {@linkplain java.util.function.Supplier#get()}, just calls {@linkplain #apply()}.
     *
     * @return the result of {@code apply()}
     */
    @Override
    default R get() {
<span class="fc" id="L97">        return apply();</span>
    }

    @Override
    default int arity() {
<span class="fc" id="L102">        return 0;</span>
    }

    @Override
    default Function0&lt;R&gt; curried() {
<span class="fc" id="L107">        return this;</span>
    }

    @Override
    default Function1&lt;Tuple0, R&gt; tupled() {
<span class="pc" id="L112">        return t -&gt; apply();</span>
    }

    @Override
    default Function0&lt;R&gt; reversed() {
<span class="fc" id="L117">        return this;</span>
    }

    @Override
    default Function0&lt;R&gt; memoized() {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (isMemoized()) {</span>
<span class="fc" id="L123">            return this;</span>
        } else {
<span class="fc" id="L125">            return (Function0&lt;R&gt; &amp; Memoized) Lazy.of(this::apply)::get;</span>
        }
    }

    /**
     * Returns a composed function that first applies this Function0 to the given argument and then applies
     * {@linkplain Function} {@code after} to the result.
     *
     * @param &lt;V&gt; return type of after
     * @param after the function applied after this
     * @return a function composed of this and after
     * @throws NullPointerException if after is null
     */
    default &lt;V&gt; Function0&lt;V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
<span class="fc" id="L139">        Objects.requireNonNull(after, &quot;after is null&quot;);</span>
<span class="pc" id="L140">        return () -&gt; after.apply(apply());</span>
    }

    @Override
    default Type&lt;R&gt; getType() {
<span class="fc" id="L145">        return new Type&lt;&gt;(this);</span>
    }

    /**
     * Represents the type of a {@code Function0} which consists of no parameter types
     * and a return type.
     *
     *
     * @param &lt;R&gt; the return type of the function
     * @author Daniel Dietrich
     * @since 2.0.0
     */
    final class Type&lt;R&gt; extends 位.Type&lt;R&gt; {

        private static final long serialVersionUID = 1L;

        private Type(Function0&lt;R&gt; 位) {
<span class="fc" id="L162">            super(位);</span>
<span class="fc" id="L163">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>