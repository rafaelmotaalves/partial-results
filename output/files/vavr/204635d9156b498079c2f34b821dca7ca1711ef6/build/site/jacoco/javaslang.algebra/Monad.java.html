<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Monad.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.algebra</a> &gt; <span class="el_source">Monad.java</span></div><h1>Monad.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.algebra;

/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*\
   G E N E R A T O R   C R A F T E D
\*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

import java.util.function.BiFunction;
import java.util.function.Function;
import javaslang.*;

/**
 * Defines a Monad by generalizing the flatMap function.
 * &lt;p&gt;
 * A {@code Monad} is a {@link Functor} with a {@code flatMap} method that satisfies the Monad laws, also known
 * as the three control laws:
 * &lt;p&gt;
 * Let
 * &lt;ul&gt;
 * &lt;li&gt;{@code A}, {@code B}, {@code C} be types&lt;/li&gt;
 * &lt;li&gt;{@code unit: A -&gt; Monad&lt;A&gt;} a constructor&lt;/li&gt;
 * &lt;li&gt;{@code f: A -&gt; Monad&lt;B&gt;}, {@code g: B -&gt; Monad&lt;C&gt;} functions&lt;/li&gt;
 * &lt;li&gt;{@code a} be an object of type {@code A}&lt;/li&gt;
 * &lt;li&gt;{@code m} be an object of type {@code Monad&lt;A&gt;}&lt;/li&gt;
 * &lt;/ul&gt;
 * Then all instances of the {@code Monad} interface should obey the three control laws:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;strong&gt;Left identity:&lt;/strong&gt; {@code unit(a).flatMap(f) ≡ f a}&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;Right identity:&lt;/strong&gt; {@code m.flatMap(unit) ≡ m}&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;Associativity:&lt;/strong&gt; {@code m.flatMap(f).flatMap(g) ≡ m.flatMap(x -&gt; f.apply(x).flatMap(g))}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;strong&gt;The left identity `unit(a).flatMap(f) ≡ f.apply(a)` can't be satisfied for single-valued monads.&lt;/strong&gt;
 * &lt;p&gt;
 * Example:
 *
 * &lt;pre&gt;
 * &lt;code&gt;
 * // = Try(1)
 * Try.success(20).flatMap(i -&amp;gt; List.of(1, 2, 3));
 * &lt;/code&gt;
 * &lt;/pre&gt;
 *
 * To fix this, we change the flatMap method by adding a &lt;em&gt;unit&lt;/em&gt; function:
 *
 * &lt;pre&gt;
 * &lt;code&gt;flatMap(f) := unit(map(f).flatten())&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * where &lt;em&gt;unit&lt;/em&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;takes the first element (if present), if the underlying Monad is single-valued&lt;/li&gt;
 * &lt;li&gt;takes all elements (if any is present), if the underlying Monad is multi-valued&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * To read further about monads in Java please refer to
 * &lt;a href=&quot;http://java.dzone.com/articles/whats-wrong-java-8-part-iv&quot;&gt;What's Wrong in Java 8, Part IV: Monads&lt;/a&gt;.
 *
 * @param &lt;T&gt; component type of this monad
 * @author Daniel Dietrich
 * @since 1.1.0
 */
public interface Monad&lt;T&gt; extends Functor&lt;T&gt;, Iterable&lt;T&gt; {

    /**
     * Lifts a {@code Function} to a higher {@code Function1} that operates on Monads.
     *
     * @param &lt;T&gt; 1st argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function
     * @return a new Function1 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T, R&gt; Function1&lt;? super Monad&lt;T&gt;, Monad&lt;R&gt;&gt; lift(Function&lt;? super T, ? extends R&gt; f) {
<span class="fc" id="L79">        return mT -&gt; mT.map(f::apply);</span>
    }

    /**
     * Lifts a {@code BiFunction} to a higher {@code Function2} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a BiFunction
     * @return a new Function2 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, R&gt; Function2&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;R&gt;&gt; lift(BiFunction&lt;? super T1, ? super T2, ? extends R&gt; f) {
<span class="fc" id="L92">        return (mT1, mT2) -&gt;</span>
<span class="fc" id="L93">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L94">                mT2.map(t2 -&gt; f.apply(t1, t2)));</span>
    }

    /**
     * Lifts a {@code Function3} to a higher {@code Function3} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function3
     * @return a new Function3 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, R&gt; Function3&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;R&gt;&gt; lift(Function3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; f) {
<span class="fc" id="L108">        return (mT1, mT2, mT3) -&gt;</span>
<span class="fc" id="L109">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L110">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L111">                mT3.map(t3 -&gt; f.apply(t1, t2, t3))));</span>
    }

    /**
     * Lifts a {@code Function4} to a higher {@code Function4} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;T4&gt; 4th argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function4
     * @return a new Function4 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, T4, R&gt; Function4&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;T4&gt;, Monad&lt;R&gt;&gt; lift(Function4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; f) {
<span class="fc" id="L126">        return (mT1, mT2, mT3, mT4) -&gt;</span>
<span class="fc" id="L127">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L128">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L129">                mT3.flatMap(t3 -&gt;</span>
<span class="fc" id="L130">                mT4.map(t4 -&gt; f.apply(t1, t2, t3, t4)))));</span>
    }

    /**
     * Lifts a {@code Function5} to a higher {@code Function5} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;T4&gt; 4th argument type of f
     * @param &lt;T5&gt; 5th argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function5
     * @return a new Function5 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, T4, T5, R&gt; Function5&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;T4&gt;, Monad&lt;T5&gt;, Monad&lt;R&gt;&gt; lift(Function5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; f) {
<span class="fc" id="L146">        return (mT1, mT2, mT3, mT4, mT5) -&gt;</span>
<span class="fc" id="L147">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L148">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L149">                mT3.flatMap(t3 -&gt;</span>
<span class="fc" id="L150">                mT4.flatMap(t4 -&gt;</span>
<span class="fc" id="L151">                mT5.map(t5 -&gt; f.apply(t1, t2, t3, t4, t5))))));</span>
    }

    /**
     * Lifts a {@code Function6} to a higher {@code Function6} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;T4&gt; 4th argument type of f
     * @param &lt;T5&gt; 5th argument type of f
     * @param &lt;T6&gt; 6th argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function6
     * @return a new Function6 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, T4, T5, T6, R&gt; Function6&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;T4&gt;, Monad&lt;T5&gt;, Monad&lt;T6&gt;, Monad&lt;R&gt;&gt; lift(Function6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; f) {
<span class="fc" id="L168">        return (mT1, mT2, mT3, mT4, mT5, mT6) -&gt;</span>
<span class="fc" id="L169">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L170">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L171">                mT3.flatMap(t3 -&gt;</span>
<span class="fc" id="L172">                mT4.flatMap(t4 -&gt;</span>
<span class="fc" id="L173">                mT5.flatMap(t5 -&gt;</span>
<span class="fc" id="L174">                mT6.map(t6 -&gt; f.apply(t1, t2, t3, t4, t5, t6)))))));</span>
    }

    /**
     * Lifts a {@code Function7} to a higher {@code Function7} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;T4&gt; 4th argument type of f
     * @param &lt;T5&gt; 5th argument type of f
     * @param &lt;T6&gt; 6th argument type of f
     * @param &lt;T7&gt; 7th argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function7
     * @return a new Function7 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Function7&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;T4&gt;, Monad&lt;T5&gt;, Monad&lt;T6&gt;, Monad&lt;T7&gt;, Monad&lt;R&gt;&gt; lift(Function7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; f) {
<span class="fc" id="L192">        return (mT1, mT2, mT3, mT4, mT5, mT6, mT7) -&gt;</span>
<span class="fc" id="L193">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L194">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L195">                mT3.flatMap(t3 -&gt;</span>
<span class="fc" id="L196">                mT4.flatMap(t4 -&gt;</span>
<span class="fc" id="L197">                mT5.flatMap(t5 -&gt;</span>
<span class="fc" id="L198">                mT6.flatMap(t6 -&gt;</span>
<span class="fc" id="L199">                mT7.map(t7 -&gt; f.apply(t1, t2, t3, t4, t5, t6, t7))))))));</span>
    }

    /**
     * Lifts a {@code Function8} to a higher {@code Function8} that operates on Monads.
     *
     * @param &lt;T1&gt; 1st argument type of f
     * @param &lt;T2&gt; 2nd argument type of f
     * @param &lt;T3&gt; 3rd argument type of f
     * @param &lt;T4&gt; 4th argument type of f
     * @param &lt;T5&gt; 5th argument type of f
     * @param &lt;T6&gt; 6th argument type of f
     * @param &lt;T7&gt; 7th argument type of f
     * @param &lt;T8&gt; 8th argument type of f
     * @param &lt;R&gt; result type of f
     * @param f a Function8
     * @return a new Function8 that lifts the given function f in a layer that operates on monads.
     */
    static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Function8&lt;Monad&lt;T1&gt;, Monad&lt;T2&gt;, Monad&lt;T3&gt;, Monad&lt;T4&gt;, Monad&lt;T5&gt;, Monad&lt;T6&gt;, Monad&lt;T7&gt;, Monad&lt;T8&gt;, Monad&lt;R&gt;&gt; lift(Function8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; f) {
<span class="fc" id="L218">        return (mT1, mT2, mT3, mT4, mT5, mT6, mT7, mT8) -&gt;</span>
<span class="fc" id="L219">                mT1.flatMap(t1 -&gt;</span>
<span class="fc" id="L220">                mT2.flatMap(t2 -&gt;</span>
<span class="fc" id="L221">                mT3.flatMap(t3 -&gt;</span>
<span class="fc" id="L222">                mT4.flatMap(t4 -&gt;</span>
<span class="fc" id="L223">                mT5.flatMap(t5 -&gt;</span>
<span class="fc" id="L224">                mT6.flatMap(t6 -&gt;</span>
<span class="fc" id="L225">                mT7.flatMap(t7 -&gt;</span>
<span class="fc" id="L226">                mT8.map(t8 -&gt; f.apply(t1, t2, t3, t4, t5, t6, t7, t8)))))))));</span>
    }

    /**
     * FlatMaps this Monad to a new Monad with different component type.
     * &lt;p&gt;
     * FlatMap is the sequence operation for functions and behaves like the imperative {@code ;}.
     * &lt;p&gt;
     * If the previous results are needed, flatMap cascades:
     * &lt;pre&gt;
     * &lt;code&gt;
     * m1().flatMapM(result1 -&amp;gt;
     *      m2(result1).flatMapM(result2 -&amp;gt;
     *          m3(result1, result2).flatMapM(result3 -&amp;gt;
     *              ...
     *          )
     *      )
     * );
     * &lt;/code&gt;
     * &lt;/pre&gt;
     * If only the last result is needed, flatMap may be used sequentially:
     * &lt;pre&gt;
     * &lt;code&gt;
     * m1().flatMapM(this::m2)
     *     .flatMapM(this::m3)
     *     .flatMapM(...);
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param mapper A mapper
     * @param &lt;U&gt;    Component type of the mapped {@code Monad}
     * @return a mapped {@code Monad}
     * @throws NullPointerException if {@code mapper} is null
     */
    &lt;U&gt; Monad&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper);

    /**
     * Creates a new instance of this Monad. If this Monad is single-valued (like Option an Try),
     * only the first value of the given {@code iterable} is taken.
     *
     * @param &lt;U&gt; component type of the resulting Monad
     * @param iterable an iterable
     * @return a new {@code Monad} instance
     * @throws NullPointerException if {@code mapper} is null
     */
    &lt;U&gt; Monad&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable);

    // -- adjusting return types of super interface methods

    @Override
    &lt;U&gt; Monad&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>