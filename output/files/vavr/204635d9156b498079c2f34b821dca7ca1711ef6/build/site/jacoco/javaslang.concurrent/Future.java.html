<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Future.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.concurrent</a> &gt; <span class="el_source">Future.java</span></div><h1>Future.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.concurrent;

import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.Value;
import javaslang.algebra.Monad;
import javaslang.collection.Iterator;
import javaslang.collection.List;
import javaslang.collection.Seq;
import javaslang.collection.Stream;
import javaslang.control.Match;
import javaslang.control.Option;
import javaslang.control.Try;
import javaslang.control.Try.CheckedRunnable;
import javaslang.control.Try.CheckedSupplier;

import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * A Future is a computation result that becomes available at some point. All operations provided are non-blocking.
 * &lt;p&gt;
 * The underlying {@code ExecutorService} is used to execute asynchronous handlers, e.g. via
 * {@code onComplete(...)}.
 * &lt;p&gt;
 * A Future has two states: pending and completed.
 * &lt;ul&gt;
 * &lt;li&gt;Pending: The computation is ongoing. Only a pending future may be completed or cancelled.&lt;/li&gt;
 * &lt;li&gt;Completed: The computation finished successfully with a result, failed with an exception or was cancelled.&lt;/li&gt;
 * &lt;/ul&gt;
 * Callbacks may be registered on a Future at each point of time. These actions are performed as soon as the Future
 * is completed. An action which is registered on a completed Future is immediately performed. The action may run on
 * a separate Thread, depending on the underlying ExecutorService. Actions which are registered on a cancelled
 * Future are performed with the failed result.
 *
 * @param &lt;T&gt; Type of the computation result.
 * @author Daniel Dietrich, Dillon Jett Callis
 * @since 2.0.0
 */
public interface Future&lt;T&gt; extends Monad&lt;T&gt;, Value&lt;T&gt; {

    /**
     * The default executor service is {@link Executors#newCachedThreadPool()}.
     */
<span class="fc" id="L57">    ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span>

    /**
     * Creates a failed {@code Future} with the given {@code exception}, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param exception The reason why it failed.
     * @param &lt;T&gt;       The value type of a successful result.
     * @return A failed {@code Future}.
     * @throws NullPointerException if exception is null
     */
    static &lt;T&gt; Future&lt;T&gt; failed(Throwable exception) {
<span class="fc" id="L68">        Objects.requireNonNull(exception, &quot;exception is null&quot;);</span>
<span class="fc" id="L69">        return failed(DEFAULT_EXECUTOR_SERVICE, exception);</span>
    }

    /**
     * Creates a failed {@code Future} with the given {@code exception}, backed by the given {@link ExecutorService}.
     *
     * @param executorService An executor service.
     * @param exception       The reason why it failed.
     * @param &lt;T&gt;             The value type of a successful result.
     * @return A failed {@code Future}.
     * @throws NullPointerException if executorService or exception is null
     */
    static &lt;T&gt; Future&lt;T&gt; failed(ExecutorService executorService, Throwable exception) {
<span class="fc" id="L82">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L83">        Objects.requireNonNull(exception, &quot;exception is null&quot;);</span>
<span class="fc" id="L84">        return Promise.&lt;T&gt; failed(executorService, exception).future();</span>
    }

    /**
     * Returns a {@code Future} that eventually succeeds with the first result of the given {@code Future}s which
     * matches the given {@code predicate}. If no result matches, the {@code Future} will contain {@link Option.None}.
     * &lt;p&gt;
     * The returned {@code Future} is backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param futures   An iterable of futures.
     * @param predicate A predicate that tests successful future results.
     * @param &lt;T&gt;       Result type of the futures.
     * @return A Future of an {@link Option} of the first result of the given {@code futures} that satisfies the given {@code predicate}.
     * @throws NullPointerException if one of the arguments is null
     */
    static &lt;T&gt; Future&lt;Option&lt;T&gt;&gt; find(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L100">        return find(DEFAULT_EXECUTOR_SERVICE, futures, predicate);</span>
    }

    /**
     * Returns a {@code Future} that eventually succeeds with the first result of the given {@code Future}s which
     * matches the given {@code predicate}. If no result matches, the {@code Future} will contain {@link Option.None}.
     * &lt;p&gt;
     * The returned {@code Future} is backed by the given {@link ExecutorService}.
     *
     * @param executorService An executor service.
     * @param futures         An iterable of futures.
     * @param predicate       A predicate that tests successful future results.
     * @param &lt;T&gt;             Result type of the futures.
     * @return A Future of an {@link Option} of the first result of the given {@code futures} that satisfies the given {@code predicate}.
     * @throws NullPointerException if one of the arguments is null
     */
    static &lt;T&gt; Future&lt;Option&lt;T&gt;&gt; find(ExecutorService executorService, Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L117">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L118">        Objects.requireNonNull(futures, &quot;futures is null&quot;);</span>
<span class="fc" id="L119">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L120">        final Promise&lt;Option&lt;T&gt;&gt; promise = Promise.make(executorService);</span>
<span class="fc" id="L121">        final List&lt;Future&lt;? extends T&gt;&gt; list = List.ofAll(futures);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (list.isEmpty()) {</span>
<span class="fc" id="L123">            promise.success(Option.none());</span>
        } else {
<span class="fc" id="L125">            final AtomicInteger count = new AtomicInteger(list.length());</span>
<span class="fc" id="L126">            list.forEach(future -&gt; future.onComplete(result -&gt; {</span>
<span class="fc" id="L127">                synchronized (count) {</span>
                    // if the promise is already completed we already found our result and there is nothing more to do.
<span class="fc bfc" id="L129" title="All 2 branches covered.">                    if (!promise.isCompleted()) {</span>
                        // when there are no more results we return a None
<span class="fc bfc" id="L131" title="All 2 branches covered.">                        final boolean wasLast = count.decrementAndGet() == 0;</span>
                        // when result is a Failure or predicate is false then we check in onFailure for finish
<span class="fc" id="L133">                        result.filter(predicate)</span>
<span class="fc" id="L134">                                .onSuccess(value -&gt; promise.trySuccess(Option.some(value)))</span>
<span class="fc" id="L135">                                .onFailure(ignored -&gt; {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                                    if (wasLast) {</span>
<span class="fc" id="L137">                                        promise.trySuccess(Option.none());</span>
                                    }
<span class="fc" id="L139">                                });</span>
                    }
<span class="pc" id="L141">                }</span>
<span class="fc" id="L142">            }));</span>
        }
<span class="fc" id="L144">        return promise.future();</span>
    }

    /**
     * Returns a new {@code Future} that will contain the result of the first of the given futures that is completed,
     * backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param futures An iterable of futures.
     * @param &lt;T&gt;     The result type.
     * @return A new {@code Future}.
     * @throws NullPointerException if futures is null
     */
    static &lt;T&gt; Future&lt;T&gt; firstCompletedOf(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures) {
<span class="fc" id="L157">        return firstCompletedOf(DEFAULT_EXECUTOR_SERVICE, futures);</span>
    }

    /**
     * Returns a new {@code Future} that will contain the result of the first of the given futures that is completed,
     * backed by the given {@link ExecutorService}.
     *
     * @param executorService An executor service.
     * @param futures         An iterable of futures.
     * @param &lt;T&gt;             The result type.
     * @return A new {@code Future}.
     * @throws NullPointerException if executorService or futures is null
     */
    static &lt;T&gt; Future&lt;T&gt; firstCompletedOf(ExecutorService executorService, Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures) {
<span class="fc" id="L171">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L172">        Objects.requireNonNull(futures, &quot;futures is null&quot;);</span>
<span class="fc" id="L173">        final Promise&lt;T&gt; promise = Promise.make(executorService);</span>
<span class="fc" id="L174">        final Consumer&lt;Try&lt;? extends T&gt;&gt; completeFirst = promise::tryComplete;</span>
<span class="fc" id="L175">        futures.forEach(future -&gt; future.onComplete(completeFirst));</span>
<span class="fc" id="L176">        return promise.future();</span>
    }

    /**
     * Returns a Future which contains the result of the fold of the given future values. If any future or the fold
     * fail, the result is a failure.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param futures An iterable of futures.
     * @param zero    The zero element of the fold.
     * @param f       The fold operation.
     * @param &lt;T&gt;     The result type of the given {@code Futures}.
     * @param &lt;U&gt;     The fold result type.
     * @return A new {@code Future} that will contain the fold result.
     * @throws NullPointerException if futures or f is null.
     */
    static &lt;T, U&gt; Future&lt;U&gt; fold(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; f) {
<span class="fc" id="L194">        return fold(DEFAULT_EXECUTOR_SERVICE, futures, zero, f);</span>
    }

    /**
     * Returns a Future which contains the result of the fold of the given future values. If any future or the fold
     * fail, the result is a failure.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param futures         An iterable of futures.
     * @param zero            The zero element of the fold.
     * @param f               The fold operation.
     * @param &lt;T&gt;             The result type of the given {@code Futures}.
     * @param &lt;U&gt;             The fold result type.
     * @return A new {@code Future} that will contain the fold result.
     * @throws NullPointerException if executorService, futures or f is null.
     */
    static &lt;T, U&gt; Future&lt;U&gt; fold(ExecutorService executorService, Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; f) {
<span class="fc" id="L213">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L214">        Objects.requireNonNull(futures, &quot;futures is null&quot;);</span>
<span class="fc" id="L215">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (!futures.iterator().hasNext()) {</span>
<span class="fc" id="L217">            return successful(executorService, zero);</span>
        } else {
<span class="fc" id="L219">            return sequence(executorService, futures).map(seq -&gt; seq.foldLeft(zero, f));</span>
        }
    }

    /**
     * Creates a {@code Future} with the given java.util.concurrent.Future, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}
     *
     * @param future A {@link java.util.concurrent.Future}
     * @param &lt;T&gt;    Result type of the Future
     * @return A new {@code Future} wrapping the result of the Java future
     * @throws NullPointerException if future is null
     */
    static &lt;T&gt; Future&lt;T&gt; fromJavaFuture(java.util.concurrent.Future&lt;T&gt; future) {
<span class="fc" id="L232">        Objects.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L233">        return Future.of(DEFAULT_EXECUTOR_SERVICE, future::get);</span>
    }

    /**
     * Creates a {@code Future} with the given java.util.concurrent.Future, backed by given {@link ExecutorService}
     *
     * @param executorService An {@link ExecutorService}
     * @param future          A {@link java.util.concurrent.Future}
     * @param &lt;T&gt;             Result type of the Future
     * @return A new {@code Future} wrapping the result of the Java future
     * @throws NullPointerException if executorService or future is null
     */
    static &lt;T&gt; Future&lt;T&gt; fromJavaFuture(ExecutorService executorService, java.util.concurrent.Future&lt;T&gt; future) {
<span class="fc" id="L246">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L247">        Objects.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L248">        return Future.of(executorService, future::get);</span>
    }

    /**
     * Creates a {@code Future} from a {@link Try}, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param result The result.
     * @param &lt;T&gt;    The value type of a successful result.
     * @return A completed {@code Future} which contains either a {@code Success} or a {@code Failure}.
     * @throws NullPointerException if result is null
     */
    static &lt;T&gt; Future&lt;T&gt; fromTry(Try&lt;? extends T&gt; result) {
<span class="fc" id="L260">        return fromTry(DEFAULT_EXECUTOR_SERVICE, result);</span>
    }

    /**
     * Creates a {@code Future} from a {@link Try}, backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param result          The result.
     * @param &lt;T&gt;             The value type of a successful result.
     * @return A completed {@code Future} which contains either a {@code Success} or a {@code Failure}.
     * @throws NullPointerException if executorService or result is null
     */
    static &lt;T&gt; Future&lt;T&gt; fromTry(ExecutorService executorService, Try&lt;? extends T&gt; result) {
<span class="fc" id="L273">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L274">        Objects.requireNonNull(result, &quot;result is null&quot;);</span>
<span class="fc" id="L275">        return Promise.&lt;T&gt; fromTry(executorService, result).future();</span>
    }

    /**
     * Starts an asynchronous computation, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param computation A computation.
     * @param &lt;T&gt;         Type of the computation result.
     * @return A new Future instance.
     * @throws NullPointerException if computation is null.
     */
    static &lt;T&gt; Future&lt;T&gt; of(CheckedSupplier&lt;? extends T&gt; computation) {
<span class="fc" id="L287">        return Future.of(DEFAULT_EXECUTOR_SERVICE, computation);</span>
    }

    /**
     * Starts an asynchronous computation, backed by the given {@link ExecutorService}.
     *
     * @param executorService An executor service.
     * @param computation     A computation.
     * @param &lt;T&gt;             Type of the computation result.
     * @return A new Future instance.
     * @throws NullPointerException if one of executorService of computation is null.
     */
    static &lt;T&gt; Future&lt;T&gt; of(ExecutorService executorService, CheckedSupplier&lt;? extends T&gt; computation) {
<span class="fc" id="L300">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L301">        Objects.requireNonNull(computation, &quot;computation is null&quot;);</span>
<span class="fc" id="L302">        final FutureImpl&lt;T&gt; future = new FutureImpl&lt;&gt;(executorService);</span>
<span class="fc" id="L303">        future.run(computation);</span>
<span class="fc" id="L304">        return future;</span>
    }

    /**
     * Returns a Future which contains the reduce result of the given future values. The zero is the result of the
     * first future that completes. If any future or the reduce operation fail, the result is a failure.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param futures An iterable of futures.
     * @param f       The reduce operation.
     * @param &lt;T&gt;     The result type of the given {@code Futures}.
     * @return A new {@code Future} that will contain the reduce result.
     * @throws NullPointerException if executorService, futures or f is null.
     */
    static &lt;T&gt; Future&lt;T&gt; reduce(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, BiFunction&lt;? super T, ? super T, ? extends T&gt; f) {
<span class="fc" id="L320">        return reduce(DEFAULT_EXECUTOR_SERVICE, futures, f);</span>
    }

    /**
     * Returns a Future which contains the reduce result of the given future values. The zero is the result of the
     * first future that completes. If any future or the reduce operation fail, the result is a failure.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param futures         An iterable of futures.
     * @param f               The reduce operation.
     * @param &lt;T&gt;             The result type of the given {@code Futures}.
     * @return A new {@code Future} that will contain the reduce result.
     * @throws NullPointerException if executorService, futures or f is null.
     */
    static &lt;T&gt; Future&lt;T&gt; reduce(ExecutorService executorService, Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures, BiFunction&lt;? super T, ? super T, ? extends T&gt; f) {
<span class="fc" id="L337">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L338">        Objects.requireNonNull(futures, &quot;futures is null&quot;);</span>
<span class="fc" id="L339">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (!futures.iterator().hasNext()) {</span>
<span class="fc" id="L341">            throw new NoSuchElementException(&quot;Future.reduce on empty futures&quot;);</span>
        } else {
<span class="fc" id="L343">            return Future.&lt;T&gt; sequence(futures).map(seq -&gt; seq.reduceLeft(f));</span>
        }
    }

    /**
     * Runs an asynchronous computation, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param unit A unit of work.
     * @return A new Future instance which results in nothing.
     * @throws NullPointerException if unit is null.
     */
    static Future&lt;Void&gt; run(CheckedRunnable unit) {
<span class="fc" id="L355">        return run(DEFAULT_EXECUTOR_SERVICE, unit);</span>
    }

    /**
     * Starts an asynchronous computation, backed by the given {@link ExecutorService}.
     *
     * @param executorService An executor service.
     * @param unit            A unit of work.
     * @return A new Future instance which results in nothing.
     * @throws NullPointerException if one of executorService of unit is null.
     */
    static Future&lt;Void&gt; run(ExecutorService executorService, CheckedRunnable unit) {
<span class="fc" id="L367">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L368">        Objects.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L369">        return Future.of(executorService, () -&gt; {</span>
<span class="fc" id="L370">            unit.run();</span>
<span class="fc" id="L371">            return null;</span>
        });
    }

    /**
     * Reduces many {@code Future}s into a single {@code Future} by transforming an
     * {@code Iterable&lt;Future&lt;? extends T&gt;&gt;} into a {@code Future&lt;Seq&lt;T&gt;&gt;}.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * &lt;ul&gt;
     * &lt;li&gt;
     * If all of the given Futures succeed, sequence() succeeds too:
     * &lt;pre&gt;&lt;code&gt;// = Future(Success(Seq(1, 2)))
     * sequence(
     *     List.of(
     *         Future.of(() -&amp;gt; 1),
     *         Future.of(() -&amp;gt; 2)
     *     )
     * );&lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;li&gt;
     * If a given Future fails, sequence() fails too:
     * &lt;pre&gt;&lt;code&gt;// = Future(Failure(Error)))
     * sequence(
     *     List.of(
     *         Future.of(() -&amp;gt; 1),
     *         Future.of(() -&amp;gt; { throw new Error(); }
     *     )
     * );&lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param futures An {@code Iterable} of {@code Future}s.
     * @param &lt;T&gt;     Result type of the futures.
     * @return A {@code Future} of a {@link Seq} of results.
     * @throws NullPointerException if futures is null.
     */
    static &lt;T&gt; Future&lt;Seq&lt;T&gt;&gt; sequence(Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures) {
<span class="fc" id="L410">        return sequence(DEFAULT_EXECUTOR_SERVICE, futures);</span>
    }

    /**
     * Reduces many {@code Future}s into a single {@code Future} by transforming an
     * {@code Iterable&lt;Future&lt;? extends T&gt;&gt;} into a {@code Future&lt;Seq&lt;T&gt;&gt;}.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param futures         An {@code Iterable} of {@code Future}s.
     * @param &lt;T&gt;             Result type of the futures.
     * @return A {@code Future} of a {@link Seq} of results.
     * @throws NullPointerException if executorService or futures is null.
     */
    static &lt;T&gt; Future&lt;Seq&lt;T&gt;&gt; sequence(ExecutorService executorService, Iterable&lt;? extends Future&lt;? extends T&gt;&gt; futures) {
<span class="fc" id="L426">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L427">        Objects.requireNonNull(futures, &quot;futures is null&quot;);</span>
<span class="fc" id="L428">        final Future&lt;Seq&lt;T&gt;&gt; zero = successful(executorService, Stream.empty());</span>
<span class="fc" id="L429">        final BiFunction&lt;Future&lt;Seq&lt;T&gt;&gt;, Future&lt;? extends T&gt;, Future&lt;Seq&lt;T&gt;&gt;&gt; f =</span>
<span class="fc" id="L430">                (result, future) -&gt; result.flatMap(seq -&gt; future.map(seq::append));</span>
<span class="fc" id="L431">        return Iterator.ofAll(futures).foldLeft(zero, f);</span>
    }

    /**
     * Creates a succeeded {@code Future}, backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param result The result.
     * @param &lt;T&gt;    The value type of a successful result.
     * @return A succeeded {@code Future}.
     */
    static &lt;T&gt; Future&lt;T&gt; successful(T result) {
<span class="fc" id="L442">        return successful(DEFAULT_EXECUTOR_SERVICE, result);</span>
    }

    /**
     * Creates a succeeded {@code Future}, backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param result          The result.
     * @param &lt;T&gt;             The value type of a successful result.
     * @return A succeeded {@code Future}.
     * @throws NullPointerException if executorService is null
     */
    static &lt;T&gt; Future&lt;T&gt; successful(ExecutorService executorService, T result) {
<span class="fc" id="L455">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L456">        return Promise.successful(executorService, result).future();</span>
    }

    /**
     * Maps the values of an iterable in parallel to a sequence of mapped values into a single {@code Future} by
     * transforming an {@code Iterable&lt;? extends T&gt;} into a {@code Future&lt;Seq&lt;U&gt;&gt;}.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the {@link #DEFAULT_EXECUTOR_SERVICE}.
     *
     * @param values An {@code Iterable} of {@code Future}s.
     * @param mapper A mapper of values to Futures
     * @param &lt;T&gt;    The type of the given values.
     * @param &lt;U&gt;    The mapped value type.
     * @return A {@code Future} of a {@link Seq} of results.
     * @throws NullPointerException if values or f is null.
     */
    static &lt;T, U&gt; Future&lt;Seq&lt;U&gt;&gt; traverse(Iterable&lt;? extends T&gt; values, Function&lt;? super T, ? extends Future&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L473">        return traverse(DEFAULT_EXECUTOR_SERVICE, values, mapper);</span>
    }

    /**
     * Maps the values of an iterable in parallel to a sequence of mapped values into a single {@code Future} by
     * transforming an {@code Iterable&lt;? extends T&gt;} into a {@code Future&lt;Seq&lt;U&gt;&gt;}.
     * &lt;p&gt;
     * The resulting {@code Future} is backed by the given {@link ExecutorService}.
     *
     * @param executorService An {@code ExecutorService}.
     * @param values          An {@code Iterable} of values.
     * @param mapper          A mapper of values to Futures
     * @param &lt;T&gt;             The type of the given values.
     * @param &lt;U&gt;             The mapped value type.
     * @return A {@code Future} of a {@link Seq} of results.
     * @throws NullPointerException if executorService, values or f is null.
     */
    static &lt;T, U&gt; Future&lt;Seq&lt;U&gt;&gt; traverse(ExecutorService executorService, Iterable&lt;? extends T&gt; values, Function&lt;? super T, ? extends Future&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L491">        Objects.requireNonNull(executorService, &quot;executorService is null&quot;);</span>
<span class="fc" id="L492">        Objects.requireNonNull(values, &quot;values is null&quot;);</span>
<span class="fc" id="L493">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L494">        return sequence(Iterator.ofAll(values).map(mapper));</span>
    }

    // -- non-static Future API

    /**
     * Support for chaining of callbacks that are guaranteed to be executed in a specific order.
     * &lt;p&gt;
     * An exception, which occurs when performing the given {@code action}, is not propagated to the outside.
     * In other words, subsequent actions are performed based on the value of the original Future.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // prints Success(1)
     * Future.of(() -&amp;gt; 1)
     *       .andThen(t -&amp;gt; { throw new Error(&quot;&quot;); })
     *       .andThen(System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param action A side-effecting action.
     * @return A new Future that contains this result and which is completed after the given action was performed.
     * @throws NullPointerException if action is null
     */
    default Future&lt;T&gt; andThen(Consumer&lt;? super Try&lt;T&gt;&gt; action) {
<span class="fc" id="L518">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc" id="L519">        final Promise&lt;T&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L520">        onComplete(t -&gt; {</span>
<span class="fc" id="L521">            Try.run(() -&gt; action.accept(t));</span>
<span class="fc" id="L522">            promise.complete(t);</span>
<span class="fc" id="L523">        });</span>
<span class="fc" id="L524">        return promise.future();</span>
    }

    /**
     * Blocks the current Thread until this Future completed or returns immediately if this Future is already completed.
     */
    void await();

    /**
     * Cancels the Future. A running thread is interrupted.
     * &lt;p&gt;
     * If the Future was successfully cancelled, the result is a {@code Failure(CancellationException)}.
     *
     * @return {@code false}, if this {@code Future} is already completed or could not be cancelled, otherwise {@code true}.
     */
    default boolean cancel() {
<span class="fc" id="L540">        return cancel(true);</span>
    }

    /**
     * Cancels the Future. A pending Future may be interrupted, depending on the underlying ExecutionService.
     * &lt;p&gt;
     * If the Future was successfully cancelled, the result is a {@code Failure(CancellationException)}.
     *
     * @param mayInterruptIfRunning {@code true} if a running thread should be interrupted, otherwise a running thread
     *                              is allowed to complete its computation.
     * @return {@code false}, if this {@code Future} is already completed or could not be cancelled, otherwise {@code true}.
     * @see java.util.concurrent.Future#cancel(boolean)
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns the {@link ExecutorService} used by this {@code Future}.
     *
     * @return The underlying {@code ExecutorService}.
     */
    ExecutorService executorService();

    /**
     * A projection that inverses the result of this Future.
     * &lt;p&gt;
     * If this Future succeeds, the failed projection returns a failure containing a {@code NoSuchElementException}.
     * &lt;p&gt;
     * If this Future fails, the failed projection returns a success containing the exception.
     *
     * @return A new Future which contains an exception at a point of time.
     */
    default Future&lt;Throwable&gt; failed() {
<span class="fc" id="L572">        final Promise&lt;Throwable&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L573">        onComplete(result -&gt; {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (result.isFailure()) {</span>
<span class="fc" id="L575">                promise.success(result.getCause());</span>
            } else {
<span class="fc" id="L577">                promise.failure(new NoSuchElementException(&quot;Future.failed completed without a throwable&quot;));</span>
            }
<span class="fc" id="L579">        });</span>
<span class="fc" id="L580">        return promise.future();</span>
    }

    /**
     * Returns a Future that returns the result of this Future, if it is a success. If the value of this Future is a
     * failure, the result of {@code that} Future is returned, if that is a success. If both Futures fail, the failure
     * of this Future is returned.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Future&amp;lt;Integer&amp;gt; future = Future.of(() -&amp;gt; { throw new Error(); });
     * Future&amp;lt;Integer&amp;gt; that = Future.of(() -&amp;gt; 1);
     * Future&amp;lt;Integer&amp;gt; result = future.fallbackTo(that);
     *
     * // prints Some(1)
     * result.onComplete(System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param that A fallback future computation
     * @return A new Future
     * @throws NullPointerException if that is null
     */
    default Future&lt;T&gt; fallbackTo(Future&lt;? extends T&gt; that) {
<span class="fc" id="L603">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L604">        final Promise&lt;T&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L605">        onComplete(t -&gt; {</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (t.isSuccess()) {</span>
<span class="fc" id="L607">                promise.complete(t);</span>
            } else {
<span class="fc" id="L609">                that.onComplete(alt -&gt; {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                    if (alt.isSuccess()) {</span>
<span class="fc" id="L611">                        promise.complete(alt);</span>
                    } else {
<span class="fc" id="L613">                        promise.complete(t);</span>
                    }
<span class="fc" id="L615">                });</span>
            }
<span class="fc" id="L617">        });</span>
<span class="fc" id="L618">        return promise.future();</span>
    }

    @Override
    default Future&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L623">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L624">        final Promise&lt;T&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L625">        onComplete(result -&gt; promise.complete(result.filter(predicate)));</span>
<span class="fc" id="L626">        return promise.future();</span>
    }

    @Override
    default Future&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate) {
<span class="nc" id="L631">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="nc" id="L632">        return filter(predicate.negate());</span>
    }

    /**
     * Returns the underlying exception of this Future, syntactic sugar for {@code future.getValue().map(Try::getCause)}.
     *
     * @return None if the Future is not completed yet. Returns Some(Throwable) if the Future was completed with a failure.
     * @throws UnsupportedOperationException if the Future was successfully completed with a value
     */
    default Option&lt;Throwable&gt; getCause() {
<span class="fc" id="L642">        return getValue().map(Try::getCause);</span>
    }

    /**
     * Returns the value of the Future.
     *
     * @return {@code None}, if the Future is not yet completed or was cancelled, otherwise {@code Some(Try)}.
     */
    Option&lt;Try&lt;T&gt;&gt; getValue();

    /**
     * Checks if this Future is completed, i.e. has a value.
     *
     * @return true, if the computation successfully finished, failed or was cancelled, false otherwise.
     */
    boolean isCompleted();

    /**
     * Checks if this Future completed with a success.
     *
     * @return true, if this Future completed and is a Success, false otherwise.
     */
    default boolean isSuccess() {
<span class="fc" id="L665">        return getValue().map(Try::isSuccess).orElse(false);</span>
    }

    /**
     * Checks if this Future completed with a failure.
     *
     * @return true, if this Future completed and is a Failure, false otherwise.
     */
    default boolean isFailure() {
<span class="fc" id="L674">        return getValue().map(Try::isFailure).orElse(false);</span>
    }

    /**
     * Performs the action once the Future is complete.
     *
     * @param action An action to be performed when this future is complete.
     * @throws NullPointerException if {@code action} is null.
     */
    void onComplete(Consumer&lt;? super Try&lt;T&gt;&gt; action);

    /**
     * Performs the action once the Future is complete and the result is a {@link Try.Failure}. Please note that the
     * future is also a failure when it was cancelled.
     *
     * @param action An action to be performed when this future failed.
     * @throws NullPointerException if {@code action} is null.
     */
    default void onFailure(Consumer&lt;? super Throwable&gt; action) {
<span class="fc" id="L693">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc" id="L694">        onComplete(result -&gt; result.onFailure(action));</span>
<span class="fc" id="L695">    }</span>

    /**
     * Performs the action once the Future is complete and the result is a {@link Try.Success}.
     *
     * @param action An action to be performed when this future succeeded.
     * @throws NullPointerException if {@code action} is null.
     */
    default void onSuccess(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L704">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc" id="L705">        onComplete(result -&gt; result.onSuccess(action));</span>
<span class="fc" id="L706">    }</span>

    /**
     * Handles a failure of this Future by returning another result.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // = &quot;oh!&quot;
     * Future.of(() -&amp;gt; new Error(&quot;oh!&quot;)).recover(Throwable::getMessage);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param f A function which takes the exception of a failure and returns a new value.
     * @return A new Future.
     * @throws NullPointerException if {@code f} is null
     */
    default Future&lt;T&gt; recover(Function&lt;? super Throwable, ? extends T&gt; f) {
<span class="fc" id="L722">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L723">        final Promise&lt;T&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L724">        onComplete(t -&gt; promise.complete(t.recover(f)));</span>
<span class="fc" id="L725">        return promise.future();</span>
    }

    /**
     * Handles a failure of this Future by returning the result of another Future.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // = &quot;oh!&quot;
     * Future.of(() -&amp;gt; { throw new Error(&quot;oh!&quot;); }).recoverWith(x -&amp;gt; Future.of(x::getMessage));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param f A function which takes the exception of a failure and returns a new future.
     * @return A new Future.
     * @throws NullPointerException if {@code f} is null
     */
    default Future&lt;T&gt; recoverWith(Function&lt;? super Throwable, ? extends Future&lt;? extends T&gt;&gt; f) {
<span class="fc" id="L742">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L743">        final Promise&lt;T&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L744">        onComplete(t -&gt; {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            if (t.isFailure()) {</span>
<span class="fc" id="L746">                Try.run(() -&gt; f.apply(t.getCause()).onComplete(promise::complete)).onFailure(promise::failure);</span>
            } else {
<span class="fc" id="L748">                promise.complete(t);</span>
            }
<span class="fc" id="L750">        });</span>
<span class="fc" id="L751">        return promise.future();</span>
    }

    /**
     * Transforms this {@code Future}.
     *
     * @param f   A transformation
     * @param &lt;U&gt; Type of transformation result
     * @return An instance of type {@code U}
     * @throws NullPointerException if {@code f} is null
     */
    default &lt;U&gt; U transform(Function&lt;? super Future&lt;? super T&gt;, ? extends U&gt; f) {
<span class="fc" id="L763">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L764">        return f.apply(this);</span>
    }

    /**
     * Returns a tuple of this and that Future result.
     * &lt;p&gt;
     * If this Future failed the result contains this failure. Otherwise the result contains that failure or
     * a tuple of both successful Future results.
     *
     * @param that Another Future
     * @param &lt;U&gt;  Result type of {@code that}
     * @return A new Future that returns both Future results.
     * @throws NullPointerException if {@code that} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default &lt;U&gt; Future&lt;Tuple2&lt;T, U&gt;&gt; zip(Future&lt;? extends U&gt; that) {
<span class="fc" id="L780">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L781">        final Promise&lt;Tuple2&lt;T, U&gt;&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L782">        onComplete(res1 -&gt; {</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            if (res1.isFailure()) {</span>
<span class="fc" id="L784">                promise.complete((Try.Failure&lt;Tuple2&lt;T, U&gt;&gt;) res1);</span>
            } else {
<span class="fc" id="L786">                that.onComplete(res2 -&gt; {</span>
<span class="fc" id="L787">                    final Try&lt;Tuple2&lt;T, U&gt;&gt; result = res1.flatMap(t -&gt; res2.map(u -&gt; Tuple.of(t, u)));</span>
<span class="fc" id="L788">                    promise.complete(result);</span>
<span class="fc" id="L789">                });</span>
            }
<span class="fc" id="L791">        });</span>
<span class="fc" id="L792">        return promise.future();</span>
    }

    // -- Value &amp; Monad implementation

    @Override
    default &lt;U&gt; Future&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L799">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L800">        final Promise&lt;U&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L801">        onComplete((Try&lt;T&gt; result) -&gt; result.map(mapper)</span>
<span class="fc" id="L802">            .onSuccess(iterable -&gt; promise.completeWith(unit(iterable)))</span>
<span class="fc" id="L803">            .onFailure(promise::failure)</span>
        );
<span class="fc" id="L805">        return promise.future();</span>
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    default &lt;U&gt; Future&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">    	if (iterable instanceof Future) {</span>
<span class="fc" id="L812">    		return (Future&lt;U&gt;) iterable;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">    	} else if (iterable instanceof Value) {</span>
<span class="nc" id="L814">    		final Value&lt;U&gt; value = (Value&lt;U&gt;) iterable;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">    		return value.isEmpty() ? Future.failed(new NoSuchElementException()) : Future.successful(value.get());</span>
    	} else {
<span class="nc" id="L817">    		final java.util.Iterator&lt;? extends U&gt; iterator = iterable.iterator();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">    		if (iterator.hasNext()) {</span>
<span class="nc" id="L819">    			return Future.successful(iterator.next());</span>
    		} else {
<span class="nc" id="L821">    			return Future.failed(new NoSuchElementException());</span>
    		}
        }
    }

    /**
     * Performs the given {@code action} asynchronously hence this Future result becomes available.
     * The {@code action} is not performed, if the result is a failure.
     *
     * @param action A {@code Consumer}
     */
    @Override
    default void forEach(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L834">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="nc" id="L835">        onComplete(result -&gt; result.forEach(action));</span>
<span class="nc" id="L836">    }</span>

    /**
     * Returns the value of the future. Waits for the result if necessary.
     *
     * @return The value of this future.
     * @throws NoSuchElementException if the computation unexpectedly failed or was interrupted.
     */
    // DEV-NOTE: A NoSuchElementException is thrown instead of the exception of the underlying Failure in order to
    //           be conform to Value#get
    @Override
    default T get() {
        // is empty will block until result is available
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L850">            throw new NoSuchElementException(&quot;get on failed future&quot;);</span>
        } else {
<span class="fc" id="L852">            return getValue().get().get();</span>
        }
    }

    /**
     * Checks, if this future has a value.
     *
     * @return true, if this future succeeded with a value, false otherwise.
     */
    @Override
    default boolean isEmpty() {
        // does not need to be synchronized, wait() has to check the completed state again
<span class="fc bfc" id="L864" title="All 2 branches covered.">        if (!isCompleted()) {</span>
<span class="fc" id="L865">            await();</span>
        }
<span class="fc" id="L867">        return getValue().get().isEmpty();</span>
    }

    /**
     * A {@code Future} is single-valued.
     *
     * @return {@code true}
     */
    @Override
    default boolean isSingleValued() {
<span class="nc" id="L877">        return true;</span>
    }

    @Override
    default Iterator&lt;T&gt; iterator() {
<span class="fc bfc" id="L882" title="All 2 branches covered.">        return isEmpty() ? Iterator.empty() : Iterator.of(get());</span>
    }

    @Override
    default &lt;U&gt; Future&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L887">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L888">        final Promise&lt;U&gt; promise = Promise.make(executorService());</span>
<span class="fc" id="L889">        onComplete(result -&gt; promise.complete(result.map(mapper)));</span>
<span class="fc" id="L890">        return promise.future();</span>
    }

    @Override
    default Match.MatchMonad.Of&lt;Future&lt;T&gt;&gt; match() {
<span class="fc" id="L895">        return Match.of(this);</span>
    }

    @Override
    default Future&lt;T&gt; peek(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L900">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc" id="L901">        onSuccess(action);</span>
<span class="fc" id="L902">        return this;</span>
    }

    @Override
    default String stringPrefix() {
<span class="nc" id="L907">        return &quot;Future&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>