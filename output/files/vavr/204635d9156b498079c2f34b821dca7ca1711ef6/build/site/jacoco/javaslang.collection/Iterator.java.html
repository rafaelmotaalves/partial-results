<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Iterator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">Iterator.java</span></div><h1>Iterator.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.Tuple3;
import javaslang.collection.IteratorModule.ConcatIterator;
import javaslang.collection.IteratorModule.DistinctIterator;
import javaslang.control.Match;
import javaslang.control.Option;

import java.util.*;
import java.util.function.*;

/**
 * {@code javaslang.collection.Iterator} is a compositional replacement for {@code java.util.Iterator}
 * whose purpose is to iterate &lt;em&gt;once&lt;/em&gt; over a sequence of elements.
 * &lt;p&gt;
 * It is recommended to create instances using {@link AbstractIterator} in favor of {@code Iterator}.
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; Iterators encapsulate mutable state.
 * They are not meant to be used concurrently by different threads. Do not reuse Iterators, e.g. after passing to
 * {@linkplain List#ofAll(Iterable)}.
 * &lt;p&gt;
 * There are two abstract methods: {@code hasNext} for checking if there is a next element available,
 * and {@code next} which removes the next element from the iterator and returns it. They can be called
 * an arbitrary amount of times. If {@code hasNext} returns false, a call of {@code next} will throw
 * a {@code NoSuchElementException}.
 * &lt;p&gt;
 * &lt;strong&gt;Caution: Other methods than {@code hasNext} and {@code next} can be called only once (exclusively).
 * More specifically, after calling a method it cannot be guaranteed that the next call will succeed.&lt;/strong&gt;
 *
 * An Iterator that can be only used once because it is a traversal pointer into a collection, and not a collection
 * itself.
 *
 * @param &lt;T&gt; Component type
 * @author Daniel Dietrich
 * @since 2.0.0
 */
public interface Iterator&lt;T&gt; extends java.util.Iterator&lt;T&gt;, Traversable&lt;T&gt; {

    // DEV-NOTE: we prefer returning empty() over this if !hasNext() == true in order to free memory.

    /**
     * The empty Iterator.
     */
<span class="fc" id="L51">    Iterator&lt;Object&gt; EMPTY = new AbstractIterator&lt;Object&gt;() {</span>

        @Override
        public boolean hasNext() {
<span class="fc" id="L55">            return false;</span>
        }

        @Override
        public Object getNext() {
<span class="nc" id="L60">            return null;</span>
        }
    };

    /**
     * Creates an Iterator which traverses along the concatenation of the given iterables.
     *
     * @param iterables The iterables
     * @param &lt;T&gt;       Component type.
     * @return A new {@code javaslang.collection.Iterator}
     */
    @SuppressWarnings(&quot;varargs&quot;)
    @SafeVarargs
    static &lt;T&gt; Iterator&lt;T&gt; concat(Iterable&lt;? extends T&gt;... iterables) {
<span class="fc" id="L74">        Objects.requireNonNull(iterables, &quot;iterables is null&quot;);</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (iterables.length == 0) {</span>
<span class="fc" id="L76">            return empty();</span>
        } else {
<span class="fc" id="L78">            return new ConcatIterator&lt;&gt;(Stream.of(iterables).map(Iterator::ofAll).iterator());</span>
        }
    }

    /**
     * Creates an Iterator which traverses along the concatenation of the given iterables.
     *
     * @param iterables The iterable of iterables
     * @param &lt;T&gt;       Component type.
     * @return A new {@code javaslang.collection.Iterator}
     */
    static &lt;T&gt; Iterator&lt;T&gt; concat(Iterable&lt;? extends Iterable&lt;? extends T&gt;&gt; iterables) {
<span class="fc" id="L90">        Objects.requireNonNull(iterables, &quot;iterables is null&quot;);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (!iterables.iterator().hasNext()) {</span>
<span class="fc" id="L92">            return empty();</span>
        } else {
<span class="fc" id="L94">            return new ConcatIterator&lt;&gt;(Stream.ofAll(iterables).map(Iterator::ofAll).iterator());</span>
        }
    }

    /**
     * Returns the empty Iterator.
     *
     * @param &lt;T&gt; Component type
     * @return The empty Iterator
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Iterator&lt;T&gt; empty() {
<span class="fc" id="L106">        return (Iterator&lt;T&gt;) EMPTY;</span>
    }

    /**
     * Creates an Iterator which traverses one element.
     *
     * @param element An element
     * @param &lt;T&gt;     Component type.
     * @return A new Iterator
     */
    static &lt;T&gt; Iterator&lt;T&gt; of(T element) {
<span class="fc" id="L117">        return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L119">            boolean hasNext = true;</span>

            @Override
            public boolean hasNext() {
<span class="fc" id="L123">                return hasNext;</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L128">                hasNext = false;</span>
<span class="fc" id="L129">                return element;</span>
            }
        };
    }

    /**
     * Creates an Iterator which traverses the given elements.
     *
     * @param elements Zero or more elements
     * @param &lt;T&gt;      Component type
     * @return A new Iterator
     */
    @SafeVarargs
    static &lt;T&gt; Iterator&lt;T&gt; of(T... elements) {
<span class="fc" id="L143">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (elements.length == 0) {</span>
<span class="fc" id="L145">            return Iterator.empty();</span>
        } else {
<span class="fc" id="L147">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L149">                int index = 0;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L153" title="All 2 branches covered.">                    return index &lt; elements.length;</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L158">                    return elements[index++];</span>
                }
            };
        }
    }

    /**
     * Creates an Iterator based on the given Iterable. This is a convenience method for
     * {@code Iterator.of(iterable.iterator()}.
     *
     * @param iterable A {@link Iterable}
     * @param &lt;T&gt;      Component type.
     * @return A new {@code javaslang.collection.Iterator}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Iterator&lt;T&gt; ofAll(Iterable&lt;? extends T&gt; iterable) {
<span class="fc" id="L174">        Objects.requireNonNull(iterable, &quot;iterable is null&quot;);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (iterable instanceof Iterator) {</span>
<span class="fc" id="L176">            return (Iterator&lt;T&gt;) iterable;</span>
        } else {
<span class="fc" id="L178">            return Iterator.ofAll(iterable.iterator());</span>
        }
    }

    /**
     * Creates an Iterator based on the given Iterator by
     * delegating calls of {@code hasNext()} and {@code next()} to it.
     *
     * @param iterator A {@link java.util.Iterator}
     * @param &lt;T&gt;      Component type.
     * @return A new {@code javaslang.collection.Iterator}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Iterator&lt;T&gt; ofAll(java.util.Iterator&lt;? extends T&gt; iterator) {
<span class="fc" id="L192">        Objects.requireNonNull(iterator, &quot;iterator is null&quot;);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (iterator instanceof Iterator) {</span>
<span class="fc" id="L194">            return (Iterator&lt;T&gt;) iterator;</span>
        } else {
<span class="fc" id="L196">            return new AbstractIterator&lt;T&gt;() {</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L200">                    return iterator.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L205">                    return iterator.next();</span>
                }
            };
        }
    }

    /**
     * Creates an Iterator based on the elements of a boolean array.
     *
     * @param array a boolean array
     * @return A new Iterator of Boolean values
     */
    static Iterator&lt;Boolean&gt; ofAll(boolean[] array) {
<span class="fc" id="L218">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L219">        return new AbstractIterator&lt;Boolean&gt;() {</span>
<span class="fc" id="L220">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L224" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Boolean getNext() {
<span class="fc" id="L229">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of a byte array.
     *
     * @param array a byte array
     * @return A new Iterator of Byte values
     */
    static Iterator&lt;Byte&gt; ofAll(byte[] array) {
<span class="fc" id="L241">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L242">        return new AbstractIterator&lt;Byte&gt;() {</span>
<span class="fc" id="L243">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L247" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Byte getNext() {
<span class="fc" id="L252">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of a char array.
     *
     * @param array a char array
     * @return A new Iterator of Character values
     */
    static Iterator&lt;Character&gt; ofAll(char[] array) {
<span class="fc" id="L264">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L265">        return new AbstractIterator&lt;Character&gt;() {</span>
<span class="fc" id="L266">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L270" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Character getNext() {
<span class="fc" id="L275">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates ann Iterator based on the elements of a double array.
     *
     * @param array a double array
     * @return A new Iterator of Double values
     */
    static Iterator&lt;Double&gt; ofAll(double[] array) {
<span class="fc" id="L287">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L288">        return new AbstractIterator&lt;Double&gt;() {</span>
<span class="fc" id="L289">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L293" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Double getNext() {
<span class="fc" id="L298">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of a float array.
     *
     * @param array a float array
     * @return A new Iterator of Float values
     */
    static Iterator&lt;Float&gt; ofAll(float[] array) {
<span class="fc" id="L310">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L311">        return new AbstractIterator&lt;Float&gt;() {</span>
<span class="fc" id="L312">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L316" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Float getNext() {
<span class="fc" id="L321">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of an int array.
     *
     * @param array an int array
     * @return A new Iterator of Integer values
     */
    static Iterator&lt;Integer&gt; ofAll(int[] array) {
<span class="fc" id="L333">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L334">        return new AbstractIterator&lt;Integer&gt;() {</span>
<span class="fc" id="L335">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L339" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Integer getNext() {
<span class="fc" id="L344">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of a long array.
     *
     * @param array a long array
     * @return A new Iterator of Long values
     */
    static Iterator&lt;Long&gt; ofAll(long[] array) {
<span class="fc" id="L356">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L357">        return new AbstractIterator&lt;Long&gt;() {</span>
<span class="fc" id="L358">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L362" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Long getNext() {
<span class="fc" id="L367">                return array[i++];</span>
            }
        };
    }

    /**
     * Creates an Iterator based on the elements of a short array.
     *
     * @param array a short array
     * @return A new Iterator of Short values
     */
    static Iterator&lt;Short&gt; ofAll(short[] array) {
<span class="fc" id="L379">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L380">        return new AbstractIterator&lt;Short&gt;() {</span>
<span class="fc" id="L381">            int i = 0;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">                return i &lt; array.length;</span>
            }

            @Override
            public Short getNext() {
<span class="fc" id="L390">                return array[i++];</span>
            }
        };
    }

    /**
     * Returns an Iterator on a sequence of {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     *
     * @param &lt;T&gt; Component type of the Iterator
     * @param n The number of elements
     * @param f The Function computing element values
     * @return An Iterator on a sequence of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code f} is null
     */
    static &lt;T&gt; Iterator&lt;T&gt; tabulate(int n, Function&lt;? super Integer, ? extends T&gt; f) {
<span class="fc" id="L406">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L407">        return Collections.tabulate(n, f);</span>
    }

    /**
     * Returns an Iterator on a sequence of {@code n} values supplied by a given Supplier {@code s}.
     *
     * @param &lt;T&gt; Component type of the Iterator
     * @param n The number of elements
     * @param s The Supplier computing element values
     * @return An iterator on a sequence of {@code n} elements, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code s} is null
     */
    static &lt;T&gt; Iterator&lt;T&gt; fill(int n, Supplier&lt;? extends T&gt; s) {
<span class="fc" id="L420">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L421">        return Collections.fill(n, s);</span>
    }

    /**
     * Creates an Iterator of characters starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.range('a', 'c')  // = ('a', 'b')
     * Iterator.range('c', 'a')  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first character
     * @param toExclusive the successor of the last character
     * @return a range of characters as specified or the empty range if {@code from &gt;= toExclusive}
     */
    static Iterator&lt;Character&gt; range(char from, char toExclusive) {
<span class="fc" id="L440">        return Iterator.rangeBy(from, toExclusive, 1);</span>
    }

    /**
     * Creates an Iterator of characters starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeBy('a', 'c', 1)  // = ('a', 'b')
     * Iterator.rangeBy('a', 'd', 2)  // = ('a', 'c')
     * Iterator.rangeBy('d', 'a', -2) // = ('d', 'b')
     * Iterator.rangeBy('d', 'a', 2)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first character
     * @param toExclusive the successor of the last character if step &amp;gt; 0, the predecessor of the last character if step &amp;lt; 0
     * @param step        the step
     * @return a range of characters as specified or the empty range if {@code (from == toExclusive) || (step * (from - toExclusive) &gt; 0)}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Character&gt; rangeBy(char from, char toExclusive, int step) {
<span class="fc" id="L464">        return Iterator.rangeBy((int) from, (int) toExclusive, step).map(i -&gt; (char) i.shortValue());</span>
    }

    static Iterator&lt;Double&gt; rangeBy(double from, double toExclusive, double step) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (Double.isNaN(from)) {</span>
<span class="fc" id="L469">            throw new IllegalArgumentException(&quot;from is NaN&quot;);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        } else if (Double.isNaN(toExclusive)) {</span>
<span class="fc" id="L471">            throw new IllegalArgumentException(&quot;toExclusive is NaN&quot;);</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">        } else if (Double.isNaN(step)) {</span>
<span class="fc" id="L473">            throw new IllegalArgumentException(&quot;step is NaN&quot;);</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">        } else if (step == 0) {</span>
<span class="fc" id="L475">            throw new IllegalArgumentException(&quot;step cannot be 0&quot;);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">        } else if (step * (from - toExclusive) &gt;= 0) {</span>
<span class="fc" id="L477">            return Iterator.empty();</span>
        } else {
<span class="fc" id="L479">            return new AbstractIterator&lt;Double&gt;() {</span>

<span class="fc" id="L481">                double prev = Double.NaN;</span>
<span class="fc" id="L482">                double curr = from;</span>
<span class="fc" id="L483">                boolean hasNext = true;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L487">                    return hasNext;</span>
                }

                @Override
                public Double getNext() {
<span class="fc" id="L492">                    final double next = curr;</span>
<span class="fc bfc" id="L493" title="All 8 branches covered.">                    if ((step &gt; 0 &amp;&amp; curr + step &gt;= toExclusive) || (step &lt; 0 &amp;&amp; curr + step &lt;= toExclusive)) {</span>
<span class="fc" id="L494">                        hasNext = false;</span>
                    } else {
<span class="fc" id="L496">                        prev = curr;</span>
<span class="fc" id="L497">                        curr += step;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">                        if (curr == prev) {</span>
<span class="fc" id="L499">                            hasNext = false;</span>
                        }
                    }
<span class="fc" id="L502">                    return next;</span>
                }
            };
        }
    }

    /**
     * Creates an Iterator of int numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.range(0, 0)  // = ()
     * Iterator.range(2, 0)  // = ()
     * Iterator.range(-2, 2) // = (-2, -1, 0, 1)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of int values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    static Iterator&lt;Integer&gt; range(int from, int toExclusive) {
<span class="fc" id="L525">        return Iterator.rangeBy(from, toExclusive, 1);</span>
    }

    /**
     * Creates an Iterator of int numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeBy(1, 3, 1)  // = (1, 2)
     * Iterator.rangeBy(1, 4, 2)  // = (1, 3)
     * Iterator.rangeBy(4, 1, -2) // = (4, 2)
     * Iterator.rangeBy(4, 1, 2)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1 if step &amp;gt; 0, the last number - 1 if step &amp;lt; 0
     * @param step        the step
     * @return a range of long values as specified or the empty range if {@code (from == toExclusive) || (step * (from - toExclusive) &gt; 0)}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Integer&gt; rangeBy(int from, int toExclusive, int step) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">        final int one = step &gt; 0 ? 1 : -1;</span>
<span class="fc" id="L550">        return Iterator.rangeClosedBy(from, toExclusive - one, step);</span>
    }

    /**
     * Creates an Iterator of long numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.range(0L, 0L)  // = ()
     * Iterator.range(2L, 0L)  // = ()
     * Iterator.range(-2L, 2L) // = (-2L, -1L, 0L, 1L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of long values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    static Iterator&lt;Long&gt; range(long from, long toExclusive) {
<span class="fc" id="L570">        return Iterator.rangeBy(from, toExclusive, 1);</span>
    }

    /**
     * Creates an Iterator of long numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeBy(1L, 3L, 1L)  // = (1L, 2L)
     * Iterator.rangeBy(1L, 4L, 2L)  // = (1L, 3L)
     * Iterator.rangeBy(4L, 1L, -2L) // = (4L, 2L)
     * Iterator.rangeBy(4L, 1L, 2L)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1 if step &amp;gt; 0, the last number - 1 if step &amp;lt; 0
     * @param step        the step
     * @return a range of long values as specified or the empty range if {@code (from == toExclusive) || (step * (from - toExclusive) &gt; 0)}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Long&gt; rangeBy(long from, long toExclusive, long step) {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        final int one = step &gt; 0 ? 1 : -1;</span>
<span class="fc" id="L595">        return Iterator.rangeClosedBy(from, toExclusive - one, step);</span>
    }

    /**
     * Creates an Iterator of characters starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosed('a', 'c')  // = ('a', 'b', 'c')
     * Iterator.rangeClosed('c', 'a')  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first character
     * @param toInclusive the last character
     * @return a range of characters as specified or the empty range if {@code from &gt; toInclusive}
     */
    static Iterator&lt;Character&gt; rangeClosed(char from, char toInclusive) {
<span class="fc" id="L614">        return Iterator.rangeClosedBy(from, toInclusive, 1);</span>
    }

    /**
     * Creates an Iterator of characters starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosedBy('a', 'c', 1)  // = ('a', 'b', 'c')
     * Iterator.rangeClosedBy('a', 'd', 2)  // = ('a', 'c')
     * Iterator.rangeClosedBy('d', 'a', -2) // = ('d', 'b')
     * Iterator.rangeClosedBy('d', 'a', 2)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first character
     * @param toInclusive the last character
     * @param step        the step
     * @return a range of characters as specified or the empty range if {@code step * (from - toInclusive) &gt; 0}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Character&gt; rangeClosedBy(char from, char toInclusive, int step) {
<span class="fc" id="L638">        return Iterator.rangeClosedBy((int) from, (int) toInclusive, step).map(i -&gt; (char) i.shortValue());</span>
    }

    static Iterator&lt;Double&gt; rangeClosedBy(double from, double toInclusive, double step) {
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (Double.isNaN(from)) {</span>
<span class="fc" id="L643">            throw new IllegalArgumentException(&quot;from is NaN&quot;);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">        } else if (Double.isNaN(toInclusive)) {</span>
<span class="fc" id="L645">            throw new IllegalArgumentException(&quot;toInclusive is NaN&quot;);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">        } else if (Double.isNaN(step)) {</span>
<span class="fc" id="L647">            throw new IllegalArgumentException(&quot;step is NaN&quot;);</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        } else if (step == 0) {</span>
<span class="fc" id="L649">            throw new IllegalArgumentException(&quot;step cannot be 0&quot;);</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        } else if (from == toInclusive) {</span>
<span class="fc" id="L651">            return Iterator.of(from);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        } else if (step * (from - toInclusive) &gt; 0) {</span>
<span class="fc" id="L653">            return Iterator.empty();</span>
        } else {
<span class="fc" id="L655">            return new AbstractIterator&lt;Double&gt;() {</span>

<span class="fc" id="L657">                double prev = Double.NaN;</span>
<span class="fc" id="L658">                double curr = from;</span>
<span class="fc" id="L659">                boolean hasNext = true;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L663">                    return hasNext;</span>
                }

                @Override
                public Double getNext() {
<span class="fc" id="L668">                    final double next = curr;</span>
<span class="fc bfc" id="L669" title="All 8 branches covered.">                    if ((step &gt; 0 &amp;&amp; curr + step &gt; toInclusive) || (step &lt; 0 &amp;&amp; curr + step &lt; toInclusive)) {</span>
<span class="fc" id="L670">                        hasNext = false;</span>
                    } else {
<span class="fc" id="L672">                        prev = curr;</span>
<span class="fc" id="L673">                        curr += step;</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">                        if (curr == prev) {</span>
<span class="fc" id="L675">                            hasNext = false;</span>
                        }
                    }
<span class="fc" id="L678">                    return next;</span>
                }
            };
        }
    }

    /**
     * Creates an Iterator of int numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosed(0, 0)  // = (0)
     * Iterator.rangeClosed(2, 0)  // = ()
     * Iterator.rangeClosed(-2, 2) // = (-2, -1, 0, 1, 2)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of int values as specified or the empty range if {@code from &gt; toInclusive}
     */
    static Iterator&lt;Integer&gt; rangeClosed(int from, int toInclusive) {
<span class="fc" id="L701">        return Iterator.rangeClosedBy(from, toInclusive, 1);</span>
    }

    /**
     * Creates an Iterator of int numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosedBy(1, 3, 1)  // = (1, 2, 3)
     * Iterator.rangeClosedBy(1, 4, 2)  // = (1, 3)
     * Iterator.rangeClosedBy(4, 1, -2) // = (4, 2)
     * Iterator.rangeClosedBy(4, 1, 2)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if {@code step * (from - toInclusive) &gt; 0}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Integer&gt; rangeClosedBy(int from, int toInclusive, int step) {
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (step == 0) {</span>
<span class="fc" id="L726">            throw new IllegalArgumentException(&quot;step cannot be 0&quot;);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">        } else if (from == toInclusive) {</span>
<span class="fc" id="L728">            return Iterator.of(from);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        } else if (Integer.signum(step) * Integer.signum(from - toInclusive) &gt; 0) {</span>
<span class="fc" id="L730">            return Iterator.empty();</span>
        } else {
<span class="fc" id="L732">            return new AbstractIterator&lt;Integer&gt;() {</span>

<span class="fc" id="L734">                int i = from;</span>
<span class="fc" id="L735">                boolean hasNext = true;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L739">                    return hasNext;</span>
                }

                @Override
                public Integer getNext() {
<span class="fc" id="L744">                    final int next = i;</span>
<span class="fc bfc" id="L745" title="All 8 branches covered.">                    if ((step &gt; 0 &amp;&amp; i &gt; toInclusive - step) || (step &lt; 0 &amp;&amp; i &lt; toInclusive - step)) {</span>
<span class="fc" id="L746">                        hasNext = false;</span>
                    } else {
<span class="fc" id="L748">                        i += step;</span>
                    }
<span class="fc" id="L750">                    return next;</span>
                }
            };
        }
    }

    /**
     * Creates an Iterator of long numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosed(0L, 0L)  // = (0L)
     * Iterator.rangeClosed(2L, 0L)  // = ()
     * Iterator.rangeClosed(-2L, 2L) // = (-2L, -1L, 0L, 1L, 2L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of long values as specified or the empty range if {@code from &gt; toInclusive}
     */
    static Iterator&lt;Long&gt; rangeClosed(long from, long toInclusive) {
<span class="fc" id="L773">        return Iterator.rangeClosedBy(from, toInclusive, 1L);</span>
    }

    /**
     * Creates an Iterator of long numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Iterator.rangeClosedBy(1L, 3L, 1L)  // = (1L, 2L, 3L)
     * Iterator.rangeClosedBy(1L, 4L, 2L)  // = (1L, 3L)
     * Iterator.rangeClosedBy(4L, 1L, -2L) // = (4L, 2L)
     * Iterator.rangeClosedBy(4L, 1L, 2L)  // = ()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if {@code step * (from - toInclusive) &gt; 0}.
     * @throws IllegalArgumentException if {@code step} is zero
     */
    static Iterator&lt;Long&gt; rangeClosedBy(long from, long toInclusive, long step) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (step == 0L) {</span>
<span class="fc" id="L798">            throw new IllegalArgumentException(&quot;step cannot be 0&quot;);</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">        } else if (from == toInclusive) {</span>
<span class="fc" id="L800">            return Iterator.of(from);</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">        } else if (Long.signum(step) * Long.signum(from - toInclusive) &gt; 0L) {</span>
<span class="fc" id="L802">            return Iterator.empty();</span>
        } else {
<span class="fc" id="L804">            return new AbstractIterator&lt;Long&gt;() {</span>

<span class="fc" id="L806">                long i = from;</span>
<span class="fc" id="L807">                boolean hasNext = true;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L811">                    return hasNext;</span>
                }

                @Override
                public Long getNext() {
<span class="fc" id="L816">                    final long next = i;</span>
<span class="fc bfc" id="L817" title="All 8 branches covered.">                    if ((step &gt; 0L &amp;&amp; i &gt; toInclusive - step) || (step &lt; 0L &amp;&amp; i &lt; toInclusive - step)) {</span>
<span class="fc" id="L818">                        hasNext = false;</span>
                    } else {
<span class="fc" id="L820">                        i += step;</span>
                    }
<span class="fc" id="L822">                    return next;</span>
                }
            };
        }
    }

    /**
     * Returns an infinitely iterator of int values starting from {@code from}.
     * &lt;p&gt;
     * The {@code Iterator} extends to {@code Integer.MIN_VALUE} when passing {@code Integer.MAX_VALUE}.
     *
     * @param value a start int value
     * @return a new {@code Iterator} of int values starting from {@code from}
     */
    static Iterator&lt;Integer&gt; from(int value) {
<span class="fc" id="L837">        return new AbstractIterator&lt;Integer&gt;() {</span>
<span class="fc" id="L838">            private int next = value;</span>

            @Override
            public boolean hasNext() {
<span class="fc" id="L842">                return true;</span>
            }

            @Override
            public Integer getNext() {
<span class="fc" id="L847">                return next++;</span>
            }
        };
    }

    /**
     * Returns an infinitely iterator of long values starting from {@code from}.
     * &lt;p&gt;
     * The {@code Iterator} extends to {@code Long.MIN_VALUE} when passing {@code Long.MAX_VALUE}.
     *
     * @param value a start long value
     * @return a new {@code Iterator} of long values starting from {@code from}
     */
    static Iterator&lt;Long&gt; from(long value) {
<span class="fc" id="L861">        return new AbstractIterator&lt;Long&gt;() {</span>
<span class="fc" id="L862">            private long next = value;</span>

            @Override
            public boolean hasNext() {
<span class="fc" id="L866">                return true;</span>
            }

            @Override
            public Long getNext() {
<span class="fc" id="L871">                return next++;</span>
            }
        };
    }

    /**
     * Generates an infinitely iterator using a value Supplier.
     *
     * @param supplier A Supplier of iterator values
     * @param &lt;T&gt;      value type
     * @return A new {@code Iterator}
     */
    static &lt;T&gt; Iterator&lt;T&gt; gen(Supplier&lt;? extends T&gt; supplier) {
<span class="fc" id="L884">        Objects.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc" id="L885">        return new AbstractIterator&lt;T&gt;() {</span>
            @Override
            public boolean hasNext() {
<span class="fc" id="L888">                return true;</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L893">                return supplier.get();</span>
            }
        };
    }

    /**
     * Generates an infinitely iterator using a function to calculate the next value
     * based on the previous.
     *
     * @param seed The first value in the iterator
     * @param f    A function to calculate the next value based on the previous
     * @param &lt;T&gt;  value type
     * @return A new {@code Iterator}
     */
    static &lt;T&gt; Iterator&lt;T&gt; gen(T seed, Function&lt;? super T, ? extends T&gt; f) {
<span class="fc" id="L908">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L909">        return new AbstractIterator&lt;T&gt;() {</span>
<span class="fc" id="L910">            T next = seed;</span>

            @Override
            public boolean hasNext() {
<span class="fc" id="L914">                return true;</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L919">                T result = next;</span>
<span class="fc" id="L920">                next = f.apply(next);</span>
<span class="fc" id="L921">                return result;</span>
            }
        };
    }

    /**
     * Repeats an element infinitely often.
     *
     * @param t   An element
     * @param &lt;T&gt; Element type
     * @return A new Iterator containing infinite {@code t}'s.
     */
    static &lt;T&gt; Iterator&lt;T&gt; repeat(T t) {
<span class="fc" id="L934">        return new AbstractIterator&lt;T&gt;() {</span>
            @Override
            public boolean hasNext() {
<span class="fc" id="L937">                return true;</span>
            }

            @Override
            public T getNext() {
<span class="fc" id="L942">                return t;</span>
            }
        };
    }

    // -- Additional methods of Iterator

    // DEV-NOTE: cannot use arg Iterable, it would be ambiguous
    default Iterator&lt;T&gt; concat(java.util.Iterator&lt;T&gt; that) {
<span class="fc" id="L951">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        if (!that.hasNext()) {</span>
<span class="fc" id="L953">            return this;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">        } else if (!hasNext()) {</span>
<span class="fc" id="L955">            return Iterator.ofAll(that);</span>
        } else {
<span class="fc" id="L957">            return Iterator.concat(this, Iterator.ofAll(that));</span>
        }
    }

    /**
     * Inserts an element between all elements of this Iterator.
     *
     * @param element An element.
     * @return an interspersed version of this
     */
    default Iterator&lt;T&gt; intersperse(T element) {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L969">            return empty();</span>
        } else {
<span class="fc" id="L971">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L972">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L974">                boolean insertElement = false;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L978">                    return that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc bfc" id="L983" title="All 2 branches covered.">                    if (insertElement) {</span>
<span class="fc" id="L984">                        insertElement = false;</span>
<span class="fc" id="L985">                        return element;</span>
                    } else {
<span class="fc" id="L987">                        insertElement = true;</span>
<span class="fc" id="L988">                        return that.next();</span>
                    }
                }
            };
        }
    }

    /**
     * Transforms this {@code Iterator}.
     *
     * @param f   A transformation
     * @param &lt;U&gt; Type of transformation result
     * @return An instance of type {@code U}
     * @throws NullPointerException if {@code f} is null
     */
    default &lt;U&gt; U transform(Function&lt;? super Iterator&lt;? super T&gt;, ? extends U&gt; f) {
<span class="fc" id="L1004">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L1005">        return f.apply(this);</span>
    }

    @Override
    default &lt;U&gt; Iterator&lt;Tuple2&lt;T, U&gt;&gt; zip(Iterable&lt;U&gt; that) {
<span class="fc" id="L1010">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1012">            return empty();</span>
        } else {
<span class="fc" id="L1014">            final Iterator&lt;T&gt; it1 = this;</span>
<span class="fc" id="L1015">            final java.util.Iterator&lt;U&gt; it2 = that.iterator();</span>
<span class="fc" id="L1016">            return new AbstractIterator&lt;Tuple2&lt;T, U&gt;&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1019" title="All 4 branches covered.">                    return it1.hasNext() &amp;&amp; it2.hasNext();</span>
                }

                @Override
                public Tuple2&lt;T, U&gt; getNext() {
<span class="fc" id="L1024">                    return Tuple.of(it1.next(), it2.next());</span>
                }
            };
        }
    }

    @Override
    default &lt;U&gt; Iterator&lt;Tuple2&lt;T, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, T thisElem, U thatElem) {
<span class="fc" id="L1032">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L1033">        final java.util.Iterator&lt;U&gt; thatIt = that.iterator();</span>
<span class="fc bfc" id="L1034" title="All 4 branches covered.">        if (isEmpty() &amp;&amp; !thatIt.hasNext()) {</span>
<span class="fc" id="L1035">            return empty();</span>
        } else {
<span class="fc" id="L1037">            final Iterator&lt;T&gt; thisIt = this;</span>
<span class="fc" id="L1038">            return new AbstractIterator&lt;Tuple2&lt;T, U&gt;&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1041" title="All 4 branches covered.">                    return thisIt.hasNext() || thatIt.hasNext();</span>
                }

                @Override
                public Tuple2&lt;T, U&gt; getNext() {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">                    T v1 = thisIt.hasNext() ? thisIt.next() : thisElem;</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                    U v2 = thatIt.hasNext() ? thatIt.next() : thatElem;</span>
<span class="fc" id="L1048">                    return Tuple.of(v1, v2);</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;Tuple2&lt;T, Integer&gt;&gt; zipWithIndex() {
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1057">            return empty();</span>
        } else {
<span class="fc" id="L1059">            final Iterator&lt;T&gt; it1 = this;</span>
<span class="fc" id="L1060">            return new AbstractIterator&lt;Tuple2&lt;T, Integer&gt;&gt;() {</span>
<span class="fc" id="L1061">                private int index = 0;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L1065">                    return it1.hasNext();</span>
                }

                @Override
                public Tuple2&lt;T, Integer&gt; getNext() {
<span class="fc" id="L1070">                    return Tuple.of(it1.next(), index++);</span>
                }
            };
        }
    }

    @Override
    default &lt;T1, T2&gt; Tuple2&lt;Iterator&lt;T1&gt;, Iterator&lt;T2&gt;&gt; unzip(
            Function&lt;? super T, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L1079">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1081">            return Tuple.of(empty(), empty());</span>
        } else {
<span class="fc" id="L1083">            final Stream&lt;Tuple2&lt;? extends T1, ? extends T2&gt;&gt; source = Stream.ofAll(this.map(unzipper));</span>
<span class="fc" id="L1084">            return Tuple.of(source.map(t -&gt; (T1) t._1).iterator(), source.map(t -&gt; (T2) t._2).iterator());</span>
        }
    }

    @Override
    default &lt;T1, T2, T3&gt; Tuple3&lt;Iterator&lt;T1&gt;, Iterator&lt;T2&gt;, Iterator&lt;T3&gt;&gt; unzip3(
            Function&lt;? super T, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L1091">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1093">            return Tuple.of(empty(), empty(), empty());</span>
        } else {
<span class="fc" id="L1095">            final Stream&lt;Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; source = Stream.ofAll(this.map(unzipper));</span>
<span class="fc" id="L1096">            return Tuple.of(source.map(t -&gt; (T1) t._1).iterator(), source.map(t -&gt; (T2) t._2).iterator(), source.map(t -&gt; (T3) t._3).iterator());</span>
        }
    }

    // -- Overridden methods of Traversable

    @Override
    default Iterator&lt;T&gt; clear() {
<span class="fc" id="L1104">        return empty();</span>
    }

    @Override
    default Iterator&lt;T&gt; distinct() {
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1110">            return empty();</span>
        } else {
<span class="fc" id="L1112">            return new DistinctIterator&lt;&gt;(this, HashSet.empty(), Function.identity());</span>
        }
    }

    @Override
    default Iterator&lt;T&gt; distinctBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L1118">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1120">            return empty();</span>
        } else {
<span class="fc" id="L1122">            return new DistinctIterator&lt;&gt;(this, TreeSet.empty(comparator), Function.identity());</span>
        }
    }

    @Override
    default &lt;U&gt; Iterator&lt;T&gt; distinctBy(Function&lt;? super T, ? extends U&gt; keyExtractor) {
<span class="fc" id="L1128">        Objects.requireNonNull(keyExtractor, &quot;keyExtractor is null&quot;);</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1130">            return empty();</span>
        } else {
<span class="fc" id="L1132">            return new DistinctIterator&lt;&gt;(this, HashSet.empty(), keyExtractor);</span>
        }
    }

    /**
     * Removes up to n elements from this iterator.
     *
     * @param n A number
     * @return The empty iterator, if {@code n &lt;= 0} or this is empty, otherwise a new iterator without the first n elements.
     */
    @Override
    default Iterator&lt;T&gt; drop(int n) {
<span class="fc bfc" id="L1144" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L1145">            return this;</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">        } else if (!hasNext()) {</span>
<span class="fc" id="L1147">            return empty();</span>
        } else {
<span class="fc" id="L1149">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1150">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1152">                int count = n;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1156" title="All 4 branches covered.">                    while (count &gt; 0 &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1157">                        that.next(); // discarded</span>
<span class="fc" id="L1158">                        count--;</span>
                    }
<span class="fc" id="L1160">                    return that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1165">                    return that.next();</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; dropRight(int n) {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L1174">            return this;</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">        } else if (!hasNext()) {</span>
<span class="fc" id="L1176">            return empty();</span>
        } else {
<span class="fc" id="L1178">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1179">            return new AbstractIterator&lt;T&gt;() {</span>
<span class="fc" id="L1180">                private Queue&lt;T&gt; queue = Queue.empty();</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1184" title="All 4 branches covered.">                    while (queue.length() &lt; n &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1185">                        queue = queue.append(that.next());</span>
                    }
<span class="fc bfc" id="L1187" title="All 4 branches covered.">                    return queue.length() == n &amp;&amp; that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1192">                    Tuple2&lt;T, Queue&lt;T&gt;&gt; t = queue.append(that.next()).dequeue();</span>
<span class="fc" id="L1193">                    queue = t._2;</span>
<span class="fc" id="L1194">                    return t._1;</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; dropUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1202">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1203">        return dropWhile(predicate.negate());</span>
    }

    @Override
    default Iterator&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1208">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L1209" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1210">            return empty();</span>
        } else {
<span class="fc" id="L1212">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1213">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1215">                private T next = null;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1219" title="All 4 branches covered.">                    while (next == null &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1220">                        final T value = that.next();</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">                        if (!predicate.test(value)) {</span>
<span class="fc" id="L1222">                            next = value;</span>
                        }
<span class="fc" id="L1224">                    }</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">                    return next != null;</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1230">                    final T result = next;</span>
<span class="fc" id="L1231">                    next = null;</span>
<span class="fc" id="L1232">                    return result;</span>
                }
            };
        }
    }

    /**
     * Returns an Iterator that contains elements that satisfy the given {@code predicate}.
     *
     * @param predicate A predicate
     * @return A new Iterator
     */
    @Override
    default Iterator&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1246">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1248">            return empty();</span>
        } else {
<span class="fc" id="L1250">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1251">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1253">                Option&lt;T&gt; next = Option.none();</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1257" title="All 4 branches covered.">                    while (next.isEmpty() &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1258">                        final T candidate = that.next();</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">                        if (predicate.test(candidate)) {</span>
<span class="fc" id="L1260">                            next = Option.some(candidate);</span>
                        }
<span class="fc" id="L1262">                    }</span>
<span class="fc" id="L1263">                    return next.isDefined();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1268">                    T result = next.get();</span>
<span class="fc" id="L1269">                    next = Option.none();</span>
<span class="fc" id="L1270">                    return result;</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1278">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1279">        return filter(predicate.negate());</span>
    }

    @Override
    default Option&lt;T&gt; findLast(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1284">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1285">        T last = null;</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">        while (hasNext()) {</span>
<span class="fc" id="L1287">            final T elem = next();</span>
<span class="fc bfc" id="L1288" title="All 2 branches covered.">            if (predicate.test(elem)) {</span>
<span class="fc" id="L1289">                last = elem;</span>
            }
<span class="fc" id="L1291">        }</span>
<span class="fc" id="L1292">        return Option.of(last);</span>
    }

    /**
     * FlatMaps the elements of this Iterator to Iterables, which are iterated in the order of occurrence.
     *
     * @param mapper A mapper
     * @param &lt;U&gt;    Component type
     * @return A new Iterable
     */
    @Override
    default &lt;U&gt; Iterator&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L1304">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L1306">            return empty();</span>
        } else {
<span class="fc" id="L1308">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1309">            return new AbstractIterator&lt;U&gt;() {</span>

<span class="fc" id="L1311">                final Iterator&lt;? extends T&gt; inputs = that;</span>
<span class="fc" id="L1312">                java.util.Iterator&lt;? extends U&gt; current = java.util.Collections.emptyIterator();</span>

                @Override
                public boolean hasNext() {
                    boolean currentHasNext;
<span class="fc bfc" id="L1317" title="All 4 branches covered.">                    while (!(currentHasNext = current.hasNext()) &amp;&amp; inputs.hasNext()) {</span>
<span class="fc" id="L1318">                        current = mapper.apply(inputs.next()).iterator();</span>
                    }
<span class="fc" id="L1320">                    return currentHasNext;</span>
                }

                @Override
                public U getNext() {
<span class="fc" id="L1325">                    return current.next();</span>
                }
            };
        }
    }
    
    @Override
    default &lt;U&gt; U foldRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; f) {
<span class="fc" id="L1333">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L1334">        return Stream.ofAll(this).foldRight(zero, f);</span>
    }

    @Override
    default T get() {
<span class="fc" id="L1339">        return head();</span>
    }

    @Override
    default &lt;C&gt; Map&lt;C, Iterator&lt;T&gt;&gt; groupBy(Function&lt;? super T, ? extends C&gt; classifier) {
<span class="fc" id="L1344">        Objects.requireNonNull(classifier, &quot;classifier is null&quot;);</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1346">            return HashMap.empty();</span>
        } else {
<span class="fc" id="L1348">            Map&lt;C, Stream&lt;T&gt;&gt; streams = foldLeft(HashMap.empty(), (map, entry) -&gt; {</span>
<span class="fc" id="L1349">                final C key = classifier.apply(entry);</span>
<span class="fc" id="L1350">                final Stream&lt;T&gt; values = map.get(key).map(entries -&gt; entries.append(entry)).orElse(Stream.of(entry));</span>
<span class="fc" id="L1351">                return map.put(key, values);</span>
            });
<span class="fc" id="L1353">            return streams.map((c, ts) -&gt; Tuple.of(c, ts.iterator()));</span>
        }
    }

    @Override
    default Iterator&lt;Seq&lt;T&gt;&gt; grouped(int size) {
<span class="fc" id="L1359">        return sliding(size, size);</span>
    }

    @Override
    default boolean hasDefiniteSize() {
<span class="fc" id="L1364">        return false;</span>
    }

    @Override
    default T head() {
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1370">            throw new NoSuchElementException(&quot;head() on empty iterator&quot;);</span>
        }
<span class="fc" id="L1372">        return next();</span>
    }

    @Override
    default Option&lt;T&gt; headOption() {
<span class="fc bfc" id="L1377" title="All 2 branches covered.">        return hasNext() ? Option.some(next()) : Option.none();</span>
    }

    @Override
    default Iterator&lt;T&gt; init() {
<span class="fc bfc" id="L1382" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1383">            throw new UnsupportedOperationException();</span>
        } else {
<span class="fc" id="L1385">            return dropRight(1);</span>
        }
    }

    @Override
    default Option&lt;Iterator&lt;T&gt;&gt; initOption() {
<span class="fc bfc" id="L1391" title="All 2 branches covered.">        return hasNext() ? Option.some(init()) : Option.none();</span>
    }

    @Override
    default boolean isEmpty() {
<span class="fc bfc" id="L1396" title="All 2 branches covered.">        return !hasNext();</span>
    }

    @Override
    default boolean isTraversableAgain() {
<span class="fc" id="L1401">        return false;</span>
    }

    @Override
    default Iterator&lt;T&gt; iterator() {
<span class="fc" id="L1406">        return this;</span>
    }

    @Override
    default int length() {
<span class="fc" id="L1411">        return foldLeft(0, (n, ignored) -&gt; n + 1);</span>
    }

    /**
     * Maps the elements of this Iterator lazily using the given {@code mapper}.
     *
     * @param mapper A mapper.
     * @param &lt;U&gt;    Component type
     * @return A new Iterator
     */
    @Override
    default &lt;U&gt; Iterator&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L1423">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1425">            return empty();</span>
        } else {
<span class="fc" id="L1427">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1428">            return new AbstractIterator&lt;U&gt;() {</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L1432">                    return that.hasNext();</span>
                }

                @Override
                public U getNext() {
<span class="fc" id="L1437">                    return mapper.apply(that.next());</span>
                }
            };
        }
    }

    @Override
    default Match.MatchMonad.Of&lt;Iterator&lt;T&gt;&gt; match() {
<span class="fc" id="L1445">        return Match.of(this);</span>
    }

    @Override
    default Tuple2&lt;Iterator&lt;T&gt;, Iterator&lt;T&gt;&gt; partition(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1450">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1452">            return Tuple.of(empty(), empty());</span>
        } else {
<span class="fc" id="L1454">            final Stream&lt;T&gt; that = Stream.ofAll(this);</span>
<span class="fc" id="L1455">            final Iterator&lt;T&gt; first = that.iterator().filter(predicate);</span>
<span class="fc" id="L1456">            final Iterator&lt;T&gt; second = that.iterator().filter(predicate.negate());</span>
<span class="fc" id="L1457">            return Tuple.of(first, second);</span>
        }
    }

    @Override
    default Iterator&lt;T&gt; peek(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L1463">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1465">            return empty();</span>
        } else {
<span class="fc" id="L1467">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1468">            return new AbstractIterator&lt;T&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc" id="L1471">                    return that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1476">                    final T next = that.next();</span>
<span class="fc" id="L1477">                    action.accept(next);</span>
<span class="fc" id="L1478">                    return next;</span>
                }
            };
        }
    }

    @Override
    default T reduceLeft(BiFunction&lt;? super T, ? super T, ? extends T&gt; op) {
<span class="fc" id="L1486">        Objects.requireNonNull(op, &quot;op is null&quot;);</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1488">            throw new NoSuchElementException(&quot;reduceLeft on Nil&quot;);</span>
        } else {
<span class="fc" id="L1490">            Stream&lt;T&gt; stream = Stream.ofAll(this);</span>
<span class="fc" id="L1491">            return stream.tail().foldLeft(stream.head(), op);</span>
        }
    }

    @Override
    default T reduceRight(BiFunction&lt;? super T, ? super T, ? extends T&gt; op) {
<span class="fc" id="L1497">        Objects.requireNonNull(op, &quot;op is null&quot;);</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1499">            throw new NoSuchElementException(&quot;reduceRight on Nil&quot;);</span>
        } else {
<span class="fc" id="L1501">            Stream&lt;T&gt; reversed = Stream.ofAll(this).reverse();</span>
<span class="fc" id="L1502">            return reversed.tail().foldLeft(reversed.head(), (xs, x) -&gt; op.apply(x, xs));</span>
        }
    }

    @Override
    default Iterator&lt;T&gt; replace(T currentElement, T newElement) {
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1509">            return empty();</span>
        } else {
<span class="fc" id="L1511">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1512">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1514">                boolean done = false;</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L1518">                    return that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1523">                    final T elem = that.next();</span>
<span class="fc bfc" id="L1524" title="All 4 branches covered.">                    if (done || !Objects.equals(currentElement, elem)) {</span>
<span class="fc" id="L1525">                        return elem;</span>
                    } else {
<span class="fc" id="L1527">                        done = true;</span>
<span class="fc" id="L1528">                        return newElement;</span>
                    }
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; replaceAll(T currentElement, T newElement) {
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1538">            return empty();</span>
        } else {
<span class="fc" id="L1540">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1541">            return new AbstractIterator&lt;T&gt;() {</span>

                @Override
                public boolean hasNext() {
<span class="fc" id="L1545">                    return that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1550">                    final T elem = that.next();</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">                    if (Objects.equals(currentElement, elem)) {</span>
<span class="fc" id="L1552">                        return newElement;</span>
                    } else {
<span class="fc" id="L1554">                        return elem;</span>
                    }
                }
            };
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    default Iterator&lt;T&gt; retainAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L1564">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
        // DEV-NOTE: Only Eclipse does need this unchecked cast, IntelliJ and javac are fine.
<span class="fc bfc" id="L1566" title="All 2 branches covered.">        return hasNext() ? filter(HashSet.ofAll((Iterable&lt;T&gt;) elements)::contains) : empty();</span>
    }

    @Override
    default Traversable&lt;T&gt; scan(T zero, BiFunction&lt;? super T, ? super T, ? extends T&gt; operation) {
<span class="fc" id="L1571">        return scanLeft(zero, operation);</span>
    }

    @Override
    default &lt;U&gt; Iterator&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; operation) {
<span class="fc" id="L1576">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1578">            return Iterator.of(zero);</span>
        } else {
<span class="fc" id="L1580">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1581">            return new AbstractIterator&lt;U&gt;() {</span>

<span class="fc" id="L1583">                boolean isFirst = true;</span>
<span class="fc" id="L1584">                U acc = zero;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1588" title="All 4 branches covered.">                    return isFirst || that.hasNext();</span>
                }

                @Override
                public U getNext() {
<span class="fc bfc" id="L1593" title="All 2 branches covered.">                    if (isFirst) {</span>
<span class="fc" id="L1594">                        isFirst = false;</span>
<span class="fc" id="L1595">                        return acc;</span>
                    } else {
<span class="fc" id="L1597">                        acc = operation.apply(acc, that.next());</span>
<span class="fc" id="L1598">                        return acc;</span>
                    }
                }
            };
        }
    }

    // not lazy!
    @Override
    default &lt;U&gt; Iterator&lt;U&gt; scanRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; operation) {
<span class="fc" id="L1608">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1610">            return Iterator.of(zero);</span>
        } else {
<span class="fc" id="L1612">            return Collections.scanRight(this, zero, operation, Stream.empty(), Stream::prepend, Stream::iterator);</span>
        }
    }

    @Override
    default Iterator&lt;Seq&lt;T&gt;&gt; sliding(int size) {
<span class="fc" id="L1618">        return sliding(size, 1);</span>
    }

    @Override
    default Iterator&lt;Seq&lt;T&gt;&gt; sliding(int size, int step) {
<span class="fc bfc" id="L1623" title="All 4 branches covered.">        if (size &lt;= 0 || step &lt;= 0) {</span>
<span class="fc" id="L1624">            throw new IllegalArgumentException(String.format(&quot;size: %s or step: %s not positive&quot;, size, step));</span>
        }
<span class="fc bfc" id="L1626" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1627">            return empty();</span>
        } else {
<span class="fc" id="L1629">            final Stream&lt;T&gt; source = Stream.ofAll(this);</span>
<span class="fc" id="L1630">            return new AbstractIterator&lt;Seq&lt;T&gt;&gt;() {</span>
<span class="fc" id="L1631">                private Stream&lt;T&gt; that = source;</span>
<span class="fc" id="L1632">                private IndexedSeq&lt;T&gt; next = null;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1636" title="All 4 branches covered.">                    while (next == null &amp;&amp; !that.isEmpty()) {</span>
<span class="fc" id="L1637">                        final Tuple2&lt;Stream&lt;T&gt;, Stream&lt;T&gt;&gt; split = that.splitAt(size);</span>
<span class="fc" id="L1638">                        next = split._1.toVector();</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">                        that = split._2.isEmpty() ? Stream.&lt;T&gt; empty() : that.drop(step);</span>
<span class="fc" id="L1640">                    }</span>
<span class="fc bfc" id="L1641" title="All 2 branches covered.">                    return next != null;</span>
                }

                @Override
                public IndexedSeq&lt;T&gt; getNext() {
<span class="fc" id="L1646">                    final IndexedSeq&lt;T&gt; result = next;</span>
<span class="fc" id="L1647">                    next = null;</span>
<span class="fc" id="L1648">                    return result;</span>
                }
            };
        }
    }

    @Override
    default Tuple2&lt;Iterator&lt;T&gt;, Iterator&lt;T&gt;&gt; span(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1656">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1658">            return Tuple.of(empty(), empty());</span>
        } else {
<span class="fc" id="L1660">            Stream&lt;T&gt; that = Stream.ofAll(this);</span>
<span class="fc" id="L1661">            return Tuple.of(that.iterator().takeWhile(predicate), that.iterator().dropWhile(predicate));</span>
        }
    }

    @Override
    default Spliterator&lt;T&gt; spliterator() {
        // the focus of the Stream API is on random-access collections of *known size*
<span class="fc" id="L1668">        Stream&lt;T&gt; stream = Stream.ofAll(this);</span>
<span class="fc" id="L1669">        return Spliterators.spliterator(stream.iterator(), stream.length(),</span>
                Spliterator.ORDERED | Spliterator.IMMUTABLE);
    }

    @Override
    default String stringPrefix() {
<span class="fc" id="L1675">        return &quot;Iterator&quot;;</span>
    }

    @Override
    default Iterator&lt;T&gt; tail() {
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1681">            throw new UnsupportedOperationException();</span>
        } else {
<span class="fc" id="L1683">            next(); // remove first element</span>
<span class="fc" id="L1684">            return this;</span>
        }
    }

    @Override
    default Option&lt;Iterator&lt;T&gt;&gt; tailOption() {
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        if (hasNext()) {</span>
<span class="fc" id="L1691">            next();</span>
<span class="fc" id="L1692">            return Option.some(this);</span>
        } else {
<span class="fc" id="L1694">            return Option.none();</span>
        }
    }

    /**
     * Take the first n elements from this iterator.
     *
     * @param n A number
     * @return The empty iterator, if {@code n &lt;= 0} or this is empty, otherwise a new iterator without the first n elements.
     */
    @Override
    default Iterator&lt;T&gt; take(int n) {
<span class="fc bfc" id="L1706" title="All 4 branches covered.">        if (n &lt;= 0 || !hasNext()) {</span>
<span class="fc" id="L1707">            return empty();</span>
        } else {
<span class="fc" id="L1709">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1710">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1712">                int count = n;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1716" title="All 4 branches covered.">                    return count &gt; 0 &amp;&amp; that.hasNext();</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1721">                    count--;</span>
<span class="fc" id="L1722">                    return that.next();</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; takeRight(int n) {
<span class="fc bfc" id="L1730" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L1731">            return empty();</span>
        } else {
<span class="fc" id="L1733">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1734">            return new AbstractIterator&lt;T&gt;() {</span>
<span class="fc" id="L1735">                private Queue&lt;T&gt; queue = Queue.empty();</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1739" title="All 2 branches covered.">                    while (that.hasNext()) {</span>
<span class="fc" id="L1740">                        queue = queue.enqueue(that.next());</span>
<span class="fc bfc" id="L1741" title="All 2 branches covered.">                        if (queue.length() &gt; n) {</span>
<span class="fc" id="L1742">                            queue = queue.dequeue()._2;</span>
                        }
                    }
<span class="fc bfc" id="L1745" title="All 2 branches covered.">                    return queue.length() &gt; 0;</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1750">                    final Tuple2&lt;T, Queue&lt;T&gt;&gt; t = queue.dequeue();</span>
<span class="fc" id="L1751">                    queue = t._2;</span>
<span class="fc" id="L1752">                    return t._1;</span>
                }
            };
        }
    }

    @Override
    default Iterator&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1760">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L1761">        return takeWhile(predicate.negate());</span>
    }

    @Override
    default Iterator&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L1766">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L1768">            return empty();</span>
        } else {
<span class="fc" id="L1770">            final Iterator&lt;T&gt; that = this;</span>
<span class="fc" id="L1771">            return new AbstractIterator&lt;T&gt;() {</span>

<span class="fc" id="L1773">                private T next = null;</span>
<span class="fc" id="L1774">                private boolean finished = false;</span>

                @Override
                public boolean hasNext() {
<span class="fc bfc" id="L1778" title="All 6 branches covered.">                    while (!finished &amp;&amp; next == null &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1779">                        final T value = that.next();</span>
<span class="fc bfc" id="L1780" title="All 2 branches covered.">                        if (predicate.test(value)) {</span>
<span class="fc" id="L1781">                            next = value;</span>
                        } else {
<span class="fc" id="L1783">                            finished = true;</span>
                        }
<span class="fc" id="L1785">                    }</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">                    return next != null;</span>
                }

                @Override
                public T getNext() {
<span class="fc" id="L1791">                    final T result = next;</span>
<span class="fc" id="L1792">                    next = null;</span>
<span class="fc" id="L1793">                    return result;</span>
                }
            };
        }
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
	@Override
    default &lt;U&gt; Iterator&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="nc bnc" id="L1802" title="All 2 branches missed.">    	if (iterable instanceof Iterator) {</span>
<span class="nc" id="L1803">    		return (Iterator&lt;U&gt;) iterable;</span>
    	} else {
<span class="nc" id="L1805">    		return Iterator.ofAll(iterable.iterator());</span>
    	}
    }
}

interface IteratorModule {

    final class ConcatIterator&lt;T&gt; extends AbstractIterator&lt;T&gt; {

        private final Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators;
        private Iterator&lt;? extends T&gt; current;

<span class="fc" id="L1817">        ConcatIterator(Iterator&lt;? extends Iterator&lt;? extends T&gt;&gt; iterators) {</span>
<span class="fc" id="L1818">            this.current = Iterator.empty();</span>
<span class="fc" id="L1819">            this.iterators = iterators;</span>
<span class="fc" id="L1820">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L1824" title="All 4 branches covered.">            while (!current.hasNext() &amp;&amp; !iterators.isEmpty()) {</span>
<span class="fc" id="L1825">                current = iterators.next();</span>
            }
<span class="fc" id="L1827">            return current.hasNext();</span>
        }

        @Override
        public T getNext() {
<span class="fc" id="L1832">            return current.next();</span>
        }
    }

    final class DistinctIterator&lt;T, U&gt; extends AbstractIterator&lt;T&gt; {

        private final Iterator&lt;? extends T&gt; that;
        private Set&lt;U&gt; known;
        private final Function&lt;? super T, ? extends U&gt; keyExtractor;
<span class="fc" id="L1841">        private T next = null;</span>

<span class="fc" id="L1843">        DistinctIterator(Iterator&lt;? extends T&gt; that, Set&lt;U&gt; set, Function&lt;? super T, ? extends U&gt; keyExtractor) {</span>
<span class="fc" id="L1844">            this.that = that;</span>
<span class="fc" id="L1845">            this.known = set;</span>
<span class="fc" id="L1846">            this.keyExtractor = keyExtractor;</span>
<span class="fc" id="L1847">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L1851" title="All 4 branches covered.">            while (next == null &amp;&amp; that.hasNext()) {</span>
<span class="fc" id="L1852">                final T elem = that.next();</span>
<span class="fc" id="L1853">                final U key = keyExtractor.apply(elem);</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">                if (!known.contains(key)) {</span>
<span class="fc" id="L1855">                    known = known.add(key);</span>
<span class="fc" id="L1856">                    next = elem;</span>
                }
<span class="fc" id="L1858">            }</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">            return next != null;</span>
        }

        @Override
        public T getNext() {
<span class="fc" id="L1864">            final T result = next;</span>
<span class="fc" id="L1865">            next = null;</span>
<span class="fc" id="L1866">            return result;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>