<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LinkedHashMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">LinkedHashMap.java</span></div><h1>LinkedHashMap.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.control.Match;
import javaslang.control.Option;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Objects;
import java.util.function.*;
import java.util.stream.Collector;

/**
 * An immutable {@code LinkedHashMap} implementation.
 *
 * @author Ruslan Sennov
 * @since 2.0.0
 */
public final class LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Serializable {

    private static final long serialVersionUID = 1L;

<span class="fc" id="L30">    private static final LinkedHashMap&lt;?, ?&gt; EMPTY = new LinkedHashMap&lt;&gt;(Queue.empty(), HashMap.empty());</span>

    private final Queue&lt;Tuple2&lt;K, V&gt;&gt; list;
    private final HashMap&lt;K, V&gt; map;

<span class="fc" id="L35">    private LinkedHashMap(Queue&lt;Tuple2&lt;K, V&gt;&gt; list, HashMap&lt;K, V&gt; map) {</span>
<span class="fc" id="L36">        this.list = list;</span>
<span class="fc" id="L37">        this.map = map;</span>
<span class="fc" id="L38">    }</span>

    /**
     * Returns a {@link java.util.stream.Collector} which may be used in conjunction with
     * {@link java.util.stream.Stream#collect(java.util.stream.Collector)} to obtain a {@link javaslang.collection.LinkedHashMap}.
     *
     * @param &lt;K&gt; The key type
     * @param &lt;V&gt; The value type
     * @return A {@link javaslang.collection.LinkedHashMap} Collector.
     */
    public static &lt;K, V&gt; Collector&lt;Tuple2&lt;K, V&gt;, ArrayList&lt;Tuple2&lt;K, V&gt;&gt;, LinkedHashMap&lt;K, V&gt;&gt; collector() {
<span class="fc" id="L49">        final Supplier&lt;ArrayList&lt;Tuple2&lt;K, V&gt;&gt;&gt; supplier = ArrayList::new;</span>
<span class="fc" id="L50">        final BiConsumer&lt;ArrayList&lt;Tuple2&lt;K, V&gt;&gt;, Tuple2&lt;K, V&gt;&gt; accumulator = ArrayList::add;</span>
<span class="fc" id="L51">        final BinaryOperator&lt;ArrayList&lt;Tuple2&lt;K, V&gt;&gt;&gt; combiner = (left, right) -&gt; {</span>
<span class="fc" id="L52">            left.addAll(right);</span>
<span class="fc" id="L53">            return left;</span>
        };
<span class="fc" id="L55">        final Function&lt;ArrayList&lt;Tuple2&lt;K, V&gt;&gt;, LinkedHashMap&lt;K, V&gt;&gt; finisher = LinkedHashMap::ofEntries;</span>
<span class="fc" id="L56">        return Collector.of(supplier, accumulator, combiner, finisher);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; empty() {
<span class="fc" id="L61">        return (LinkedHashMap&lt;K, V&gt;) EMPTY;</span>
    }

    /**
     * Returns a singleton {@code LinkedHashMap}, i.e. a {@code LinkedHashMap} of one element.
     *
     * @param entry A map entry.
     * @param &lt;K&gt;   The key type
     * @param &lt;V&gt;   The value type
     * @return A new Map containing the given entry
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; of(Tuple2&lt;? extends K, ? extends V&gt; entry) {
<span class="fc" id="L74">        final HashMap&lt;K, V&gt; map = HashMap.of(entry);</span>
<span class="fc" id="L75">        final Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.of((Tuple2&lt;K, V&gt;) entry);</span>
<span class="fc" id="L76">        return new LinkedHashMap&lt;&gt;(list, map);</span>
    }

    /**
     * Creates a LinkedHashMap of the given list of key-value pairs.
     *
     * @param pairs A list of key-value pairs
     * @param &lt;K&gt;   The key type
     * @param &lt;V&gt;   The value type
     * @return A new Map containing the given entries
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; of(Object... pairs) {
<span class="fc" id="L89">        Objects.requireNonNull(pairs, &quot;pairs is null&quot;);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if ((pairs.length &amp; 1) != 0) {</span>
<span class="fc" id="L91">            throw new IllegalArgumentException(&quot;Odd length of key-value pairs list&quot;);</span>
        }
<span class="fc" id="L93">        HashMap&lt;K, V&gt; map = HashMap.empty();</span>
<span class="fc" id="L94">        Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.empty();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for (int i = 0; i &lt; pairs.length; i += 2) {</span>
<span class="fc" id="L96">            final K k = (K) pairs[i];</span>
<span class="fc" id="L97">            final V v = (V) pairs[i + 1];</span>
<span class="fc" id="L98">            map = map.put(k, v);</span>
<span class="fc" id="L99">            list = list.append(Tuple.of(k, v));</span>
        }
<span class="fc" id="L101">        return wrap(list, map);</span>
    }

    /**
     * Returns a {@code LinkedHashMap}, from a source java.util.Map.
     *
     * @param map A map entry.
     * @param &lt;K&gt; The key type
     * @param &lt;V&gt; The value type
     * @return A new Map containing the given map
     */
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; ofAll(java.util.Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L113">        Objects.requireNonNull(map, &quot;map is null&quot;);</span>
<span class="fc" id="L114">        LinkedHashMap&lt;K, V&gt; result = LinkedHashMap.empty();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (java.util.Map.Entry&lt;? extends K, ? extends V&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L116">            result = result.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L117">        }</span>
<span class="fc" id="L118">        return result;</span>
    }

    /**
     * Returns a singleton {@code LinkedHashMap}, i.e. a {@code LinkedHashMap} of one element.
     *
     * @param key   A singleton map key.
     * @param value A singleton map value.
     * @param &lt;K&gt;   The key type
     * @param &lt;V&gt;   The value type
     * @return A new Map containing the given entry
     */
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; of(K key, V value) {
<span class="fc" id="L131">        final HashMap&lt;K, V&gt; map = HashMap.of(key, value);</span>
<span class="fc" id="L132">        final Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.of(Tuple.of(key, value));</span>
<span class="fc" id="L133">        return new LinkedHashMap&lt;&gt;(list, map);</span>
    }

    /**
     * Returns a LinkedHashMap containing {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     *
     * @param &lt;K&gt; The key type
     * @param &lt;V&gt; The value type
     * @param n The number of elements in the LinkedHashMap
     * @param f The Function computing element values
     * @return A LinkedHashMap consisting of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code f} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; tabulate(int n, Function&lt;? super Integer, ? extends Tuple2&lt;? extends K, ? extends V&gt;&gt; f) {
<span class="fc" id="L149">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L150">        return ofEntries(Collections.tabulate(n, (Function&lt;? super Integer, ? extends Tuple2&lt;K, V&gt;&gt;) f));</span>
    }

    /**
     * Returns a LinkedHashMap containing {@code n} values supplied by a given Supplier {@code s}.
     *
     * @param &lt;K&gt; The key type
     * @param &lt;V&gt; The value type
     * @param n The number of elements in the LinkedHashMap
     * @param s The Supplier computing element values
     * @return A LinkedHashMap of size {@code n}, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code s} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; fill(int n, Supplier&lt;? extends Tuple2&lt;? extends K, ? extends V&gt;&gt; s) {
<span class="fc" id="L165">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L166">        return ofEntries(Collections.fill(n, (Supplier&lt;? extends Tuple2&lt;K, V&gt;&gt;) s));</span>
    }

    /**
     * Creates a LinkedHashMap of the given entries.
     *
     * @param entries Map entries
     * @param &lt;K&gt;     The key type
     * @param &lt;V&gt;     The value type
     * @return A new Map containing the given entries
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; ofEntries(java.util.Map.Entry&lt;? extends K, ? extends V&gt;... entries) {
<span class="fc" id="L179">        HashMap&lt;K, V&gt; map = HashMap.empty();</span>
<span class="fc" id="L180">        Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.empty();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (java.util.Map.Entry&lt;? extends K, ? extends V&gt; entry : entries) {</span>
<span class="fc" id="L182">            final Tuple2&lt;K, V&gt; tuple = Tuple.of(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L183">            map = map.put(tuple);</span>
<span class="fc" id="L184">            list = list.append(tuple);</span>
        }
<span class="fc" id="L186">        return wrap(list, map);</span>
    }

    /**
     * Creates a LinkedHashMap of the given entries.
     *
     * @param entries Map entries
     * @param &lt;K&gt;     The key type
     * @param &lt;V&gt;     The value type
     * @return A new Map containing the given entries
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; ofEntries(Tuple2&lt;? extends K, ? extends V&gt;... entries) {
<span class="fc" id="L199">        final HashMap&lt;K, V&gt; map = HashMap.ofEntries(entries);</span>
<span class="fc" id="L200">        final Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.of((Tuple2&lt;K, V&gt;[]) entries);</span>
<span class="fc" id="L201">        return wrap(list, map);</span>
    }

    /**
     * Creates a LinkedHashMap of the given entries.
     *
     * @param entries Map entries
     * @param &lt;K&gt;     The key type
     * @param &lt;V&gt;     The value type
     * @return A new Map containing the given entries
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; ofEntries(Iterable&lt;? extends Tuple2&lt;? extends K, ? extends V&gt;&gt; entries) {
<span class="fc" id="L214">        Objects.requireNonNull(entries, &quot;entries is null&quot;);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (entries instanceof LinkedHashMap) {</span>
<span class="fc" id="L216">            return (LinkedHashMap&lt;K, V&gt;) entries;</span>
        } else {
<span class="fc" id="L218">            HashMap&lt;K, V&gt; map = HashMap.empty();</span>
<span class="fc" id="L219">            Queue&lt;Tuple2&lt;K, V&gt;&gt; list = Queue.empty();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            for (Tuple2&lt;? extends K, ? extends V&gt; entry : entries) {</span>
<span class="fc" id="L221">                map = map.put(entry);</span>
<span class="fc" id="L222">                list = list.append((Tuple2&lt;K, V&gt;) entry);</span>
<span class="fc" id="L223">            }</span>
<span class="fc" id="L224">            return wrap(list, map);</span>
        }
    }

    @Override
    public &lt;K2, V2&gt; LinkedHashMap&lt;K2, V2&gt; bimap(Function&lt;? super K, ? extends K2&gt; keyMapper, Function&lt;? super V, ? extends V2&gt; valueMapper) {
<span class="nc" id="L230">        Objects.requireNonNull(keyMapper, &quot;keyMapper is null&quot;);</span>
<span class="nc" id="L231">        Objects.requireNonNull(valueMapper, &quot;valueMapper is null&quot;);</span>
<span class="nc" id="L232">        final Iterator&lt;Tuple2&lt;K2, V2&gt;&gt; entries = iterator().map(entry -&gt; Tuple.of(keyMapper.apply(entry._1), valueMapper.apply(entry._2)));</span>
<span class="nc" id="L233">        return LinkedHashMap.ofEntries(entries);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; clear() {
<span class="fc" id="L238">        return LinkedHashMap.empty();</span>
    }

    @Override
    public boolean contains(Tuple2&lt;K, V&gt; element) {
<span class="fc" id="L243">        return map.contains(element);</span>
    }

    @Override
    public boolean containsKey(K key) {
<span class="fc" id="L248">        return map.containsKey(key);</span>
    }

    @Override
    public boolean containsValue(V value) {
<span class="fc" id="L253">        return map.containsValue(value);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; distinct() {
<span class="fc" id="L258">        return this;</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; distinctBy(Comparator&lt;? super Tuple2&lt;K, V&gt;&gt; comparator) {
<span class="fc" id="L263">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L264">        return LinkedHashMap.ofEntries(list.distinctBy(comparator));</span>
    }

    @Override
    public &lt;U&gt; LinkedHashMap&lt;K, V&gt; distinctBy(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends U&gt; keyExtractor) {
<span class="fc" id="L269">        Objects.requireNonNull(keyExtractor, &quot;keyExtractor is null&quot;);</span>
<span class="fc" id="L270">        return LinkedHashMap.ofEntries(list.distinctBy(keyExtractor));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; drop(int n) {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L276">            return this;</span>
        }
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L279">            return empty();</span>
        }
<span class="fc" id="L281">        return LinkedHashMap.ofEntries(list.drop(n));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; dropRight(int n) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L287">            return this;</span>
        }
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (n &gt;= length()) {</span>
<span class="fc" id="L290">            return empty();</span>
        }
<span class="fc" id="L292">        return LinkedHashMap.ofEntries(list.dropRight(n));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; dropUntil(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L297">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L298">        return dropWhile(predicate.negate());</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; dropWhile(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L303">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L304">        return LinkedHashMap.ofEntries(list.dropWhile(predicate));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; filter(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L309">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L310">        return LinkedHashMap.ofEntries(list.filter(predicate));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; filterNot(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L315">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L316">        return filter(predicate.negate());</span>
    }

    @Override
    public &lt;K2, V2&gt; LinkedHashMap&lt;K2, V2&gt; flatMap(BiFunction&lt;? super K, ? super V, ? extends Iterable&lt;Tuple2&lt;K2, V2&gt;&gt;&gt; mapper) {
<span class="fc" id="L321">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L322">        return foldLeft(LinkedHashMap.&lt;K2, V2&gt; empty(), (acc, entry) -&gt; {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            for (Tuple2&lt;? extends K2, ? extends V2&gt; mappedEntry : mapper.apply(entry._1, entry._2)) {</span>
<span class="fc" id="L324">                acc = acc.put(mappedEntry);</span>
<span class="fc" id="L325">            }</span>
<span class="fc" id="L326">            return acc;</span>
        });
    }

    @Override
    public &lt;U&gt; U foldRight(U zero, BiFunction&lt;? super Tuple2&lt;K, V&gt;, ? super U, ? extends U&gt; f) {
<span class="fc" id="L332">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L333">        return list.foldRight(zero, f);</span>
    }

    @Override
    public Option&lt;V&gt; get(K key) {
<span class="fc" id="L338">        return map.get(key);</span>
    }

    @Override
    public &lt;C&gt; LinkedHashMap&lt;C, LinkedHashMap&lt;K, V&gt;&gt; groupBy(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends C&gt; classifier) {
<span class="fc" id="L343">        Objects.requireNonNull(classifier, &quot;classifier is null&quot;);</span>
<span class="fc" id="L344">        return foldLeft(LinkedHashMap.empty(), (map, entry) -&gt; {</span>
<span class="fc" id="L345">            final C key = classifier.apply(entry);</span>
<span class="fc" id="L346">            final LinkedHashMap&lt;K, V&gt; values = map</span>
<span class="fc" id="L347">                    .get(key)</span>
<span class="fc" id="L348">                    .map(entries -&gt; entries.put(entry))</span>
<span class="fc" id="L349">                    .orElse(LinkedHashMap.of(entry));</span>
<span class="fc" id="L350">            return map.put(key, values);</span>
        });
    }

    @Override
    public Iterator&lt;LinkedHashMap&lt;K, V&gt;&gt; grouped(int size) {
<span class="fc" id="L356">        return sliding(size, size);</span>
    }

    @Override
    public boolean hasDefiniteSize() {
<span class="fc" id="L361">        return true;</span>
    }

    @Override
    public Tuple2&lt;K, V&gt; head() {
<span class="fc" id="L366">        return list.head();</span>
    }

    @Override
    public Option&lt;Tuple2&lt;K, V&gt;&gt; headOption() {
<span class="fc" id="L371">        return list.headOption();</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; init() {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L377">            throw new UnsupportedOperationException(&quot;init of empty LinkedHashMap&quot;);</span>
        } else {
<span class="fc" id="L379">            return LinkedHashMap.ofEntries(list.init());</span>
        }
    }

    @Override
    public Option&lt;LinkedHashMap&lt;K, V&gt;&gt; initOption() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L386">            return Option.none();</span>
        } else {
<span class="fc" id="L388">            return Option.some(init());</span>
        }
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L394">        return map.isEmpty();</span>
    }

    @Override
    public boolean isTraversableAgain() {
<span class="fc" id="L399">        return true;</span>
    }

    @Override
    public Iterator&lt;Tuple2&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L404">        return list.iterator();</span>
    }

    @Override
    public Set&lt;K&gt; keySet() {
<span class="fc" id="L409">        return map.keySet();</span>
    }
    
    @Override
    public &lt;K2, V2&gt; LinkedHashMap&lt;K2, V2&gt; map(BiFunction&lt;? super K, ? super V, Tuple2&lt;K2, V2&gt;&gt; mapper) {
<span class="fc" id="L414">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L415">        return foldLeft(LinkedHashMap.empty(), (acc, entry) -&gt; acc.put(entry.map(mapper)));</span>
    }

    @Override
    public &lt;W&gt; LinkedHashMap&lt;K, W&gt; mapValues(Function&lt;? super V, ? extends W&gt; mapper) {
<span class="fc" id="L420">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L421">        return map((k, v) -&gt; Tuple.of(k, mapper.apply(v)));</span>
    }

    @Override
    public Match.MatchMonad.Of&lt;LinkedHashMap&lt;K, V&gt;&gt; match() {
<span class="nc" id="L426">        return Match.of(this);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; merge(Map&lt;? extends K, ? extends V&gt; that) {
<span class="fc" id="L431">        return (LinkedHashMap&lt;K, V&gt;) Collections.mergeMaps(this, that, LinkedHashMap::ofEntries);</span>
    }

    @Override
    public &lt;U extends V&gt; LinkedHashMap&lt;K, V&gt; merge(Map&lt;? extends K, U&gt; that, BiFunction&lt;? super V, ? super U, ? extends V&gt; collisionResolution) {
<span class="fc" id="L436">        return (LinkedHashMap&lt;K, V&gt;) Collections.mergeMaps(this, that, LinkedHashMap::ofEntries, collisionResolution);</span>
    }

    @Override
    public Tuple2&lt;LinkedHashMap&lt;K, V&gt;, LinkedHashMap&lt;K, V&gt;&gt; partition(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L441">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L442">        final Tuple2&lt;Iterator&lt;Tuple2&lt;K, V&gt;&gt;, Iterator&lt;Tuple2&lt;K, V&gt;&gt;&gt; p = iterator().partition(predicate);</span>
<span class="fc" id="L443">        return Tuple.of(LinkedHashMap.ofEntries(p._1), LinkedHashMap.ofEntries(p._2));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; peek(Consumer&lt;? super Tuple2&lt;K, V&gt;&gt; action) {
<span class="fc" id="L448">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if (!isEmpty()) {</span>
<span class="fc" id="L450">            action.accept(list.head());</span>
        }
<span class="fc" id="L452">        return this;</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; put(K key, V value) {
<span class="fc" id="L457">        Queue&lt;Tuple2&lt;K, V&gt;&gt; newList = list;</span>
<span class="fc" id="L458">        HashMap&lt;K, V&gt; newMap = map;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (containsKey(key)) {</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">            newList = newList.filter(t -&gt; !t._1.equals(key));</span>
<span class="fc" id="L461">            newMap = newMap.remove(key);</span>
        }
<span class="fc" id="L463">        newList = newList.append(Tuple.of(key, value));</span>
<span class="fc" id="L464">        newMap = newMap.put(key, value);</span>
<span class="fc" id="L465">        return new LinkedHashMap&lt;&gt;(newList, newMap);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; put(Tuple2&lt;? extends K, ? extends V&gt; entry) {
<span class="fc" id="L470">        return put(entry._1, entry._2);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; remove(K key) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (containsKey(key)) {</span>
<span class="fc" id="L476">            final Queue&lt;Tuple2&lt;K, V&gt;&gt; newList = list.removeFirst(t -&gt; t._1.equals(key));</span>
<span class="fc" id="L477">            final HashMap&lt;K, V&gt; newMap = map.remove(key);</span>
<span class="fc" id="L478">            return wrap(newList, newMap);</span>
        } else {
<span class="fc" id="L480">            return this;</span>
        }
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; removeAll(Iterable&lt;? extends K&gt; keys) {
<span class="fc" id="L486">        Objects.requireNonNull(keys, &quot;keys is null&quot;);</span>
<span class="fc" id="L487">        final HashSet&lt;K&gt; toRemove = HashSet.ofAll(keys);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">        final Queue&lt;Tuple2&lt;K, V&gt;&gt; newList = list.filter(t -&gt; !toRemove.contains(t._1));</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">        final HashMap&lt;K, V&gt; newMap = map.filter(t -&gt; !toRemove.contains(t._1));</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        return newList.size() == size() ? this : wrap(newList, newMap);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; replace(Tuple2&lt;K, V&gt; currentElement, Tuple2&lt;K, V&gt; newElement) {
<span class="fc" id="L495">        Objects.requireNonNull(currentElement, &quot;currentElement is null&quot;);</span>
<span class="fc" id="L496">        Objects.requireNonNull(newElement, &quot;newElement is null&quot;);</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        return containsKey(currentElement._1) ? remove(currentElement._1).put(newElement) : this;</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; replaceAll(Tuple2&lt;K, V&gt; currentElement, Tuple2&lt;K, V&gt; newElement) {
<span class="fc" id="L502">        return replace(currentElement, newElement);</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; retainAll(Iterable&lt;? extends Tuple2&lt;K, V&gt;&gt; elements) {
<span class="fc" id="L507">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L508">        LinkedHashMap&lt;K, V&gt; result = empty();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">        for (Tuple2&lt;K, V&gt; entry : elements) {</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">            if (contains(entry)) {</span>
<span class="fc" id="L511">                result = result.put(entry._1, entry._2);</span>
            }
<span class="fc" id="L513">        }</span>
<span class="fc" id="L514">        return result;</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; scan(Tuple2&lt;K, V&gt; zero, BiFunction&lt;? super Tuple2&lt;K, V&gt;, ? super Tuple2&lt;K, V&gt;, ? extends Tuple2&lt;K, V&gt;&gt; operation) {
<span class="fc" id="L519">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L520">        return Collections.scanLeft(this, zero, operation, LinkedHashMap.empty(), LinkedHashMap::put, Function.identity());</span>
    }

    @Override
    public &lt;U&gt; Seq&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super Tuple2&lt;K, V&gt;, ? extends U&gt; operation) {
<span class="fc" id="L525">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L526">        return Collections.scanLeft(this, zero, operation, List.empty(), List::prepend, List::reverse);</span>
    }

    @Override
    public &lt;U&gt; Seq&lt;U&gt; scanRight(U zero, BiFunction&lt;? super Tuple2&lt;K, V&gt;, ? super U, ? extends U&gt; operation) {
<span class="fc" id="L531">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L532">        return Collections.scanRight(this, zero, operation, List.empty(), List::prepend, Function.identity());</span>
    }

    @Override
    public int size() {
<span class="fc" id="L537">        return map.size();</span>
    }

    @Override
    public Iterator&lt;LinkedHashMap&lt;K, V&gt;&gt; sliding(int size) {
<span class="fc" id="L542">        return sliding(size, 1);</span>
    }

    @Override
    public Iterator&lt;LinkedHashMap&lt;K, V&gt;&gt; sliding(int size, int step) {
<span class="fc" id="L547">        return iterator().sliding(size, step).map(LinkedHashMap::ofEntries);</span>
    }

    @Override
    public Tuple2&lt;LinkedHashMap&lt;K, V&gt;, LinkedHashMap&lt;K, V&gt;&gt; span(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L552">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L553">        final Tuple2&lt;Iterator&lt;Tuple2&lt;K, V&gt;&gt;, Iterator&lt;Tuple2&lt;K, V&gt;&gt;&gt; t = iterator().span(predicate);</span>
<span class="fc" id="L554">        return Tuple.of(LinkedHashMap.ofEntries(t._1), LinkedHashMap.ofEntries(t._2));</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; tail() {
<span class="fc bfc" id="L559" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L560">            throw new UnsupportedOperationException(&quot;tail of empty LinkedHashMap&quot;);</span>
        } else {
<span class="fc" id="L562">            return LinkedHashMap.ofEntries(list.tail());</span>
        }
    }

    @Override
    public Option&lt;LinkedHashMap&lt;K, V&gt;&gt; tailOption() {
<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L569">            return Option.none();</span>
        } else {
<span class="fc" id="L571">            return Option.some(tail());</span>
        }
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; take(int n) {
<span class="fc bfc" id="L577" title="All 2 branches covered.">        if (size() &lt;= n) {</span>
<span class="fc" id="L578">            return this;</span>
        } else {
<span class="fc" id="L580">            return LinkedHashMap.ofEntries(list.take(n));</span>
        }
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; takeRight(int n) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (size() &lt;= n) {</span>
<span class="fc" id="L587">            return this;</span>
        } else {
<span class="fc" id="L589">            return LinkedHashMap.ofEntries(list.takeRight(n));</span>
        }
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; takeUntil(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L595">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L596">        final LinkedHashMap&lt;K, V&gt; taken = LinkedHashMap.ofEntries(list.takeUntil(predicate));</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        return taken.length() == length() ? this : taken;</span>
    }

    @Override
    public LinkedHashMap&lt;K, V&gt; takeWhile(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate) {
<span class="fc" id="L602">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L603">        final LinkedHashMap&lt;K, V&gt; taken = LinkedHashMap.ofEntries(list.takeWhile(predicate));</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        return taken.length() == length() ? this : taken;</span>
    }

    @Override
    public Seq&lt;V&gt; values() {
<span class="fc" id="L609">        return map.values();</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (o == this) {</span>
<span class="fc" id="L615">            return true;</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        } else if (o instanceof LinkedHashMap) {</span>
<span class="fc" id="L617">            final LinkedHashMap&lt;?, ?&gt; that = (LinkedHashMap&lt;?, ?&gt;) o;</span>
<span class="fc" id="L618">            return this.list.equals(that.list);</span>
        } else {
<span class="nc" id="L620">            return false;</span>
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L626">        return list.hashCode();</span>
    }

    private Object readResolve() {
<span class="fc bfc" id="L630" title="All 2 branches covered.">        return isEmpty() ? EMPTY : this;</span>
    }

    @Override
    public String stringPrefix() {
<span class="fc" id="L635">        return &quot;LinkedHashMap&quot;;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L640">        return mkString(stringPrefix() + &quot;(&quot;, &quot;, &quot;, &quot;)&quot;);</span>
    }

    private static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; wrap(Queue&lt;Tuple2&lt;K, V&gt;&gt; list, HashMap&lt;K, V&gt; map) {
<span class="fc bfc" id="L644" title="All 2 branches covered.">        return list.isEmpty() ? empty() : new LinkedHashMap&lt;&gt;(list, map);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>