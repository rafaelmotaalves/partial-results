<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Map.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">Map.java</span></div><h1>Map.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Function1;
import javaslang.Tuple2;
import javaslang.Tuple3;
import javaslang.algebra.BiFunctor;
import javaslang.control.Match;
import javaslang.control.Option;

import java.util.*;
import java.util.function.*;

/**
 * An immutable {@code Map} interface.
 *
 * @param &lt;K&gt; Key type
 * @param &lt;V&gt; Value type
 * @author Daniel Dietrich, Ruslan Sennov
 * @since 2.0.0
 */
public interface Map&lt;K, V&gt; extends Traversable&lt;Tuple2&lt;K, V&gt;&gt;, BiFunctor&lt;K, V&gt;, Function1&lt;K, V&gt; {

    long serialVersionUID = 1L;

    @Override
    default V apply(K key) {
<span class="fc" id="L32">        return get(key).orElseThrow(NoSuchElementException::new);</span>
    }

    /**
     * Maps this {@code Map} to a new {@code Map} with different component type by applying a function to its elements.
     *
     * @param &lt;K2&gt;        key's component type of the map result
     * @param &lt;V2&gt;        value's component type of the map result
     * @param keyMapper   a {@code Function} that maps the keys of type {@code K} to keys of type {@code K2}
     * @param valueMapper a {@code Function} that the values of type {@code V} to values of type {@code V2}
     * @return a new {@code Map}
     * @throws NullPointerException if {@code keyMapper} or {@code valueMapper} is null
     */
    @Override
    &lt;K2, V2&gt; Map&lt;K2, V2&gt; bimap(Function&lt;? super K, ? extends K2&gt; keyMapper, Function&lt;? super V, ? extends V2&gt; valueMapper);

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this map contains a mapping for the specified key.
     *
     * @param key key whose presence in this map is to be tested
     * @return &lt;code&gt;true&lt;/code&gt; if this map contains a mapping for the specified key
     */
    boolean containsKey(K key);

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this map maps one or more keys to the
     * specified value. This operation will require time linear in the map size.
     *
     * @param value value whose presence in this map is to be tested
     * @return &lt;code&gt;true&lt;/code&gt; if this map maps one or more keys to the
     * specified value
     */
    boolean containsValue(V value);

    /**
     * FlatMaps this {@code Map} to a new {@code Map} with different component type.
     *
     * @param mapper A mapper
     * @param &lt;K2&gt;   key's component type of the mapped {@code Map}
     * @param &lt;V2&gt;   value's component type of the mapped {@code Map}
     * @return A new {@code Map}.
     * @throws NullPointerException if {@code mapper} is null
     */
    &lt;K2, V2&gt; Map&lt;K2, V2&gt; flatMap(BiFunction&lt;? super K, ? super V, ? extends Iterable&lt;Tuple2&lt;K2, V2&gt;&gt;&gt; mapper);

    /**
     * Returns the {@code Some} of value to which the specified key
     * is mapped, or {@code None} if this map contains no mapping for the key.
     *
     * @param key the key whose associated value is to be returned
     * @return the {@code Some} of value to which the specified key
     * is mapped, or {@code None} if this map contains no mapping
     * for the key
     */
    Option&lt;V&gt; get(K key);

    /**
     * Returns the keys contained in this map.
     *
     * @return {@code Set} of the keys contained in this map.
     */
    Set&lt;K&gt; keySet();
    
    /**
     * Maps the entries of this {@code Map} to form a new {@code Map}.
     *
     * @param &lt;K2&gt;   key's component type of the map result
     * @param &lt;V2&gt;   value's component type of the map result
     * @param mapper a {@code Function} that maps entries of type {@code (K, V)} to entries of type {@code (K2, V2)}
     * @return a new {@code Map}
     * @throws NullPointerException if {@code mapper} is null
     */
    &lt;K2, V2&gt; Map&lt;K2, V2&gt; map(BiFunction&lt;? super K, ? super V, Tuple2&lt;K2, V2&gt;&gt; mapper);

    /**
     * Maps the values of this {@code Map} while preserving the corresponding keys.
     *
     * @param &lt;V2&gt;        the new value type
     * @param valueMapper a {@code Function} that maps values of type {@code V} to values of type {@code V2}
     * @return a new {@code Map}
     * @throws NullPointerException if {@code valueMapper} is null
     */
    &lt;V2&gt; Map&lt;K, V2&gt; mapValues(Function&lt;? super V, ? extends V2&gt; valueMapper);

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old value is
     * replaced by the specified value.
     *
     * @param key   key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return A new Map containing these elements and that entry.
     */
    Map&lt;K, V&gt; put(K key, V value);

    /**
     * Convenience method for {@code put(entry._1, entry._2)}.
     *
     * @param entry A Map.Tuple2
     * @return A new Map containing these elements and that entry.
     */
    Map&lt;K, V&gt; put(Tuple2&lt;? extends K, ? extends V&gt; entry);

    /**
     * Removes the mapping for a key from this map if it is present.
     *
     * @param key key whose mapping is to be removed from the map
     * @return A new Map containing these elements without the entry
     * specified by that key.
     */
    Map&lt;K, V&gt; remove(K key);

    /**
     * Removes the mapping for a key from this map if it is present.
     *
     * @param keys keys are to be removed from the map
     * @return A new Map containing these elements without the entries
     * specified by that keys.
     */
    Map&lt;K, V&gt; removeAll(Iterable&lt;? extends K&gt; keys);

    @Override
    int size();

    /**
     * Transforms this {@code Map}.
     *
     * @param f   A transformation
     * @param &lt;U&gt; Type of transformation result
     * @return An instance of type {@code U}
     * @throws NullPointerException if {@code f} is null
     */
    default &lt;U&gt; U transform(Function&lt;? super Map&lt;? super K, ? super V&gt;, ? extends U&gt; f) {
<span class="fc" id="L165">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L166">        return f.apply(this);</span>
    }

    default &lt;U&gt; Seq&lt;U&gt; traverse(BiFunction&lt;K, V, ? extends U&gt; mapper) {
<span class="fc" id="L170">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L171">        return foldLeft(List.empty(), (acc, entry) -&gt; acc.append(mapper.apply(entry._1, entry._2)));</span>
    }
    
    @SuppressWarnings(&quot;unchecked&quot;)
	@Override
    default &lt;U&gt; Seq&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">    	if (iterable instanceof Seq) {</span>
<span class="nc" id="L178">    		return (Seq&lt;U&gt;) iterable;</span>
    	} else {
<span class="nc" id="L180">    		return Stream.ofAll(iterable);</span>
    	}
    }

    default &lt;T1, T2&gt; Tuple2&lt;Seq&lt;T1&gt;, Seq&lt;T2&gt;&gt; unzip(BiFunction&lt;? super K, ? super V, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L185">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="pc" id="L186">        return unzip(entry -&gt; unzipper.apply(entry._1, entry._2));</span>
    }

    default &lt;T1, T2, T3&gt; Tuple3&lt;Seq&lt;T1&gt;, Seq&lt;T2&gt;, Seq&lt;T3&gt;&gt; unzip3(BiFunction&lt;? super K, ? super V, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L190">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="pc" id="L191">        return unzip3(entry -&gt; unzipper.apply(entry._1, entry._2));</span>
    }

    Seq&lt;V&gt; values();

    // -- Adjusted return types of Traversable methods

    @Override
    Map&lt;K, V&gt; clear();

    @Override
    default boolean contains(Tuple2&lt;K, V&gt; element) {
<span class="fc" id="L203">        return get(element._1).map(v -&gt; Objects.equals(v, element._2)).orElse(false);</span>
    }

    @Override
    Map&lt;K, V&gt; distinct();

    @Override
    Map&lt;K, V&gt; distinctBy(Comparator&lt;? super Tuple2&lt;K, V&gt;&gt; comparator);

    @Override
    &lt;U&gt; Map&lt;K, V&gt; distinctBy(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends U&gt; keyExtractor);

    @Override
    Map&lt;K, V&gt; drop(int n);

    @Override
    Map&lt;K, V&gt; dropRight(int n);

    @Override
    Map&lt;K, V&gt; dropUntil(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    Map&lt;K, V&gt; dropWhile(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    Map&lt;K, V&gt; filter(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    Map&lt;K, V&gt; filterNot(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    /**
     * Flat-maps this entries to a sequence of values.
     * &lt;p&gt;
     * Please use {@link #flatMap(BiFunction)} if the result should be a {@code Map}
     * 
     * @param mapper A mapper
     * @param &lt;U&gt; Component type
     * @return A sequence of flat-mapped values.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    default &lt;U&gt; Seq&lt;U&gt; flatMap(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="nc" id="L245">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="nc" id="L246">        return (Seq&lt;U&gt;) iterator().flatMap(mapper).toStream();</span>
    }

    @Override
    &lt;C&gt; Map&lt;C, ? extends Map&lt;K, V&gt;&gt; groupBy(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends C&gt; classifier);

    @Override
    Iterator&lt;? extends Map&lt;K, V&gt;&gt; grouped(int size);

    @Override
    Map&lt;K, V&gt; init();

    @Override
    Option&lt;? extends Map&lt;K, V&gt;&gt; initOption();

    @Override
    Iterator&lt;Tuple2&lt;K, V&gt;&gt; iterator();

    @Override
    default int length() {
<span class="fc" id="L266">        return size();</span>
    }

    /**
     * Maps the {@code Map} entries to a sequence of values.
     * &lt;p&gt;
     * Please use {@link #map(BiFunction)} if the result has to be of type {@code Map}.
     *
     * @param mapper A mapper
     * @param &lt;U&gt; Component type
     * @return A sequence of mapped values.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    default &lt;U&gt; Seq&lt;U&gt; map(Function&lt;? super Tuple2&lt;K, V&gt;, ? extends U&gt; mapper) {
<span class="fc" id="L281">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
        // don't remove cast, doesn't compile in Eclipse without it
<span class="fc" id="L283">        return (Seq&lt;U&gt;) iterator().map(mapper).toStream();</span>
    }

    @Override
    Match.MatchMonad.Of&lt;? extends Map&lt;K, V&gt;&gt; match();

    /**
     * Creates a new map which by merging the entries of {@code this} map and {@code that} map.
     * &lt;p&gt;
     * If collisions occur, the value of {@code this} map is taken.
     *
     * @param that the other map
     * @return A merged map
     * @throws NullPointerException if that map is null
     */
    Map&lt;K, V&gt; merge(Map&lt;? extends K, ? extends V&gt; that);

    /**
     * Creates a new map which by merging the entries of {@code this} map and {@code that} map.
     * &lt;p&gt;
     * Uses the specified collision resolution function if two keys are the same.
     * The collision resolution function will always take the first argument from &lt;code&gt;this&lt;/code&gt; map
     * and the second from &lt;code&gt;that&lt;/code&gt; map.
     *
     * @param &lt;U&gt;                 value type of that Map
     * @param that                the other map
     * @param collisionResolution the collision resolution function
     * @return A merged map
     * @throws NullPointerException if that map or the given collision resolution function is null
     */
    &lt;U extends V&gt; Map&lt;K, V&gt; merge(Map&lt;? extends K, U&gt; that, BiFunction&lt;? super V, ? super U, ? extends V&gt; collisionResolution);

    @Override
    Tuple2&lt;? extends Map&lt;K, V&gt;, ? extends Map&lt;K, V&gt;&gt; partition(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    Map&lt;K, V&gt; peek(Consumer&lt;? super Tuple2&lt;K, V&gt;&gt; action);

    @Override
    Map&lt;K, V&gt; replace(Tuple2&lt;K, V&gt; currentElement, Tuple2&lt;K, V&gt; newElement);

    @Override
    Map&lt;K, V&gt; replaceAll(Tuple2&lt;K, V&gt; currentElement, Tuple2&lt;K, V&gt; newElement);

    @Override
    Map&lt;K, V&gt; retainAll(Iterable&lt;? extends Tuple2&lt;K, V&gt;&gt; elements);

    @Override
    Map&lt;K, V&gt; scan(Tuple2&lt;K, V&gt; zero,
                   BiFunction&lt;? super Tuple2&lt;K, V&gt;, ? super Tuple2&lt;K, V&gt;, ? extends Tuple2&lt;K, V&gt;&gt; operation);

    @Override
    &lt;U&gt; Seq&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super Tuple2&lt;K, V&gt;, ? extends U&gt; operation);

    @Override
    &lt;U&gt; Seq&lt;U&gt; scanRight(U zero, BiFunction&lt;? super Tuple2&lt;K, V&gt;, ? super U, ? extends U&gt; operation);

    @Override
    Iterator&lt;? extends Map&lt;K, V&gt;&gt; sliding(int size);

    @Override
    Iterator&lt;? extends Map&lt;K, V&gt;&gt; sliding(int size, int step);

    @Override
    Tuple2&lt;? extends Map&lt;K, V&gt;, ? extends Map&lt;K, V&gt;&gt; span(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    default Spliterator&lt;Tuple2&lt;K, V&gt;&gt; spliterator() {
<span class="fc" id="L351">        return Spliterators.spliterator(iterator(), length(), Spliterator.ORDERED | Spliterator.IMMUTABLE);</span>
    }

    @Override
    Map&lt;K, V&gt; tail();

    @Override
    Option&lt;? extends Map&lt;K, V&gt;&gt; tailOption();

    @Override
    Map&lt;K, V&gt; take(int n);

    @Override
    Map&lt;K, V&gt; takeRight(int n);

    @Override
    Map&lt;K, V&gt; takeUntil(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    Map&lt;K, V&gt; takeWhile(Predicate&lt;? super Tuple2&lt;K, V&gt;&gt; predicate);

    @Override
    default &lt;T1, T2&gt; Tuple2&lt;Seq&lt;T1&gt;, Seq&lt;T2&gt;&gt; unzip(Function&lt;? super Tuple2&lt;K, V&gt;, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L374">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L375">        return iterator().unzip(unzipper).map(Stream::ofAll, Stream::ofAll);</span>
    }

    @Override
    default &lt;T1, T2, T3&gt; Tuple3&lt;Seq&lt;T1&gt;, Seq&lt;T2&gt;, Seq&lt;T3&gt;&gt; unzip3(
            Function&lt;? super Tuple2&lt;K, V&gt;, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L381">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L382">        return iterator().unzip3(unzipper).map(Stream::ofAll, Stream::ofAll, Stream::ofAll);</span>
    }

    @Override
    default &lt;U&gt; Seq&lt;Tuple2&lt;Tuple2&lt;K, V&gt;, U&gt;&gt; zip(Iterable&lt;U&gt; that) {
<span class="fc" id="L387">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L388">        return Stream.ofAll(iterator().zip(that));</span>
    }

    @Override
    default &lt;U&gt; Seq&lt;Tuple2&lt;Tuple2&lt;K, V&gt;, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, Tuple2&lt;K, V&gt; thisElem, U thatElem) {
<span class="fc" id="L393">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L394">        return Stream.ofAll(iterator().zipAll(that, thisElem, thatElem));</span>
    }

    @Override
    default Seq&lt;Tuple2&lt;Tuple2&lt;K, V&gt;, Integer&gt;&gt; zipWithIndex() {
<span class="fc" id="L399">        return Stream.ofAll(iterator().zipWithIndex());</span>
    }

    /**
     * Performs an action on key, value pair.
     *
     * @param action A {@code BiConsumer}
     * @throws NullPointerException if {@code action} is null
     */
    default void forEach(BiConsumer&lt;K, V&gt; action) {
<span class="fc" id="L409">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        for (Tuple2&lt;K, V&gt; t : this) {</span>
<span class="fc" id="L411">            action.accept(t._1, t._2);</span>
<span class="fc" id="L412">        }</span>
<span class="fc" id="L413">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>