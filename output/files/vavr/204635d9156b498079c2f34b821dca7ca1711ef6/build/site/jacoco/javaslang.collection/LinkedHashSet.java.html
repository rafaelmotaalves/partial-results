<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LinkedHashSet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.collection</a> &gt; <span class="el_source">LinkedHashSet.java</span></div><h1>LinkedHashSet.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.collection;

import javaslang.Tuple;
import javaslang.Tuple2;
import javaslang.Tuple3;
import javaslang.control.Match;
import javaslang.control.Option;

import java.io.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.*;
import java.util.stream.Collector;

/**
 * An immutable {@code HashSet} implementation.
 *
 * @param &lt;T&gt; Component type
 * @author Ruslan Sennov, Patryk Najda, Daniel Dietrich
 * @since 2.0.0
 */
public final class LinkedHashSet&lt;T&gt; implements Set&lt;T&gt;, Serializable {

    private static final long serialVersionUID = 1L;

<span class="fc" id="L33">    private static final LinkedHashSet&lt;?&gt; EMPTY = new LinkedHashSet&lt;&gt;(LinkedHashMap.empty());</span>

    private final LinkedHashMap&lt;T, T&gt; map;

<span class="fc" id="L37">    private LinkedHashSet(LinkedHashMap&lt;T, T&gt; map) {</span>
<span class="fc" id="L38">        this.map = map;</span>
<span class="fc" id="L39">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; empty() {
<span class="fc" id="L43">        return (LinkedHashSet&lt;T&gt;) EMPTY;</span>
    }

    /**
     * Returns a {@link Collector} which may be used in conjunction with
     * {@link java.util.stream.Stream#collect(Collector)} to obtain a {@link LinkedHashSet}.
     *
     * @param &lt;T&gt; Component type of the LinkedHashSet.
     * @return A javaslang.collection.LinkedHashSet Collector.
     */
    public static &lt;T&gt; Collector&lt;T, ArrayList&lt;T&gt;, LinkedHashSet&lt;T&gt;&gt; collector() {
<span class="fc" id="L54">        final Supplier&lt;ArrayList&lt;T&gt;&gt; supplier = ArrayList::new;</span>
<span class="fc" id="L55">        final BiConsumer&lt;ArrayList&lt;T&gt;, T&gt; accumulator = ArrayList::add;</span>
<span class="fc" id="L56">        final BinaryOperator&lt;ArrayList&lt;T&gt;&gt; combiner = (left, right) -&gt; {</span>
<span class="fc" id="L57">            left.addAll(right);</span>
<span class="fc" id="L58">            return left;</span>
        };
<span class="fc" id="L60">        final Function&lt;ArrayList&lt;T&gt;, LinkedHashSet&lt;T&gt;&gt; finisher = LinkedHashSet::ofAll;</span>
<span class="fc" id="L61">        return Collector.of(supplier, accumulator, combiner, finisher);</span>
    }

    /**
     * Returns a singleton {@code LinkedHashSet}, i.e. a {@code LinkedHashSet} of one element.
     *
     * @param element An element.
     * @param &lt;T&gt;     The component type
     * @return A new LinkedHashSet instance containing the given element
     */
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; of(T element) {
<span class="fc" id="L72">        return LinkedHashSet.&lt;T&gt; empty().add(element);</span>
    }

    /**
     * Creates a LinkedHashSet of the given elements.
     *
     * &lt;pre&gt;&lt;code&gt;LinkedHashSet.of(1, 2, 3, 4)&lt;/code&gt;&lt;/pre&gt;
     *
     * @param &lt;T&gt;      Component type of the LinkedHashSet.
     * @param elements Zero or more elements.
     * @return A set containing the given elements.
     * @throws NullPointerException if {@code elements} is null
     */
    @SafeVarargs
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; of(T... elements) {
<span class="fc" id="L87">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L88">        LinkedHashMap&lt;T, T&gt; map = LinkedHashMap.empty();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L90">            map = map.put(element, element);</span>
        }
<span class="fc bfc" id="L92" title="All 2 branches covered.">        return map.isEmpty() ? LinkedHashSet.empty() : new LinkedHashSet&lt;&gt;(map);</span>
    }

    /**
     * Returns a LinkedHashSet containing {@code n} values of a given Function {@code f}
     * over a range of integer values from 0 to {@code n - 1}.
     *
     * @param &lt;T&gt; Component type of the LinkedHashSet
     * @param n The number of elements in the LinkedHashSet
     * @param f The Function computing element values
     * @return A LinkedHashSet consisting of elements {@code f(0),f(1), ..., f(n - 1)}
     * @throws NullPointerException if {@code f} is null
     */
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; tabulate(int n, Function&lt;? super Integer, ? extends T&gt; f) {
<span class="fc" id="L106">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L107">        return Collections.tabulate(n, f, LinkedHashSet.empty(), LinkedHashSet::of);</span>
    }

    /**
     * Returns a LinkedHashSet containing {@code n} values supplied by a given Supplier {@code s}.
     *
     * @param &lt;T&gt; Component type of the LinkedHashSet
     * @param n The number of elements in the LinkedHashSet
     * @param s The Supplier computing element values
     * @return A LinkedHashSet of size {@code n}, where each element contains the result supplied by {@code s}.
     * @throws NullPointerException if {@code s} is null
     */
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; fill(int n, Supplier&lt;? extends T&gt; s) {
<span class="fc" id="L120">        Objects.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L121">        return Collections.fill(n, s, LinkedHashSet.empty(), LinkedHashSet::of);</span>
    }

    /**
     * Creates a LinkedHashSet of the given elements.
     *
     * @param elements Set elements
     * @param &lt;T&gt;      The value type
     * @return A new LinkedHashSet containing the given entries
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; LinkedHashSet&lt;T&gt; ofAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L133">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (elements instanceof LinkedHashSet) {</span>
<span class="nc" id="L135">            return (LinkedHashSet&lt;T&gt;) elements;</span>
        } else {
<span class="fc" id="L137">            final LinkedHashMap&lt;T, T&gt; mao = addAll(LinkedHashMap.empty(), elements);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">            return mao.isEmpty() ? empty() : new LinkedHashSet&lt;&gt;(mao);</span>
        }
    }

    /**
     * Creates a LinkedHashSet based on the elements of a boolean array.
     *
     * @param array a boolean array
     * @return A new LinkedHashSet of Boolean values
     */
    public static LinkedHashSet&lt;Boolean&gt; ofAll(boolean[] array) {
<span class="fc" id="L149">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L150">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a byte array.
     *
     * @param array a byte array
     * @return A new LinkedHashSet of Byte values
     */
    public static LinkedHashSet&lt;Byte&gt; ofAll(byte[] array) {
<span class="fc" id="L160">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L161">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a char array.
     *
     * @param array a char array
     * @return A new LinkedHashSet of Character values
     */
    public static LinkedHashSet&lt;Character&gt; ofAll(char[] array) {
<span class="fc" id="L171">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L172">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a double array.
     *
     * @param array a double array
     * @return A new LinkedHashSet of Double values
     */
    public static LinkedHashSet&lt;Double&gt; ofAll(double[] array) {
<span class="fc" id="L182">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L183">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a float array.
     *
     * @param array a float array
     * @return A new LinkedHashSet of Float values
     */
    public static LinkedHashSet&lt;Float&gt; ofAll(float[] array) {
<span class="fc" id="L193">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L194">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of an int array.
     *
     * @param array an int array
     * @return A new LinkedHashSet of Integer values
     */
    public static LinkedHashSet&lt;Integer&gt; ofAll(int[] array) {
<span class="fc" id="L204">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L205">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a long array.
     *
     * @param array a long array
     * @return A new LinkedHashSet of Long values
     */
    public static LinkedHashSet&lt;Long&gt; ofAll(long[] array) {
<span class="fc" id="L215">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L216">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet based on the elements of a short array.
     *
     * @param array a short array
     * @return A new LinkedHashSet of Short values
     */
    public static LinkedHashSet&lt;Short&gt; ofAll(short[] array) {
<span class="fc" id="L226">        Objects.requireNonNull(array, &quot;array is null&quot;);</span>
<span class="fc" id="L227">        return LinkedHashSet.ofAll(Iterator.ofAll(array));</span>
    }

    /**
     * Creates a LinkedHashSet of int numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.range(0, 0)  // = LinkedHashSet()
     * LinkedHashSet.range(2, 0)  // = LinkedHashSet()
     * LinkedHashSet.range(-2, 2) // = LinkedHashSet(-2, -1, 0, 1)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of int values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static LinkedHashSet&lt;Integer&gt; range(int from, int toExclusive) {
<span class="fc" id="L247">        return LinkedHashSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    public static LinkedHashSet&lt;Character&gt; range(char from, char toExclusive) {
<span class="fc" id="L251">        return LinkedHashSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a LinkedHashSet of int numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeBy(1, 3, 1)  // = LinkedHashSet(1, 2)
     * LinkedHashSet.rangeBy(1, 4, 2)  // = LinkedHashSet(1, 3)
     * LinkedHashSet.rangeBy(4, 1, -2) // = LinkedHashSet(4, 2)
     * LinkedHashSet.rangeBy(4, 1, 2)  // = LinkedHashSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static LinkedHashSet&lt;Integer&gt; rangeBy(int from, int toExclusive, int step) {
<span class="fc" id="L277">        return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static LinkedHashSet&lt;Character&gt; rangeBy(char from, char toExclusive, int step) {
<span class="fc" id="L281">        return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    public static LinkedHashSet&lt;Double&gt; rangeBy(double from, double toExclusive, double step) {
<span class="fc" id="L285">        return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a LinkedHashSet of long numbers starting from {@code from}, extending to {@code toExclusive - 1}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.range(0L, 0L)  // = LinkedHashSet()
     * LinkedHashSet.range(2L, 0L)  // = LinkedHashSet()
     * LinkedHashSet.range(-2L, 2L) // = LinkedHashSet(-2L, -1L, 0L, 1L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @return a range of long values as specified or the empty range if {@code from &gt;= toExclusive}
     */
    public static LinkedHashSet&lt;Long&gt; range(long from, long toExclusive) {
<span class="fc" id="L305">        return LinkedHashSet.ofAll(Iterator.range(from, toExclusive));</span>
    }

    /**
     * Creates a LinkedHashSet of long numbers starting from {@code from}, extending to {@code toExclusive - 1},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeBy(1L, 3L, 1L)  // = LinkedHashSet(1L, 2L)
     * LinkedHashSet.rangeBy(1L, 4L, 2L)  // = LinkedHashSet(1L, 3L)
     * LinkedHashSet.rangeBy(4L, 1L, -2L) // = LinkedHashSet(4L, 2L)
     * LinkedHashSet.rangeBy(4L, 1L, 2L)  // = LinkedHashSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toExclusive the last number + 1
     * @param step        the step
     * @return a range of long values as specified or the empty range if&lt;br&gt;
     * {@code from &gt;= toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt;= toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static LinkedHashSet&lt;Long&gt; rangeBy(long from, long toExclusive, long step) {
<span class="fc" id="L331">        return LinkedHashSet.ofAll(Iterator.rangeBy(from, toExclusive, step));</span>
    }

    /**
     * Creates a LinkedHashSet of int numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeClosed(0, 0)  // = LinkedHashSet(0)
     * LinkedHashSet.rangeClosed(2, 0)  // = LinkedHashSet()
     * LinkedHashSet.rangeClosed(-2, 2) // = LinkedHashSet(-2, -1, 0, 1, 2)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of int values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static LinkedHashSet&lt;Integer&gt; rangeClosed(int from, int toInclusive) {
<span class="fc" id="L351">        return LinkedHashSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    public static LinkedHashSet&lt;Character&gt; rangeClosed(char from, char toInclusive) {
<span class="fc" id="L355">        return LinkedHashSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a LinkedHashSet of int numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeClosedBy(1, 3, 1)  // = LinkedHashSet(1, 2, 3)
     * LinkedHashSet.rangeClosedBy(1, 4, 2)  // = LinkedHashSet(1, 3)
     * LinkedHashSet.rangeClosedBy(4, 1, -2) // = LinkedHashSet(4, 2)
     * LinkedHashSet.rangeClosedBy(4, 1, 2)  // = LinkedHashSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static LinkedHashSet&lt;Integer&gt; rangeClosedBy(int from, int toInclusive, int step) {
<span class="fc" id="L381">        return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    public static LinkedHashSet&lt;Character&gt; rangeClosedBy(char from, char toInclusive, int step) {
<span class="fc" id="L385">        return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    public static LinkedHashSet&lt;Double&gt; rangeClosedBy(double from, double toInclusive, double step) {
<span class="fc" id="L389">        return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    /**
     * Creates a LinkedHashSet of long numbers starting from {@code from}, extending to {@code toInclusive}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeClosed(0L, 0L)  // = LinkedHashSet(0L)
     * LinkedHashSet.rangeClosed(2L, 0L)  // = LinkedHashSet()
     * LinkedHashSet.rangeClosed(-2L, 2L) // = LinkedHashSet(-2L, -1L, 0L, 1L, 2L)
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @return a range of long values as specified or the empty range if {@code from &gt; toInclusive}
     */
    public static LinkedHashSet&lt;Long&gt; rangeClosed(long from, long toInclusive) {
<span class="fc" id="L409">        return LinkedHashSet.ofAll(Iterator.rangeClosed(from, toInclusive));</span>
    }

    /**
     * Creates a LinkedHashSet of long numbers starting from {@code from}, extending to {@code toInclusive},
     * with {@code step}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     * &lt;code&gt;
     * LinkedHashSet.rangeClosedBy(1L, 3L, 1L)  // = LinkedHashSet(1L, 2L, 3L)
     * LinkedHashSet.rangeClosedBy(1L, 4L, 2L)  // = LinkedHashSet(1L, 3L)
     * LinkedHashSet.rangeClosedBy(4L, 1L, -2L) // = LinkedHashSet(4L, 2L)
     * LinkedHashSet.rangeClosedBy(4L, 1L, 2L)  // = LinkedHashSet()
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     * @param from        the first number
     * @param toInclusive the last number
     * @param step        the step
     * @return a range of int values as specified or the empty range if&lt;br&gt;
     * {@code from &gt; toInclusive} and {@code step &gt; 0} or&lt;br&gt;
     * {@code from &lt; toInclusive} and {@code step &lt; 0}
     * @throws IllegalArgumentException if {@code step} is zero
     */
    public static LinkedHashSet&lt;Long&gt; rangeClosedBy(long from, long toInclusive, long step) {
<span class="fc" id="L435">        return LinkedHashSet.ofAll(Iterator.rangeClosedBy(from, toInclusive, step));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; add(T element) {
<span class="fc" id="L440">        return new LinkedHashSet&lt;&gt;(map.put(element, element));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; addAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L445">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L446">        final LinkedHashMap&lt;T, T&gt; that = addAll(map, elements);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (that.size() == map.size()) {</span>
<span class="fc" id="L448">            return this;</span>
        } else {
<span class="fc" id="L450">            return new LinkedHashSet&lt;&gt;(that);</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; clear() {
<span class="fc" id="L456">        return empty();</span>
    }

    @Override
    public boolean contains(T element) {
<span class="fc" id="L461">        return map.get(element).isDefined();</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; diff(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L466">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">        if (isEmpty() || elements.isEmpty()) {</span>
<span class="fc" id="L468">            return this;</span>
        } else {
<span class="fc" id="L470">            return removeAll(elements);</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; distinct() {
<span class="fc" id="L476">        return this;</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; distinctBy(Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L481">        Objects.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L482">        return LinkedHashSet.ofAll(iterator().distinctBy(comparator));</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;T&gt; distinctBy(Function&lt;? super T, ? extends U&gt; keyExtractor) {
<span class="fc" id="L487">        Objects.requireNonNull(keyExtractor, &quot;keyExtractor is null&quot;);</span>
<span class="fc" id="L488">        return LinkedHashSet.ofAll(iterator().distinctBy(keyExtractor));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; drop(int n) {
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L494">            return this;</span>
        } else {
<span class="fc" id="L496">            return LinkedHashSet.ofAll(iterator().drop(n));</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; dropRight(int n) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (n &lt;= 0) {</span>
<span class="fc" id="L503">            return this;</span>
        } else {
<span class="fc" id="L505">            return LinkedHashSet.ofAll(iterator().dropRight(n));</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; dropUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L511">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L512">        return dropWhile(predicate.negate());</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L517">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L518">        final LinkedHashSet&lt;T&gt; dropped = LinkedHashSet.ofAll(iterator().dropWhile(predicate));</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        return dropped.length() == length() ? this : dropped;</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L524">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L525">        final LinkedHashSet&lt;T&gt; filtered = LinkedHashSet.ofAll(iterator().filter(predicate));</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        return filtered.length() == length() ? this : filtered;</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; filterNot(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L531">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L532">        return filter(predicate.negate());</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="nc" id="L537">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L539">            return empty();</span>
        } else {
<span class="nc" id="L541">            final LinkedHashMap&lt;U, U&gt; that = foldLeft(LinkedHashMap.empty(),</span>
<span class="nc" id="L542">                    (tree, t) -&gt; addAll(tree, mapper.apply(t)));</span>
<span class="nc" id="L543">            return new LinkedHashSet&lt;&gt;(that);</span>
        }
    }

    @Override
    public &lt;U&gt; U foldRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; f) {
<span class="fc" id="L549">        Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L550">        return iterator().foldRight(zero, f);</span>
    }

    @Override
    public &lt;C&gt; Map&lt;C, LinkedHashSet&lt;T&gt;&gt; groupBy(Function&lt;? super T, ? extends C&gt; classifier) {
<span class="fc" id="L555">        return foldLeft(HashMap.empty(), (map, t) -&gt; {</span>
<span class="fc" id="L556">            final C key = classifier.apply(t);</span>
<span class="fc" id="L557">            final LinkedHashSet&lt;T&gt; values = map.get(key).map(ts -&gt; ts.add(t)).orElse(LinkedHashSet.of(t));</span>
<span class="fc" id="L558">            return map.put(key, values);</span>
        });
    }

    @Override
    public Iterator&lt;LinkedHashSet&lt;T&gt;&gt; grouped(int size) {
<span class="fc" id="L564">        return sliding(size, size);</span>
    }

    @Override
    public boolean hasDefiniteSize() {
<span class="fc" id="L569">        return true;</span>
    }

    @Override
    public T head() {
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L575">            throw new NoSuchElementException(&quot;head of empty set&quot;);</span>
        }
<span class="fc" id="L577">        return iterator().next();</span>
    }

    @Override
    public Option&lt;T&gt; headOption() {
<span class="fc" id="L582">        return iterator().headOption();</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; init() {
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L588">            throw new UnsupportedOperationException(&quot;tail of empty set&quot;);</span>
        } else {
<span class="fc" id="L590">            return new LinkedHashSet&lt;&gt;(map.init());</span>
        }
    }

    @Override
    public Option&lt;LinkedHashSet&lt;T&gt;&gt; initOption() {
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L597">            return Option.none();</span>
        } else {
<span class="fc" id="L599">            return Option.some(init());</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; intersect(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L605">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="pc bpc" id="L606" title="1 of 4 branches missed.">        if (isEmpty() || elements.isEmpty()) {</span>
<span class="fc" id="L607">            return empty();</span>
        } else {
<span class="fc" id="L609">            return retainAll(elements);</span>
        }
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L615">        return map.isEmpty();</span>
    }

    @Override
    public boolean isTraversableAgain() {
<span class="fc" id="L620">        return true;</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L625">        return map.iterator().map(t -&gt; t._1);</span>
    }

    @Override
    public int length() {
<span class="fc" id="L630">        return map.size();</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {
<span class="fc" id="L635">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L637">            return empty();</span>
        } else {
<span class="fc" id="L639">            final LinkedHashMap&lt;U, U&gt; that = foldLeft(LinkedHashMap.empty(), (tree, t) -&gt; {</span>
<span class="fc" id="L640">                final U u = mapper.apply(t);</span>
<span class="fc" id="L641">                return tree.put(u, u);</span>
            });
<span class="fc" id="L643">            return new LinkedHashSet&lt;&gt;(that);</span>
        }
    }

    @Override
    public Match.MatchMonad.Of&lt;LinkedHashSet&lt;T&gt;&gt; match() {
<span class="fc" id="L649">        return Match.of(this);</span>
    }

    @Override
    public String mkString(CharSequence prefix, CharSequence delimiter, CharSequence suffix) {
<span class="fc" id="L654">        return iterator().mkString(prefix, delimiter, suffix);</span>
    }

    @Override
    public Tuple2&lt;LinkedHashSet&lt;T&gt;, LinkedHashSet&lt;T&gt;&gt; partition(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L659">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L660">        final Tuple2&lt;Iterator&lt;T&gt;, Iterator&lt;T&gt;&gt; p = iterator().partition(predicate);</span>
<span class="fc" id="L661">        return Tuple.of(LinkedHashSet.ofAll(p._1), LinkedHashSet.ofAll(p._2));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; peek(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L666">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">        if (!isEmpty()) {</span>
<span class="fc" id="L668">            action.accept(iterator().head());</span>
        }
<span class="fc" id="L670">        return this;</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; remove(T element) {
<span class="fc" id="L675">        final LinkedHashMap&lt;T, T&gt; newMap = map.remove(element);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">        return (newMap == map) ? this : new LinkedHashSet&lt;&gt;(newMap);</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; removeAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L681">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L682">        LinkedHashMap&lt;T, T&gt; that = map;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        for (T element : elements) {</span>
<span class="fc" id="L684">            that = that.remove(element);</span>
<span class="fc" id="L685">        }</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">        return (that == map) ? this : new LinkedHashSet&lt;&gt;(that);</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; replace(T currentElement, T newElement) {
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (map.containsKey(currentElement)) {</span>
<span class="fc" id="L692">            return remove(currentElement).add(newElement);</span>
        } else {
<span class="fc" id="L694">            return this;</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; replaceAll(T currentElement, T newElement) {
<span class="fc" id="L700">        return replace(currentElement, newElement);</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; retainAll(Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L705">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc" id="L706">        final LinkedHashMap&lt;T, T&gt; kept = addAll(LinkedHashMap.empty(), elements);</span>
<span class="fc" id="L707">        LinkedHashMap&lt;T, T&gt; that = LinkedHashMap.empty();</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (T element : this) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (kept.containsKey(element)) {</span>
<span class="fc" id="L710">                that = that.put(element, element);</span>
            }
<span class="fc" id="L712">        }</span>
<span class="fc bfc" id="L713" title="All 4 branches covered.">        return that.isEmpty() ? empty() : that.size() == size() ? this : new LinkedHashSet&lt;&gt;(that);</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; scan(T zero, BiFunction&lt;? super T, ? super T, ? extends T&gt; operation) {
<span class="fc" id="L718">        return scanLeft(zero, operation);</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;U&gt; scanLeft(U zero, BiFunction&lt;? super U, ? super T, ? extends U&gt; operation) {
<span class="fc" id="L723">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L724">        return Collections.scanLeft(this, zero, operation, new java.util.ArrayList&lt;&gt;(), (c, u) -&gt; {</span>
<span class="fc" id="L725">            c.add(u);</span>
<span class="fc" id="L726">            return c;</span>
        }, LinkedHashSet::ofAll);
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;U&gt; scanRight(U zero, BiFunction&lt;? super T, ? super U, ? extends U&gt; operation) {
<span class="fc" id="L732">        Objects.requireNonNull(operation, &quot;operation is null&quot;);</span>
<span class="fc" id="L733">        return Collections.scanRight(this, zero, operation, LinkedHashSet.empty(), LinkedHashSet::add, Function.identity());</span>
    }

    @Override
    public Iterator&lt;LinkedHashSet&lt;T&gt;&gt; sliding(int size) {
<span class="fc" id="L738">        return sliding(size, 1);</span>
    }

    @Override
    public Iterator&lt;LinkedHashSet&lt;T&gt;&gt; sliding(int size, int step) {
<span class="fc" id="L743">        return iterator().sliding(size, step).map(LinkedHashSet::ofAll);</span>
    }

    @Override
    public Tuple2&lt;LinkedHashSet&lt;T&gt;, LinkedHashSet&lt;T&gt;&gt; span(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L748">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L749">        final Tuple2&lt;Iterator&lt;T&gt;, Iterator&lt;T&gt;&gt; t = iterator().span(predicate);</span>
<span class="fc" id="L750">        return Tuple.of(LinkedHashSet.ofAll(t._1), LinkedHashSet.ofAll(t._2));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; tail() {
<span class="fc bfc" id="L755" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L756">            throw new UnsupportedOperationException(&quot;tail of empty set&quot;);</span>
        }
<span class="fc" id="L758">        return remove(head());</span>
    }

    @Override
    public Option&lt;LinkedHashSet&lt;T&gt;&gt; tailOption() {
<span class="fc bfc" id="L763" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L764">            return Option.none();</span>
        } else {
<span class="fc" id="L766">            return Option.some(tail());</span>
        }
    }

    @Override
    public LinkedHashSet&lt;T&gt; take(int n) {
<span class="fc bfc" id="L772" title="All 2 branches covered.">        if (map.size() &lt;= n) {</span>
<span class="fc" id="L773">            return this;</span>
        }
<span class="fc" id="L775">        return LinkedHashSet.ofAll(() -&gt; iterator().take(n));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; takeRight(int n) {
<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (map.size() &lt;= n) {</span>
<span class="fc" id="L781">            return this;</span>
        }
<span class="fc" id="L783">        return LinkedHashSet.ofAll(() -&gt; iterator().takeRight(n));</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L788">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L789">        return takeWhile(predicate.negate());</span>
    }

    @Override
    public LinkedHashSet&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L794">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L795">        LinkedHashSet&lt;T&gt; taken = LinkedHashSet.ofAll(iterator().takeWhile(predicate));</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        return taken.length() == length() ? this : taken;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public LinkedHashSet&lt;T&gt; union(Set&lt;? extends T&gt; elements) {
<span class="fc" id="L802">        Objects.requireNonNull(elements, &quot;elements is null&quot;);</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            if (elements instanceof LinkedHashSet) {</span>
<span class="fc" id="L805">                return (LinkedHashSet&lt;T&gt;) elements;</span>
            } else {
<span class="nc" id="L807">                return LinkedHashSet.ofAll(elements);</span>
            }
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">        } else if (elements.isEmpty()) {</span>
<span class="nc" id="L810">            return this;</span>
        } else {
<span class="fc" id="L812">            final LinkedHashMap&lt;T, T&gt; that = addAll(map, elements);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">            if (that.size() == map.size()) {</span>
<span class="fc" id="L814">                return this;</span>
            } else {
<span class="fc" id="L816">                return new LinkedHashSet&lt;&gt;(that);</span>
            }
        }
    }
    
    @Override
    public &lt;U&gt; LinkedHashSet&lt;U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="nc" id="L823">    	return LinkedHashSet.ofAll(iterable);</span>
    }

    @Override
    public &lt;T1, T2&gt; Tuple2&lt;LinkedHashSet&lt;T1&gt;, LinkedHashSet&lt;T2&gt;&gt; unzip(
            Function&lt;? super T, Tuple2&lt;? extends T1, ? extends T2&gt;&gt; unzipper) {
<span class="fc" id="L829">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L830">        Tuple2&lt;Iterator&lt;T1&gt;, Iterator&lt;T2&gt;&gt; t = iterator().unzip(unzipper);</span>
<span class="fc" id="L831">        return Tuple.of(LinkedHashSet.ofAll(t._1), LinkedHashSet.ofAll(t._2));</span>
    }

    @Override
    public &lt;T1, T2, T3&gt; Tuple3&lt;LinkedHashSet&lt;T1&gt;, LinkedHashSet&lt;T2&gt;, LinkedHashSet&lt;T3&gt;&gt; unzip3(
            Function&lt;? super T, Tuple3&lt;? extends T1, ? extends T2, ? extends T3&gt;&gt; unzipper) {
<span class="fc" id="L837">        Objects.requireNonNull(unzipper, &quot;unzipper is null&quot;);</span>
<span class="fc" id="L838">        Tuple3&lt;Iterator&lt;T1&gt;, Iterator&lt;T2&gt;, Iterator&lt;T3&gt;&gt; t = iterator().unzip3(unzipper);</span>
<span class="fc" id="L839">        return Tuple.of(LinkedHashSet.ofAll(t._1), LinkedHashSet.ofAll(t._2), LinkedHashSet.ofAll(t._3));</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;Tuple2&lt;T, U&gt;&gt; zip(Iterable&lt;U&gt; that) {
<span class="fc" id="L844">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L845">        return LinkedHashSet.ofAll(iterator().zip(that));</span>
    }

    @Override
    public &lt;U&gt; LinkedHashSet&lt;Tuple2&lt;T, U&gt;&gt; zipAll(Iterable&lt;U&gt; that, T thisElem, U thatElem) {
<span class="fc" id="L850">        Objects.requireNonNull(that, &quot;that is null&quot;);</span>
<span class="fc" id="L851">        return LinkedHashSet.ofAll(iterator().zipAll(that, thisElem, thatElem));</span>
    }

    @Override
    public LinkedHashSet&lt;Tuple2&lt;T, Integer&gt;&gt; zipWithIndex() {
<span class="fc" id="L856">        return LinkedHashSet.ofAll(iterator().zipWithIndex());</span>
    }

    // -- Object

    @Override
    public int hashCode() {
<span class="fc" id="L863">        return map.hashCode();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L869" title="All 2 branches covered.">        if (o == this) {</span>
<span class="fc" id="L870">            return true;</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">        } else if (o instanceof LinkedHashSet) {</span>
<span class="fc" id="L872">            final LinkedHashSet&lt;?&gt; that = (LinkedHashSet&lt;?&gt;) o;</span>
<span class="fc bfc" id="L873" title="All 4 branches covered.">            return this.length() == that.length() &amp;&amp; ((LinkedHashSet&lt;Object&gt;) this).containsAll(that);</span>
        } else {
<span class="fc" id="L875">            return false;</span>
        }
    }

    @Override
    public String stringPrefix() {
<span class="fc" id="L881">        return &quot;LinkedHashSet&quot;;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L886">        return mkString(stringPrefix() + &quot;(&quot;, &quot;, &quot;, &quot;)&quot;);</span>
    }

    private static &lt;T&gt; LinkedHashMap&lt;T, T&gt; addAll(LinkedHashMap&lt;T, T&gt; initial,
                                                  Iterable&lt;? extends T&gt; additional) {
<span class="fc" id="L891">        LinkedHashMap&lt;T, T&gt; that = initial;</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        for (T t : additional) {</span>
<span class="fc" id="L893">            that = that.put(t, t);</span>
<span class="fc" id="L894">        }</span>
<span class="fc" id="L895">        return that;</span>
    }

    // -- Serialization

    /**
     * {@code writeReplace} method for the serialization proxy pattern.
     * &lt;p&gt;
     * The presence of this method causes the serialization system to emit a SerializationProxy instance instead of
     * an instance of the enclosing class.
     *
     * @return A SerialiationProxy for this enclosing class.
     */
    private Object writeReplace() {
<span class="fc" id="L909">        return new SerializationProxy&lt;&gt;(this.map);</span>
    }

    /**
     * {@code readObject} method for the serialization proxy pattern.
     * &lt;p&gt;
     * Guarantees that the serialization system will never generate a serialized instance of the enclosing class.
     *
     * @param stream An object serialization stream.
     * @throws InvalidObjectException This method will throw with the message &quot;Proxy required&quot;.
     */
    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
<span class="nc" id="L921">        throw new InvalidObjectException(&quot;Proxy required&quot;);</span>
    }

    /**
     * A serialization proxy which, in this context, is used to deserialize immutable, linked Lists with final
     * instance fields.
     *
     * @param &lt;T&gt; The component type of the underlying list.
     */
    // DEV NOTE: The serialization proxy pattern is not compatible with non-final, i.e. extendable,
    // classes. Also, it may not be compatible with circular object graphs.
    private static final class SerializationProxy&lt;T&gt; implements Serializable {

        private static final long serialVersionUID = 1L;

        // the instance to be serialized/deserialized
        private transient LinkedHashMap&lt;T, T&gt; map;

        /**
         * Constructor for the case of serialization, called by {@link LinkedHashSet#writeReplace()}.
         * &lt;p/&gt;
         * The constructor of a SerializationProxy takes an argument that concisely represents the logical state of
         * an instance of the enclosing class.
         *
         * @param map a Cons
         */
<span class="fc" id="L947">        SerializationProxy(LinkedHashMap&lt;T, T&gt; map) {</span>
<span class="fc" id="L948">            this.map = map;</span>
<span class="fc" id="L949">        }</span>

        /**
         * Write an object to a serialization stream.
         *
         * @param s An object serialization stream.
         * @throws IOException If an error occurs writing to the stream.
         */
        private void writeObject(ObjectOutputStream s) throws IOException {
<span class="fc" id="L958">            s.defaultWriteObject();</span>
<span class="fc" id="L959">            s.writeInt(map.size());</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">            for (Tuple2&lt;T, T&gt; e : map) {</span>
<span class="fc" id="L961">                s.writeObject(e._1);</span>
<span class="fc" id="L962">            }</span>
<span class="fc" id="L963">        }</span>

        /**
         * Read an object from a deserialization stream.
         *
         * @param s An object deserialization stream.
         * @throws ClassNotFoundException If the object's class read from the stream cannot be found.
         * @throws InvalidObjectException If the stream contains no list elements.
         * @throws IOException            If an error occurs reading from the stream.
         */
        private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {
<span class="fc" id="L974">            s.defaultReadObject();</span>
<span class="fc" id="L975">            final int size = s.readInt();</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">            if (size &lt; 0) {</span>
<span class="nc" id="L977">                throw new InvalidObjectException(&quot;No elements&quot;);</span>
            }
<span class="fc" id="L979">            LinkedHashMap&lt;T, T&gt; temp = LinkedHashMap.empty();</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L982">                final T element = (T) s.readObject();</span>
<span class="fc" id="L983">                temp = temp.put(element, element);</span>
            }
<span class="fc" id="L985">            map = temp;</span>
<span class="fc" id="L986">        }</span>

        /**
         * {@code readResolve} method for the serialization proxy pattern.
         * &lt;p&gt;
         * Returns a logically equivalent instance of the enclosing class. The presence of this method causes the
         * serialization system to translate the serialization proxy back into an instance of the enclosing class
         * upon deserialization.
         *
         * @return A deserialized instance of the enclosing class.
         */
        private Object readResolve() {
<span class="fc bfc" id="L998" title="All 2 branches covered.">            return map.isEmpty() ? LinkedHashSet.empty() : new LinkedHashSet&lt;&gt;(map);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>