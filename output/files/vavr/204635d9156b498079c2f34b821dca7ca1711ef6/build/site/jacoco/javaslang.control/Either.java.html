<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Either.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Javaslang</a> &gt; <a href="index.source.html" class="el_package">javaslang.control</a> &gt; <span class="el_source">Either.java</span></div><h1>Either.java</h1><pre class="source lang-java linenums">/*     / \____  _    _  ____   ______  / \ ____  __    _ _____
 *    /  /    \/ \  / \/    \ /  /\__\/  //    \/  \  / /  _  \   Javaslang
 *  _/  /  /\  \  \/  /  /\  \\__\\  \  //  /\  \ /\\/  \__/  /   Copyright 2014-now Daniel Dietrich
 * /___/\_/  \_/\____/\_/  \_/\__\/__/___\_/  \_//  \__/_____/    Licensed under the Apache License, Version 2.0
 */
package javaslang.control;

import javaslang.Value;
import javaslang.algebra.BiFunctor;
import javaslang.algebra.Monad;
import javaslang.collection.Iterator;

import java.io.Serializable;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * Either represents a value of two possible types. An Either is either a {@link Left} or a
 * {@link Right}.
 * &lt;p&gt;
 * If the given Either is a Right and projected to a Left, the Left operations have no effect on the Right value.&lt;br&gt;
 * If the given Either is a Left and projected to a Right, the Right operations have no effect on the Left value.&lt;br&gt;
 * If a Left is projected to a Left or a Right is projected to a Right, the operations have an effect.
 * &lt;p&gt;
 * &lt;strong&gt;Example:&lt;/strong&gt; A compute() function, which results either in an Integer value (in the case of success) or
 * in an error message of type String (in the case of failure). By convention the success case is Right and the failure
 * is Left.
 *
 * &lt;pre&gt;
 * &lt;code&gt;
 * Either&amp;lt;String,Integer&amp;gt; value = compute().right().map(i -&amp;gt; i * 2).toEither();
 * &lt;/code&gt;
 * &lt;/pre&gt;
 *
 * If the result of compute() is Right(1), the value is Right(2).&lt;br&gt;
 * If the result of compute() is Left(&quot;error), the value is Left(&quot;error&quot;).
 *
 * @param &lt;L&gt; The type of the Left value of an Either.
 * @param &lt;R&gt; The type of the Right value of an Either.
 * @author Daniel Dietrich
 * @since 1.0.0
 */
public interface Either&lt;L, R&gt; extends Value&lt;R&gt;, Monad&lt;R&gt;, BiFunctor&lt;L, R&gt; {

    /**
     * Constructs a {@link Right}
     *
     * @param right The value.
     * @param &lt;L&gt;   Type of left value.
     * @param &lt;R&gt;   Type of right value.
     * @return A new {@code Right} instance.
     */
    static &lt;L, R&gt; Either&lt;L, R&gt; right(R right) {
<span class="fc" id="L57">        return new Right&lt;&gt;(right);</span>
    }

    /**
     * Constructs a {@link Left}
     *
     * @param left The value.
     * @param &lt;L&gt;  Type of left value.
     * @param &lt;R&gt;  Type of right value.
     * @return A new {@code Left} instance.
     */
    static &lt;L, R&gt; Either&lt;L, R&gt; left(L left) {
<span class="fc" id="L69">        return new Left&lt;&gt;(left);</span>
    }

    /**
     * Returns the left value.
     *
     * @return The left value.
     * @throws NoSuchElementException if this is a {@code Right}.
     */
    L getLeft();

    /**
     * Returns whether this Either is a Left.
     *
     * @return true, if this is a Left, false otherwise
     */
    boolean isLeft();

    /**
     * Returns whether this Either is a Right.
     *
     * @return true, if this is a Right, false otherwise
     */
    boolean isRight();

    /**
     * Returns a LeftProjection of this Either.
     *
     * @return a new LeftProjection of this
     */
    default LeftProjection&lt;L, R&gt; left() {
<span class="fc" id="L100">        return new LeftProjection&lt;&gt;(this);</span>
    }

    /**
     * Returns a RightProjection of this Either.
     *
     * @return a new RightProjection of this
     */
    default RightProjection&lt;L, R&gt; right() {
<span class="fc" id="L109">        return new RightProjection&lt;&gt;(this);</span>
    }

    /**
     * Maps either the left or the right side of this disjunction.
     *
     * @param leftMapper  maps the left value if this is a Left
     * @param rightMapper maps the right value if this is a Right
     * @param &lt;X&gt;         The new left type of the resulting Either
     * @param &lt;Y&gt;         The new right type of the resulting Either
     * @return A new Either instance
     */
    @Override
    default &lt;X, Y&gt; Either&lt;X, Y&gt; bimap(Function&lt;? super L, ? extends X&gt; leftMapper, Function&lt;? super R, ? extends Y&gt; rightMapper) {
<span class="fc" id="L123">        Objects.requireNonNull(leftMapper, &quot;leftMapper is null&quot;);</span>
<span class="fc" id="L124">        Objects.requireNonNull(rightMapper, &quot;rightMapper is null&quot;);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L126">            return new Right&lt;&gt;(rightMapper.apply(get()));</span>
        } else {
<span class="fc" id="L128">            return new Left&lt;&gt;(leftMapper.apply(getLeft()));</span>
        }
    }

    /**
     * Folds either the left or the right side of this disjunction.
     *
     * @param leftMapper  maps the left value if this is a Left
     * @param rightMapper maps the right value if this is a Right
     * @param &lt;U&gt;         type of the folded value
     * @return A value of type U
     */
    default &lt;U&gt; U fold(Function&lt;? super L, ? extends U&gt; leftMapper, Function&lt;? super R, ? extends U&gt; rightMapper) {
<span class="fc" id="L141">        Objects.requireNonNull(leftMapper, &quot;leftMapper is null&quot;);</span>
<span class="fc" id="L142">        Objects.requireNonNull(rightMapper, &quot;rightMapper is null&quot;);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L144">            return rightMapper.apply(get());</span>
        } else {
<span class="fc" id="L146">            return leftMapper.apply(getLeft());</span>
        }
    }

    /**
     * Gets the Right value or an alternate value, if the projected Either is a Left.
     *
     * @param other a function which converts a Left value to an alternative Right value
     * @return the right value, if the underlying Either is a Right or else the alternative Right value provided by
     * {@code other} by applying the Left value.
     */
    default R orElseGet(Function&lt;? super L, ? extends R&gt; other) {
<span class="fc" id="L158">        Objects.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L160">            return get();</span>
        } else {
<span class="fc" id="L162">            return other.apply(getLeft());</span>
        }
    }

    /**
     * Runs an action in the case this is a projection on a Left value.
     *
     * @param action an action which consumes a Left value
     */
    default void orElseRun(Consumer&lt;? super L&gt; action) {
<span class="fc" id="L172">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (isLeft()) {</span>
<span class="fc" id="L174">            action.accept(getLeft());</span>
        }
<span class="fc" id="L176">    }</span>

    /**
     * Gets the Right value or throws, if the projected Either is a Left.
     *
     * @param &lt;X&gt;               a throwable type
     * @param exceptionFunction a function which creates an exception based on a Left value
     * @return the right value, if the underlying Either is a Right or else throws the exception provided by
     * {@code exceptionFunction} by applying the Left value.
     * @throws X if the projected Either is a Left
     */
    default &lt;X extends Throwable&gt; R orElseThrow(Function&lt;? super L, X&gt; exceptionFunction) throws X {
<span class="fc" id="L188">        Objects.requireNonNull(exceptionFunction, &quot;exceptionFunction is null&quot;);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L190">            return get();</span>
        } else {
<span class="fc" id="L192">            throw exceptionFunction.apply(getLeft());</span>
        }
    }

    /**
     * Converts a {@code Left} to a {@code Right} vice versa by wrapping the value in a new type.
     *
     * @return a new {@code Either}
     */
    default Either&lt;R, L&gt; swap() {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L203">            return new Left&lt;&gt;(get());</span>
        } else {
<span class="fc" id="L205">            return new Right&lt;&gt;(getLeft());</span>
        }
    }

    // -- Adjusted return types of Convertible methods

    @Override
    default Match.MatchMonad.Of&lt;Either&lt;L, R&gt;&gt; match() {
<span class="nc" id="L213">        return Match.of(this);</span>
    }

    // -- Adjusted return types of Monad methods

    /**
     * FlatMaps this right-biased Either.
     *
     * @param mapper A mapper
     * @param &lt;U&gt;    Component type of the mapped right value
     * @return this as {@code Either&lt;L, U&gt;} if this is a Left, otherwise {@link #unit(Iterable)} of the right mapping result
     * @throws NullPointerException if {@code mapper} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default &lt;U&gt; Either&lt;L, U&gt; flatMap(Function&lt;? super R, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="nc" id="L228">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (isRight()) {</span>
<span class="nc" id="L230">            return unit(mapper.apply(get()));</span>
        } else {
<span class="nc" id="L232">            return (Either&lt;L, U&gt;) this;</span>
        }
    }

    /**
     * Maps this right-biased Either.
     *
     * @param mapper A mapper
     * @param &lt;U&gt;    Component type of the mapped right value
     * @return a mapped {@code Monad}
     * @throws NullPointerException if {@code mapper} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    default &lt;U&gt; Either&lt;L, U&gt; map(Function&lt;? super R, ? extends U&gt; mapper) {
<span class="fc" id="L247">        Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (isRight()) {</span>
<span class="fc" id="L249">            return Either.right(mapper.apply(get()));</span>
        } else {
<span class="nc" id="L251">            return (Either&lt;L, U&gt;) this;</span>
        }
    }
    
    /**
     * Maps this right-biased Either.
     *
     * @param leftMapper A mapper
     * @param &lt;U&gt;    Component type of the mapped right value
     * @return a mapped {@code Monad}
     * @throws NullPointerException if {@code mapper} is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default &lt;U&gt; Either&lt;U, R&gt; mapLeft(Function&lt;? super L, ? extends U&gt; leftMapper) {
<span class="fc" id="L265">        Objects.requireNonNull(leftMapper, &quot;mapper is null&quot;);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (isLeft()) {</span>
<span class="fc" id="L267">            return Either.left(leftMapper.apply(getLeft()));</span>
        } else {
<span class="nc" id="L269">            return (Either&lt;U, R&gt;) this;</span>
        }
    }

    // -- Adjusted return types of Value methods

    /**
     * Filters this right-biased {@code Either} by testing a predicate.
     * &lt;p&gt;
     *
     * @param predicate A predicate
     * @return a new {@code Option} instance
     * @throws NullPointerException if {@code predicate} is null
     */
    @Override
    default Option&lt;R&gt; filter(Predicate&lt;? super R&gt; predicate) {
<span class="fc" id="L285">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L286">        return getOption().filter(predicate);</span>
    }

    /**
     * Filters this right-biased {@code Either} by testing the negation of a predicate.
     * &lt;p&gt;
     * Shortcut for {@code filter(predicate.negate()}.
     *
     * @param predicate A predicate
     * @return a new {@code Option} instance
     * @throws NullPointerException if {@code predicate} is null
     */
    @Override
    default Option&lt;R&gt; filterNot(Predicate&lt;? super R&gt; predicate) {
<span class="nc" id="L300">        Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="nc" id="L301">        return getOption().filterNot(predicate);</span>
    }

    /**
     * Gets the right value if this is a {@code Right} or throws if this is a {@code Left}.
     *
     * @return the right value
     * @throws NoSuchElementException if this is a Left.
     */
    @Override
    R get();

    @Override
    default boolean isEmpty() {
<span class="fc" id="L315">        return isLeft();</span>
    }

    /**
     * A right-biased {@code Either} is single-valued.
     *
     * @return {@code true}
     */
    @Override
    default boolean isSingleValued() {
<span class="nc" id="L325">        return true;</span>
    }

    @Override
    default Iterator&lt;R&gt; iterator() {
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (isRight()) {</span>
<span class="fc" id="L331">            return Iterator.of(get());</span>
        } else {
<span class="fc" id="L333">            return Iterator.empty();</span>
        }
    }

    @Override
    default Either&lt;L, R&gt; peek(Consumer&lt;? super R&gt; action) {
<span class="nc" id="L339">        Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (isRight()) {</span>
<span class="nc" id="L341">            action.accept(get());</span>
        }
<span class="nc" id="L343">        return this;</span>
    }
    
    
    @SuppressWarnings(&quot;unchecked&quot;)
	@Override
    default &lt;U&gt; Either&lt;L, U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="nc bnc" id="L350" title="All 2 branches missed.">    	if (iterable instanceof Either) {</span>
<span class="nc" id="L351">    		return (Either&lt;L, U&gt;) iterable;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    	} else if (iterable instanceof Value) {</span>
<span class="nc" id="L353">    		final Value&lt;U&gt; value = (Value&lt;U&gt;) iterable;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">    		return value.isEmpty() ? Either.left(null) : Either.right(value.get());</span>
    	} else {
<span class="nc" id="L356">    		final java.util.Iterator&lt;? extends U&gt; iterator = iterable.iterator();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    		return iterator.hasNext() ? Either.right(iterator.next()) : Either.left(null);</span>
    	}
    }

    // -- Object.*

    @Override
    boolean equals(Object o);

    @Override
    int hashCode();

    @Override
    String toString();

    // -- Left/Right projections

    /**
     * A left projection of an Either.
     *
     * @param &lt;L&gt; The type of the Left value of an Either.
     * @param &lt;R&gt; The type of the Right value of an Either.
     * @since 1.0.0
     */
    final class LeftProjection&lt;L, R&gt; implements Value&lt;L&gt;, Monad&lt;L&gt;, BiFunctor&lt;L, R&gt; {

        private final Either&lt;L, R&gt; either;

<span class="fc" id="L385">        private LeftProjection(Either&lt;L, R&gt; either) {</span>
<span class="fc" id="L386">            this.either = either;</span>
<span class="fc" id="L387">        }</span>

        @Override
        public &lt;U1, U2&gt; BiFunctor&lt;U1, U2&gt; bimap(Function&lt;? super L, ? extends U1&gt; f1, Function&lt;? super R, ? extends U2&gt; f2) {
<span class="nc" id="L391">            return either.bimap(f1, f2).left();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L396">            return either.isRight();</span>
        }

        /**
         * A {@code LeftProjection} is single-valued.
         *
         * @return {@code true}
         */
        @Override
        public boolean isSingleValued() {
<span class="nc" id="L406">            return true;</span>
        }

        /**
         * Gets the Left value or throws.
         *
         * @return the left value, if the underlying Either is a Left
         * @throws NoSuchElementException if the underlying either of this LeftProjection is a Right
         */
        @Override
        public L get() {
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L418">                return either.getLeft();</span>
            } else {
<span class="fc" id="L420">                throw new NoSuchElementException(&quot;LeftProjection.get() on Right&quot;);</span>
            }
        }

        /**
         * Gets the Left value or an alternate value, if the projected Either is a Right.
         *
         * @param other an alternative value
         * @return the left value, if the underlying Either is a Left or else {@code other}
         * @throws NoSuchElementException if the underlying either of this LeftProjection is a Right
         */
        @Override
        public L orElse(L other) {
<span class="fc bfc" id="L433" title="All 2 branches covered.">            return either.isLeft() ? either.getLeft() : other;</span>
        }

        /**
         * Gets the Left value or an alternate value, if the projected Either is a Right.
         *
         * @param other a function which converts a Right value to an alternative Left value
         * @return the left value, if the underlying Either is a Left or else the alternative Left value provided by
         * {@code other} by applying the Right value.
         */
        public L orElseGet(Function&lt;? super R, ? extends L&gt; other) {
<span class="fc" id="L444">            Objects.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L446">                return either.getLeft();</span>
            } else {
<span class="fc" id="L448">                return other.apply(either.get());</span>
            }
        }

        /**
         * Runs an action in the case this is a projection on a Right value.
         *
         * @param action an action which consumes a Right value
         */
        public void orElseRun(Consumer&lt;? super R&gt; action) {
<span class="fc" id="L458">            Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (either.isRight()) {</span>
<span class="fc" id="L460">                action.accept(either.get());</span>
            }
<span class="fc" id="L462">        }</span>

        /**
         * Gets the Left value or throws, if the projected Either is a Right.
         *
         * @param &lt;X&gt;               a throwable type
         * @param exceptionFunction a function which creates an exception based on a Right value
         * @return the left value, if the underlying Either is a Left or else throws the exception provided by
         * {@code exceptionFunction} by applying the Right value.
         * @throws X if the projected Either is a Right
         */
        public &lt;X extends Throwable&gt; L orElseThrow(Function&lt;? super R, X&gt; exceptionFunction) throws X {
<span class="fc" id="L474">            Objects.requireNonNull(exceptionFunction, &quot;exceptionFunction is null&quot;);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L476">                return either.getLeft();</span>
            } else {
<span class="fc" id="L478">                throw exceptionFunction.apply(either.get());</span>
            }
        }

        /**
         * Returns the underlying either of this projection.
         *
         * @return the underlying either
         */
        public Either&lt;L, R&gt; toEither() {
<span class="fc" id="L488">            return either;</span>
        }

        /**
         * Returns {@code Some} value of type L if this is a left projection of a Left value and the predicate
         * applies to the underlying value.
         *
         * @param predicate A predicate
         * @return A new Option
         */
        @Override
        public Option&lt;L&gt; filter(Predicate&lt;? super L&gt; predicate) {
<span class="fc" id="L500">            Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L502">                final L value = either.getLeft();</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                return predicate.test(value) ? Option.some(value) : Option.none();</span>
            } else {
<span class="fc" id="L505">                return Option.none();</span>
            }
        }

        @Override
        public Option&lt;L&gt; filterNot(Predicate&lt;? super L&gt; predicate) {
<span class="nc" id="L511">            Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="nc" id="L512">            return filter(predicate.negate());</span>
        }

        /**
         * FlatMaps this LeftProjection.
         *
         * @param mapper A mapper
         * @param &lt;U&gt;    Component type of the mapped left value
         * @return this as {@code LeftProjection&lt;L, U&gt;} if a Right is underlying, otherwise a the mapping result of the left value.
         * @throws NullPointerException if {@code mapper} is null
         */
        @SuppressWarnings(&quot;unchecked&quot;)
		@Override
        public &lt;U&gt; LeftProjection&lt;U, R&gt; flatMap(Function&lt;? super L, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L526">            Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L528">                return unit(mapper.apply(either.getLeft()));</span>
            } else {
<span class="fc" id="L530">                return (LeftProjection&lt;U, R&gt;) this;</span>
            }
        }

        /**
         * Maps the left value if the projected Either is a Left.
         *
         * @param mapper A mapper which takes a left value and returns a value of type U
         * @param &lt;U&gt;    The new type of a Left value
         * @return A new LeftProjection
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;U&gt; LeftProjection&lt;U, R&gt; map(Function&lt;? super L, ? extends U&gt; mapper) {
<span class="fc" id="L543">            Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L545">            	return either.mapLeft(mapper).left();</span>
            } else {
<span class="fc" id="L547">                return (LeftProjection&lt;U, R&gt;) this;</span>
            }
        }

        @Override
        public Match.MatchMonad.Of&lt;LeftProjection&lt;L, R&gt;&gt; match() {
<span class="nc" id="L553">            return Match.of(this);</span>
        }

        /**
         * Applies the given action to the value if the projected either is a Left. Otherwise nothing happens.
         *
         * @param action An action which takes a left value
         * @return this LeftProjection
         */
        @Override
        public LeftProjection&lt;L, R&gt; peek(Consumer&lt;? super L&gt; action) {
<span class="fc" id="L564">            Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L566">                action.accept(either.getLeft());</span>
            }
<span class="fc" id="L568">            return this;</span>
        }

        /**
         * Transforms this {@code LeftProjection}.
         *
         * @param f   A transformation
         * @param &lt;U&gt; Type of transformation result
         * @return An instance of type {@code U}
         * @throws NullPointerException if {@code f} is null
         */
        public &lt;U&gt; U transform(Function&lt;? super LeftProjection&lt;? super L, ? super R&gt;, ? extends U&gt; f) {
<span class="nc" id="L580">            Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="nc" id="L581">            return f.apply(this);</span>
        }
        
        @SuppressWarnings(&quot;unchecked&quot;)
    	@Override
        public &lt;U&gt; LeftProjection&lt;U, R&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        	if (iterable instanceof LeftProjection) {</span>
<span class="fc" id="L588">        		return (LeftProjection&lt;U, R&gt;) iterable;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        	} else if (iterable instanceof Value) {</span>
<span class="nc" id="L590">        		final Value&lt;U&gt; value = (Value&lt;U&gt;) iterable;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        		final Either&lt;U, R&gt; result = value.isEmpty() ? Either.right(null) : Either.left(value.get());</span>
<span class="nc" id="L592">        		return result.left();</span>
        	} else {
<span class="nc" id="L594">        		final java.util.Iterator&lt;? extends U&gt; iterator = iterable.iterator();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">        		final Either&lt;U, R&gt; result = iterator.hasNext() ? Either.right(null) : Either.left(iterator.next());</span>
<span class="nc" id="L596">        		return result.left();</span>
        	}
        }

        @Override
        public Iterator&lt;L&gt; iterator() {
<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (either.isLeft()) {</span>
<span class="fc" id="L603">                return Iterator.of(either.getLeft());</span>
            } else {
<span class="fc" id="L605">                return Iterator.empty();</span>
            }
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L611" title="1 of 6 branches missed.">            return (obj == this) || (obj instanceof LeftProjection &amp;&amp; Objects.equals(either, ((LeftProjection&lt;?, ?&gt;) obj).either));</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L616">            return Objects.hashCode(either);</span>
        }

        @Override
        public String stringPrefix() {
<span class="fc" id="L621">            return &quot;LeftProjection&quot;;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L626">            return stringPrefix() + &quot;(&quot; + either + &quot;)&quot;;</span>
        }
    }

    /**
     * A right projection of an Either.
     *
     * @param &lt;L&gt; The type of the Left value of an Either.
     * @param &lt;R&gt; The type of the Right value of an Either.
     * @since 1.0.0
     */
    final class RightProjection&lt;L, R&gt; implements Value&lt;R&gt;, Monad&lt;R&gt;, BiFunctor&lt;L, R&gt; {

        private final Either&lt;L, R&gt; either;

<span class="fc" id="L641">        private RightProjection(Either&lt;L, R&gt; either) {</span>
<span class="fc" id="L642">            this.either = either;</span>
<span class="fc" id="L643">        }</span>

        @Override
        public &lt;U1, U2&gt; BiFunctor&lt;U1, U2&gt; bimap(Function&lt;? super L, ? extends U1&gt; f1, Function&lt;? super R, ? extends U2&gt; f2) {
<span class="nc" id="L647">            return either.bimap(f1, f2).right();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L652">            return either.isLeft();</span>
        }

        /**
         * A {@code RightProjection} is single-valued.
         *
         * @return {@code true}
         */
        @Override
        public boolean isSingleValued() {
<span class="nc" id="L662">            return true;</span>
        }

        /**
         * Gets the Right value or throws.
         *
         * @return the left value, if the underlying Either is a Right
         * @throws NoSuchElementException if the underlying either of this RightProjection is a Left
         */
        @Override
        public R get() {
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (either.isRight()) {</span>
<span class="fc" id="L674">                return either.get();</span>
            } else {
<span class="fc" id="L676">                throw new NoSuchElementException(&quot;RightProjection.get() on Left&quot;);</span>
            }
        }

        /**
         * Gets the Right value or an alternate value, if the projected Either is a Left.
         *
         * @param other an alternative value
         * @return the right value, if the underlying Either is a Right or else {@code other}
         * @throws NoSuchElementException if the underlying either of this RightProjection is a Left
         */
        @Override
        public R orElse(R other) {
<span class="fc" id="L689">            return either.orElse(other);</span>
        }

        /**
         * Gets the Right value or an alternate value, if the projected Either is a Left.
         *
         * @param other a function which converts a Left value to an alternative Right value
         * @return the right value, if the underlying Either is a Right or else the alternative Right value provided by
         * {@code other} by applying the Left value.
         */
        public R orElseGet(Function&lt;? super L, ? extends R&gt; other) {
<span class="fc" id="L700">            Objects.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L701">            return either.orElseGet(other);</span>
        }

        /**
         * Runs an action in the case this is a projection on a Left value.
         *
         * @param action an action which consumes a Left value
         */
        public void orElseRun(Consumer&lt;? super L&gt; action) {
<span class="fc" id="L710">            Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc" id="L711">            either.orElseRun(action);</span>
<span class="fc" id="L712">        }</span>

        /**
         * Gets the Right value or throws, if the projected Either is a Left.
         *
         * @param &lt;X&gt;               a throwable type
         * @param exceptionFunction a function which creates an exception based on a Left value
         * @return the right value, if the underlying Either is a Right or else throws the exception provided by
         * {@code exceptionFunction} by applying the Left value.
         * @throws X if the projected Either is a Left
         */
        public &lt;X extends Throwable&gt; R orElseThrow(Function&lt;? super L, X&gt; exceptionFunction) throws X {
<span class="fc" id="L724">            Objects.requireNonNull(exceptionFunction, &quot;exceptionFunction is null&quot;);</span>
<span class="fc" id="L725">            return either.orElseThrow(exceptionFunction);</span>
        }

        /**
         * Returns the underlying either of this projection.
         *
         * @return the underlying either
         */
        public Either&lt;L, R&gt; toEither() {
<span class="fc" id="L734">            return either;</span>
        }

        /**
         * Returns {@code Some} value of type R if this is a right projection of a Right value and the predicate
         * applies to the underlying value.
         *
         * @param predicate A predicate
         * @return A new Option
         */
        @Override
        public Option&lt;R&gt; filter(Predicate&lt;? super R&gt; predicate) {
<span class="fc" id="L746">            Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L747">            return either.filter(predicate);</span>
        }

        @Override
        public Option&lt;R&gt; filterNot(Predicate&lt;? super R&gt; predicate) {
<span class="nc" id="L752">            Objects.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="nc" id="L753">            return either.filterNot(predicate);</span>
        }

        /**
         * FlatMaps this RightProjection.
         *
         * @param mapper A mapper
         * @param &lt;U&gt;    Component type of the mapped right value
         * @return this as {@code RightProjection&lt;L, U&gt;} if a Left is underlying, otherwise a the mapping result of the right value.
         * @throws NullPointerException if {@code mapper} is null
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;U&gt; RightProjection&lt;L, U&gt; flatMap(Function&lt;? super R, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L767">            Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (either.isRight()) {</span>
<span class="fc" id="L769">                return unit(mapper.apply(either.get()));</span>
            } else {
<span class="fc" id="L771">                return (RightProjection&lt;L, U&gt;) this;</span>
            }
        }

        /**
         * Maps the right value if the projected Either is a Right.
         *
         * @param mapper A mapper which takes a right value and returns a value of type U
         * @param &lt;U&gt;    The new type of a Right value
         * @return A new RightProjection
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;U&gt; RightProjection&lt;L, U&gt; map(Function&lt;? super R, ? extends U&gt; mapper) {
<span class="fc" id="L784">            Objects.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">            if (either.isRight()) {</span>
<span class="fc" id="L786">                return either.map(mapper).right();</span>
            } else {
<span class="fc" id="L788">                return (RightProjection&lt;L, U&gt;) this;</span>
            }
        }

        @Override
        public Match.MatchMonad.Of&lt;RightProjection&lt;L, R&gt;&gt; match() {
<span class="nc" id="L794">            return Match.of(this);</span>
        }

        /**
         * Applies the given action to the value if the projected either is a Right. Otherwise nothing happens.
         *
         * @param action An action which takes a right value
         * @return this {@code Either} instance
         */
        @Override
        public RightProjection&lt;L, R&gt; peek(Consumer&lt;? super R&gt; action) {
<span class="fc" id="L805">            Objects.requireNonNull(action, &quot;action is null&quot;);</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">            if (either.isRight()) {</span>
<span class="fc" id="L807">                action.accept(either.get());</span>
            }
<span class="fc" id="L809">            return this;</span>
        }

        /**
         * Transforms this {@code RightProjection}.
         *
         * @param f   A transformation
         * @param &lt;U&gt; Type of transformation result
         * @return An instance of type {@code U}
         * @throws NullPointerException if {@code f} is null
         */
        public &lt;U&gt; U transform(Function&lt;? super RightProjection&lt;? super L, ? super R&gt;, ? extends U&gt; f) {
<span class="nc" id="L821">            Objects.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="nc" id="L822">            return f.apply(this);</span>
        }
        
        @SuppressWarnings(&quot;unchecked&quot;)
    	@Override
        public &lt;U&gt; RightProjection&lt;L, U&gt; unit(Iterable&lt;? extends U&gt; iterable) {
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">        	if (iterable instanceof RightProjection) {</span>
<span class="fc" id="L829">        		return (RightProjection&lt;L, U&gt;) iterable;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        	} else if (iterable instanceof Value) {</span>
<span class="nc" id="L831">        		final Value&lt;U&gt; value = (Value&lt;U&gt;) iterable;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">        		final Either&lt;L, U&gt; result = value.isEmpty() ? Either.left(null) : Either.right(value.get());</span>
<span class="nc" id="L833">        		return result.right();</span>
        	} else {
<span class="nc" id="L835">        		final java.util.Iterator&lt;? extends U&gt; iterator = iterable.iterator();</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">        		final Either&lt;L, U&gt; result = iterator.hasNext() ? Either.left(null) : Either.right(iterator.next());</span>
<span class="nc" id="L837">        		return result.right();</span>
        	}
        }

        @Override
        public Iterator&lt;R&gt; iterator() {
<span class="fc" id="L843">            return either.iterator();</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L848" title="1 of 6 branches missed.">            return (obj == this) || (obj instanceof RightProjection &amp;&amp; Objects.equals(either, ((RightProjection&lt;?, ?&gt;) obj).either));</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L853">            return Objects.hashCode(either);</span>
        }

        @Override
        public String stringPrefix() {
<span class="fc" id="L858">            return &quot;RightProjection&quot;;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L863">            return stringPrefix() + &quot;(&quot; + either + &quot;)&quot;;</span>
        }
    }

    /**
     * The {@code Left} version of an {@code Either}.
     *
     * @param &lt;L&gt; left component type
     * @param &lt;R&gt; right component type
     * @author Daniel Dietrich
     * @since 1.0.0
     */
    final class Left&lt;L, R&gt; implements Either&lt;L, R&gt;, Serializable {

        private static final long serialVersionUID = 1L;

        private final L value;

        /**
         * Constructs a {@code Left}.
         *
         * @param value a left value
         */
<span class="fc" id="L886">        private Left(L value) {</span>
<span class="fc" id="L887">            this.value = value;</span>
<span class="fc" id="L888">        }</span>

        @Override
        public R get() {
<span class="nc" id="L892">            throw new NoSuchElementException(&quot;get() on Left&quot;);</span>
        }

        @Override
        public L getLeft() {
<span class="fc" id="L897">            return value;</span>
        }

        @Override
        public boolean isLeft() {
<span class="fc" id="L902">            return true;</span>
        }

        @Override
        public boolean isRight() {
<span class="fc" id="L907">            return false;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L912" title="1 of 6 branches missed.">            return (obj == this) || (obj instanceof Left &amp;&amp; Objects.equals(value, ((Left&lt;?, ?&gt;) obj).value));</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L917">            return Objects.hashCode(value);</span>
        }

        @Override
        public String stringPrefix() {
<span class="fc" id="L922">            return &quot;Left&quot;;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L927">            return stringPrefix() + &quot;(&quot; + value + &quot;)&quot;;</span>
        }
    }

    /**
     * The {@code Right} version of an {@code Either}.
     *
     * @param &lt;L&gt; left component type
     * @param &lt;R&gt; right component type
     * @author Daniel Dietrich
     * @since 1.0.0
     */
    final class Right&lt;L, R&gt; implements Either&lt;L, R&gt;, Serializable {

        private static final long serialVersionUID = 1L;

        private final R value;

        /**
         * Constructs a {@code Right}.
         *
         * @param value a right value
         */
<span class="fc" id="L950">        private Right(R value) {</span>
<span class="fc" id="L951">            this.value = value;</span>
<span class="fc" id="L952">        }</span>

        @Override
        public R get() {
<span class="fc" id="L956">            return value;</span>
        }

        @Override
        public L getLeft() {
<span class="nc" id="L961">            throw new NoSuchElementException(&quot;getLeft() on Right&quot;);</span>
        }

        @Override
        public boolean isLeft() {
<span class="fc" id="L966">            return false;</span>
        }

        @Override
        public boolean isRight() {
<span class="fc" id="L971">            return true;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L976" title="1 of 6 branches missed.">            return (obj == this) || (obj instanceof Right &amp;&amp; Objects.equals(value, ((Right&lt;?, ?&gt;) obj).value));</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L981">            return Objects.hashCode(value);</span>
        }

        @Override
        public String stringPrefix() {
<span class="fc" id="L986">            return &quot;Right&quot;;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L991">            return stringPrefix() + &quot;(&quot; + value + &quot;)&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>